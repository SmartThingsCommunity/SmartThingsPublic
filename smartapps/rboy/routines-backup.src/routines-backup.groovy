/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "01.02.01"
}

/**
* Backup for Routines to verify that they did their job and if not complete their actions
*
* Copyright RBoy Apps, modification, reuse or redistribution of code is not allowed without permission
*
* 2018-12-11 - (v01.02.01) Fix for saved (dynamic) settings not showing due to change in ST app behavior
* 2018-11-22 - (v01.02.00) Added support for announcing messages over a TTS device
* 2018-9-21 - (v01.01.00) Added support to check and change target mode
* 2018-7-27 - (v01.00.00) Initial release
*
*/
definition(
    name: "Routines Backup",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Run a verification check to ensure that Routines did they job and if not complete the actions",
    category: "Safety & Security",
    iconUrl: "http://smartthings.rboyapps.com/images/Routines.png",
    iconX2Url: "http://smartthings.rboyapps.com/images/Routines.png",
    iconX3Url: "http://smartthings.rboyapps.com/images/Routines.png")

preferences {
    page(name: "mainPage")
    page(name: "modeDoorMonitorPage")
}

private getRoutines() {
    def phrases = location.helloHome?.getPhrases()
    phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
    return phrases
}

private getCheckingDescription(mode) {
    def description = ""

    def devices = [
        			settings."doors${mode}",
        			settings."doorsflip${mode}",
        			settings."garagedoors${mode}",
                   	settings."garagedoorsflip${mode}",
        			settings."locks${mode}",
               	    settings."locksflip${mode}",
               	    settings."switches${mode}",
               	    settings."switchesflip${mode}",
               	    settings."shades${mode}",
               	    settings."shadesflip${mode}",
                   	settings."valves${mode}",
        			settings."valvesflip${mode}",
                    settings."thermostats${mode}",
    			]
    
    for (device in devices) {                   
        description += device ? (description ? "\n  " : "") + device?.join("\n  ") : ""
    }

    if (!description) { // Nothing selected
        description = "No devices selected"
    } else {
        description = "Checking:\n  " + description // Add the header
    }

    return description
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Routines Backup v${clientVersion()}", install: true, uninstall: true) {
        section() {
            paragraph "Click on each Routine below to configure verification checks, notifications and actions"
        }

        if (!routines) {
            section {
                paragraph title: "No Routines found on your SmartThing hub, nothing to configure", required: true, ""
            }
        } else {
            routines.each { mode ->
                section {
                    // Unlock actions for each mode
                    def hrefParams = [
                        mode: mode as String,
                        name: mode as String,
                        passed: true 
                    ]
                    log.trace "Routine $mode"
                    href(name: "modeDoorMonitor", params: hrefParams, title: "${mode}", page: "modeDoorMonitorPage", description: getCheckingDescription(mode), required: false, image: "http://smartthings.rboyapps.com/images/Routines.png")
                }
            }
        }

        section("General Notification Options") {
            input("recipients", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                input name: "notify", title: "Send push notifications", type: "bool", defaultValue: true, required: false
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*4447654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
            }
            input name: "audioDevices", title: "Play notifications on these devices", type: "capability.audioNotification", required: false, multiple: true, image: "http://www.rboyapps.com/images/Horn.png"
        }

        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }
    }
}

def modeDoorMonitorPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def mode = ""
    def name = ""
    // Get mode from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.mode) {
        mode = params.mode
        name = params.name
        log.trace "Passed from main page, using params lookup for mode $mode, name $name"
    } else if (atomicState.params) {
        mode = atomicState.params.mode ?: ""
        name = atomicState.params.name ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for mode $mode, name $name"
    } else {
        log.error "Invalid params, no mode found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Mode Door Monitor, mode:$mode, name $name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"modeDoorMonitorPage", title: "Configure notifications and actions after running routine " + (name ?: ""), uninstall: false, install: false) {
        section("Choose Door(s) and Window(s)") {
            paragraph "Notify if any of these doors or windows are left open/closed"
            input "doors${mode}", "capability.contactSensor", title: "Check for Open doors/windows", required: false, multiple:true
            input "doorsflip${mode}", "capability.contactSensor", title: "Check for Closed doors/windows", required: false, multiple:true
        }

        section("Choose Garage Door(s)") {
            paragraph "Notify if any of these selected garage doors are left open/closed"
            input "garagedoors${mode}", "capability.garageDoorControl", title: "Check for Open garage doors", required: false, multiple:true, submitOnChange: true
            if (settings."garagedoors${mode}") {
                input "garagedoorsoff${mode}", "bool", title: "Close them?", required: false
            }
            input "garagedoorsflip${mode}", "capability.garageDoorControl", title: "Check for Closed garage doors", required: false, multiple:true, submitOnChange: true
            if (settings."garagedoorsflip${mode}") {
                input "garagedoorsopen${mode}", "bool", title: "Open them?", required: false
            }
        }

        section("Choose Lock(s)") {
            paragraph "Notify if any of these selected locks are Unlocked/Locked"
            input "locks${mode}", "capability.lock", title: "Check for Unlocked locks", required: false, multiple:true, submitOnChange: true
            if (settings."locks${mode}") {
                input "locksoff${mode}", "bool", title: "Lock them?", required: false
            }
            input "locksflip${mode}", "capability.lock", title: "Check for Locked locks", required: false, multiple:true, submitOnChange: true
            if (settings."locksflip${mode}") {
                input "locksopen${mode}", "bool", title: "Unlock them?", required: false
            }
        }

        section("Choose Switch(s)") {
            paragraph "Notify if any of these selected switches are On/Off"
            input "switches${mode}", "capability.switch", title: "Check for switches left On", required: false, multiple:true, submitOnChange: true
            if (settings."switches${mode}") {
                input "switchesoff${mode}", "bool", title: "Turn them off?", required: false
            }
            input "switchesflip${mode}", "capability.switch", title: "Check for switches left Off", required: false, multiple:true, submitOnChange: true
            if (settings."switchesflip${mode}") {
                input "switcheson${mode}", "bool", title: "Turn them on?", required: false
            }
        }

        section("Choose Windows Shade/Blind(s)") {
            paragraph "Notify if any of these selected window shades/blinds are Open/Closed"
            input "shades${mode}", "capability.windowShade", title: "Check for shades left Open", required: false, multiple:true, submitOnChange: true
            if (settings."shades${mode}") {
                input "shadesoff${mode}", "bool", title: "Close them?", required: false
            }
            input "shadesflip${mode}", "capability.windowShade", title: "Check for shades left Closed", required: false, multiple:true, submitOnChange: true
            if (settings."shadesflip${mode}") {
                input "shadeson${mode}", "bool", title: "Open them?", required: false
            }
        }

        section("Choose Valve(s)") {
            paragraph "Notify if any of these selected valves are Open/Closed"
            input "valves${mode}", "capability.valve", title: "Check for valves left Open", required: false, multiple:true, submitOnChange: true
            if (settings."valves${mode}") {
                input "valvesoff${mode}", "bool", title: "Close them?", required: false
            }
            input "valvesflip${mode}", "capability.valve", title: "Check for valves left Closed", required: false, multiple:true, submitOnChange: true
            if (settings."valvesflip${mode}") {
                input "valveson${mode}", "bool", title: "Open them?", required: false
            }
        }

        section("Choose Thermostat(s)") {
            paragraph "Notify the thermostat heat/cool setpoints do not match"
            input "thermostats${mode}", "capability.thermostat", title: "Check Thermostats setpoint", required: false, multiple:true, submitOnChange: true
            if (settings."thermostats${mode}") {
                input "heatingSetpoint${mode}", "decimal", title: "...Heating", required: true
                input "coolingSetpoint${mode}", "decimal", title: "...Cooling", required: true
                input "thermostatsSet${mode}", "bool", title: "Update setpoints?", required: false
            }
        }
        
        section("Check Mode") {
            paragraph "Notify the hub Mode has not changed"
            input "targetMode${mode}", "mode", title: "New mode", description: "Select the target hub mode", required: false, multiple: false, submitOnChange: true
            if (settings."targetMode${mode}") {
                input "targetModeSet${mode}", "bool", title: "Change mode?", required: false
            }
        }

        section("Run Routine") {
            def phrases = location.helloHome?.getPhrases()
            phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
            input "homePhrase${mode}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: settings."homePhrase${mode}"
        }
        
        section("Routine Verification and Notifications Options") {
            paragraph "Use this option to delay before checking/taking actions for any devices after the routine runs\nThis can allow for an exit delay or for apps to complete their tasks"
            input "delayAction${mode}", "number", title: "Delay by (seconds)", required: false, range: "1..*"

            paragraph "Enabling routine specific notifications will override over any general notifications defined on the first page"
            input "modeOverrideNotifications${mode}", "bool", title: "Enable $name routine specific notifications", required: false,  submitOnChange: true
            if (settings."modeOverrideNotifications${mode}") {
                input("recipients${mode}", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                    input "notify${mode}", "bool", title: "Send push notifications", defaultValue: true, required: false
                    paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*4447654321"
                    input "sms${mode}", "phone", title: "Send SMS notification to (optional):", required: false
                }
                input "audioDevices${mode}", "capability.audioNotification", title: "Play notifications on these devices", required: false, multiple: true, image: "http://www.rboyapps.com/images/Horn.png"
            }
        }
    }
}

def installed() {
    log.debug "Installed"

    subscribeToEvents()
}

def updated() {
    log.debug "Updated"

    unsubscribe()
    unschedule()
    subscribeToEvents()
}

def subscribeToEvents() {
    log.trace settings

    state.queuedActions = [] // initialize it
    
    subscribe(location, "routineExecuted" , modeChangeHandler)

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
}

def modeChangeHandler(evt = null) {
    if (evt && (evt.name != "routineExecuted")) { // This is not a routine notification
        log.warn "Invalid event notification received, event name: ${evt.name}"
        return
    }
    
    unschedule(modeChangeHandler) // If there are any pending from previous runs cancel them
    log.debug "Routine run notification, ${evt ? "name: ${evt.displayName}, description: ${evt.descriptionText}, SmartAppId: ${evt.value}" : "delayed checking/actions"}"

    def mode = evt.displayName // This should the routine name that was run

    // Check if we need a delayed actions for this state
    if (evt && settings."delayAction${mode}") {
        log.trace "Delaying checking/actions by ${settings."delayAction${mode}"} seconds"
        runIn(settings."delayAction${mode}", modeChangeHandler) // It automatically overwrites old schedules so we only get the latest
        return
    }

    def msgs = [] // Messages to send
    
    // Check for open doors/windows left open
    if (settings."doors${mode}") {
        def message = ""
        for (door in settings."doors${mode}") {
            if (door.currentValue("contact") == "open") {
                message += ", $door"
            } else {
                log.debug "$door is currently Closed"
            }
        }

        if(message) {
            message = "These doors were Open after routine $mode completed" + message
            log.info message
            msgs << message
        }
    } else {
        log.trace "No doors/windows found to check for open after routine $mode completed"
    }    

    // Check for open doors/windows left closed
    if (settings."doorsflip${mode}") {
        def message = ""
        for (door in settings."doorsflip${mode}") {
            if (door.currentValue("contact") == "closed") {
                message += ", $door"
            } else {
                log.debug "$door is currently Open"
            }
        }

        if(message) {
            message = "These doors were Closed after routine $mode completed" + message
            log.info message
            msgs << message
        }
    } else {
        log.trace "No doors/windows found to check for closed after routine $mode completed"
    }    

    // Check for switches left on
    if (settings."switches${mode}") {
        def message = ""
        for (switchs in settings."switches${mode}") {
            if (switchs.currentValue("switch") == "on") {
                message += ", $switchs"
                if (settings."switchesoff${mode}") {
                    switchs.off()
                }
            } else {
                log.debug "$switchs is currently Off"
            }
        }

        if(message) {
            if (settings."switchesoff${mode}") {
                message = "These switches were On after routine $mode completed, turning them Off" + message
            } else {
                message = "These switches were On after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No switches found to check for on after routine $mode completed"
    }    

    // Check for switches left off
    if (settings."switchesflip${mode}") {
        def message = ""
        for (switchs in settings."switchesflip${mode}") {
            if (switchs.currentValue("switch") == "off") {
                message += ", $switchs"
                if (settings."switcheson${mode}") {
                    switchs.on()
                }
            } else {
                log.debug "$switchs is currently On"
            }
        }

        if(message) {
            if (settings."switcheson${mode}") {
                message = "These switches were Off after routine $mode completed, turning them On" + message
            } else {
                message = "These switches were Off after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No switches found to check for off after routine $mode completed"
    }    

    // Check for locks left unlocked
    if (settings."locks${mode}") {
        def message = ""
        for (lock in settings."locks${mode}") {
            if (lock.currentValue("lock") == "unlocked") {
                message += ", $lock"
                if (settings."locksoff${mode}") {
                    lock.lock()
                }
            } else {
                log.debug "$lock is currently Locked"
            }
        }

        if(message) {
            if (settings."locksoff${mode}") {
                message = "These locks were Unlocked after routine $mode completed, Locking them" + message
            } else {
                message = "These locks were Unlocked after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No locks found to check for unlocked after routine $mode completed"
    }    

    // Check for locks left locked
    if (settings."locksflip${mode}") {
        def message = ""
        for (lock in settings."locksflip${mode}") {
            if (lock.currentValue("lock") == "locked") {
                message += ", $lock"
                if (settings."locksopen${mode}") {
                    lock.unlock()
                }
            } else {
                log.debug "$lock is currently Unlocked"
            }
        }

        if(message) {
            if (settings."locksopen${mode}") {
                message = "These locks were Locked after routine $mode completed, Unlocking them" + message
            } else {
                message = "These locks were Locked after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No locks found to check for locked after routine $mode completed"
    }    

    // Check for garage doors left open
    if (settings."garagedoors${mode}") {
        def message = ""
        for (garagedoor in settings."garagedoors${mode}") {
            if (garagedoor.currentValue("door") != "closed") {
                message += ", $garagedoor"
                if (settings."garagedoorsoff${mode}") {
                    garagedoor.close()
                }
            } else {
                log.debug "$garagedoor is currently Closed"
            }
        }

        if(message) {
            if (settings."garagedoorsoff${mode}") {
                message = "These doors were Open after routine $mode completed, Closing them" + message
            } else {
                message = "These doors were Open after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No garage doors found to check for open after routine $mode completed"
    }    

    // Check for garage doors left closed
    if (settings."garagedoorsflip${mode}") {
        def message = ""
        for (garagedoor in settings."garagedoorsflip${mode}") {
            if (garagedoor.currentValue("door") != "open") {
                message += ", $garagedoor"
                if (settings."garagedoorsopen${mode}") {
                    garagedoor.open()
                }
            } else {
                log.debug "$garagedoor is currently Open"
            }
        }

        if(message) {
            if (settings."garagedoorsopen${mode}") {
                message = "These doors were Closed after routine $mode completed, Opening them" + message
            } else {
                message = "These doors were Closed after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No garage doors found to check for closed after routine $mode completed"
    }    

    // Check for shades left open
    if (settings."shades${mode}") {
        def message = ""
        for (shade in settings."shades${mode}") {
            if (shade.currentValue("windowShade") != "closed") {
                message += ", $shade"
                if (settings."shadesoff${mode}") {
                    shade.close()
                }
            } else {
                log.debug "$shade is currently Closed"
            }
        }

        if(message) {
            if (settings."shadesoff${mode}") {
                message = "These shades were Open after routine $mode completed, Closing them" + message
            } else {
                message = "These shades were Open after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No window shades found to check for open after routine $mode completed"
    }    

    // Check for window shades left closed
    if (settings."shadesflip${mode}") {
        def message = ""
        for (shade in settings."shadesflip${mode}") {
            if (shade.currentValue("windowShade") != "open") {
                message += ", $shade"
                if (settings."shadeson${mode}") {
                    shade.open()
                }
            } else {
                log.debug "$shade is currently Open"
            }
        }

        if(message) {
            if (settings."shadeson${mode}") {
                message = "These shades were Closed after routine $mode completed, Opening them" + message
            } else {
                message = "These shades were Closed after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No window shades found to check for closed after routine $mode completed"
    }    

    // Check for valves left open
    if (settings."valves${mode}") {
        def message = ""
        for (valve in settings."valves${mode}") {
            if (valve.currentValue("valve") == "open" || valve.currentValue("contact") == "open") { // ST doesn't use valve due to firmware bug - https://community.smartthings.com/t/documentation-error-for-valve-or-platform-bug/88037/19
                message += ", $valve"
                if (settings."valvesoff${mode}") {
                    valve.close()
                }
            } else {
                log.debug "$valve is currently Closed"
            }
        }

        if(message) {
            if (settings."valvesoff${mode}") {
                message = "These valves were Open after routine $mode completed, Closing them" + message
            } else {
                message = "These valves were Open after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No valves found to check for open after routine $mode completed"
    }    

    // Check for valves left closed
    if (settings."valvesflip${mode}") {
        def message = ""
        for (valve in settings."valvesflip${mode}") {
            if (valve.currentValue("valve") == "closed" || valve.currentValue("contact") == "closed") { // ST doesn't use valve firmware bug - https://community.smartthings.com/t/documentation-error-for-valve-or-platform-bug/88037/19
                message += ", $valve"
                if (settings."valveson${mode}") {
                    valve.open()
                }
            } else {
                log.debug "$valve is currently Open"
            }
        }

        if(message) {
            if (settings."valveson${mode}") {
                message = "These valves were Closed after routine $mode completed, Opening them" + message
            } else {
                message = "These valves were Closed after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No valves found to check for closed after routine $mode completed"
    }
    
    // Check Thermostat setpoints
    if (settings."thermostats${mode}") {
        // Heating setpoint
        def message = ""
        for (device in settings."thermostats${mode}") {
            if (device.currentValue("heatingSetpoint") != settings."heatingSetpoint${mode}") {
                message += ", $device"
                if (settings."thermostatsSet${mode}") {
                    device.setHeatingSetpoint(settings."heatingSetpoint${mode}")
                }
            } else {
                log.debug "$device heating setpoint is set to ${settings."heatingSetpoint${mode}"}"
            }
        }

        if(message) {
            if (settings."thermostatsSet${mode}") {
                message = "These thermostats heating setpoint were not set to ${settings."heatingSetpoint${mode}"} after routine $mode completed, updating them" + message
            } else {
                message = "These thermostats heating setpoint were not set to ${settings."heatingSetpoint${mode}"} after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }

        // Cooling setpoint
        message = ""
        for (device in settings."thermostats${mode}") {
            if (device.currentValue("coolingSetpoint") != settings."coolingSetpoint${mode}") {
                message += ", $device"
                if (settings."thermostatsSet${mode}") {
                    device.setCoolingSetpoint(settings."coolingSetpoint${mode}")
                }
            } else {
                log.debug "$device cooling setpoint is set to ${settings."coolingSetpoint${mode}"}"
            }
        }

        if(message) {
            if (settings."thermostatsSet${mode}") {
                message = "These thermostats cooling setpoint were not set to ${settings."coolingSetpoint${mode}"} after routine $mode completed, updating them" + message
            } else {
                message = "These thermostats cooling setpoint were not set to ${settings."coolingSetpoint${mode}"} after routine $mode completed" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No thermostats found to check setpoints after routine $mode completed"
    }

    // Check if Mode has changed
    if (settings."targetMode${mode}") {
        def message = ""
        if (!settings."targetMode${mode}".contains(location.mode)) {
            message += "Hub was not in Mode ${settings."targetMode${mode}"} after routine $mode completed"
            if (settings."targetModeSet${mode}") {
                if (location.modes?.contains(settings."targetMode${mode}")) {
                    setLocationMode(settings."targetMode${mode}")
                    message += ", changing mode to ${settings."targetMode${mode}"}"
                } else {
                    message += ", cannot change Mode as new mode is invalid"
                }
            }
        } else {
            log.debug "Hub Mode is set to ${location.mode}"
        }

        if(message) {
            log.info message
            msgs << message
        }
    } else {
        log.trace "No target Mode to check after routine $mode completed"
    }
    
    
    // Run routine if required, do this last as it can timeout
    if (settings."homePhrase${mode}") {
        def message = "Running routine ${settings."homePhrase${mode}"} after routine $mode completed"
        location.helloHome.execute(settings."homePhrase${mode}")

        if(message) {
            log.info message
            msgs << message
        }
    } else {
        log.trace "No routines to run after routine $mode completed"
    }
    
    // Last this to do is send messages since these can time out
    log.trace "Sending messages"

    for (message in msgs) {
        if (settings."modeOverrideNotifications${mode}") {
            log.trace "Using mode specific notifications"
            sendMessages(mode, message)
        } else {
            log.trace "Using general notifications"
            sendMessages(null, message)
        }
    }
}

private sendText(number, message) {
    if (number) {
        def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private sendMessages(mode, message) {
    if (mode) {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, settings."recipients${mode}")
        } else {
            if (settings."notify${mode}") {
                sendPush message
            }

            if (settings."sms${mode}") {
                sendText(settings."sms${mode}", message)
            }
        }
        if (settings."audioDevices${mode}") {
            settings."audioDevices${mode}"*.playTextAndResume(message)
        }
    } else {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, recipients)
        } else {
            if (notify) {
                sendPush message
            }

            if (sms) {
                sendText(sms, message)
            }
        }
        if (settings."audioDevices") {
            settings."audioDevices"*.playTextAndResume(message)
        }
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Routines Backup"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = []
                routines.each { mode, name ->
                    caps.add(settings."doors${mode}")
                    caps.add(settings."doorsflip${mode}")
                    caps.add(settings."garagedoors${mode}")
                    caps.add(settings."garagedoorsflip${mode}")
                    caps.add(settings."locks${mode}")
                    caps.add(settings."locksflip${mode}")
                    caps.add(settings."switches${mode}")
                    caps.add(settings."switchesflip${mode}")
                    caps.add(settings."shades${mode}")
                    caps.add(settings."shadesflip${mode}")
                    caps.add(settings."valves${mode}")
                    caps.add(settings."valvesflip${mode}")
                    caps.add(settings."thermostats${mode}")
                }
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (!disableUpdateNotifications) {
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}


// THIS IS THE END OF THE FILE