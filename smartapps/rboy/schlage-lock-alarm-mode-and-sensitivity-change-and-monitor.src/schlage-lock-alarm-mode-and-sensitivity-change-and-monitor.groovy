/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "01.02.02"
}

/**
* Schlage Lock Alarm Mode and Sensitivity Change and Monitor
*
* Author: RBoy Apps
* Copyright RBoy Apps, redistribution of any changes or modified code is not allowed without permission
* 2017-5-26 - (v 01.02.02) Added ability to check for required device handler and notify user and sms now uses * to separate numbers
* 2016-10-23 - Added ability to check for new code versions automatically once a week and check for required device handler
* 2016-9-26 - Fix for broken ST phrases returning null data
* 2016-8-17 - Added workaround for ST contact address book bug
* 2016-7-22 - Added support for contact address book for customers who have this feature enabled
* 2016-1-19 - Bug fix for sensitivity not updating correctly (needs a delay between setAlarm and setSensitivity)
* 2016-1-15 - Clarified input options
* 2015-11-2 - Initial version
*/

definition(
    name: "Schlage Lock Alarm Mode and Sensitivity Change and Monitor",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "This SmartApp is used to control the Schalge Locks to modify the Alarm mode and sensitivity based on changes to hub mode and routines modes. It also monitors for alarms on the lock",
    category: "Safety & Security",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/SafetyAndSecurity/App-AudioVisualSmokeAlarm.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/SafetyAndSecurity/App-AudioVisualSmokeAlarm@2x.png",
    iconX3Url: "https://s3.amazonaws.com/smartapp-icons/SafetyAndSecurity/App-AudioVisualSmokeAlarm@2x.png")


preferences {
    page(name: "mainPage")
    page(name: "modePresetsPage")
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Schlage Lock Alarm Mode and Sensitivity Change/Monitor v${clientVersion()}", install: true, uninstall: true) {    
        section("About") {
            paragraph "This SmartApp is used to control the Schalge Z-Wave Locks and modify the Alarm mode and Sensitivity based on changes to hub mode and routines. It can also monitor for Alarm events and alert the user"
            paragraph "NOTE: This SmartApp will only with Schlage Z-Wave locks using the RBoy Apps Universal Enhanced Z-Wave Lock With Alarms Device type."
        }

        section("Schlage locks to configure") {
            for (lock in locks) {
                if (!lock?.hasAttribute('sensitive')) { // For now only custom DH supports sensitivity and alarm
                    def msg = "$lock IS NOT USING THE 'Universal Enhanced Z-Wave Lock With Alarms' DEVICE HANDLER, PLEASE REMOVE THE LOCK FROM THE MONITOR LIST OR UPDATE THE DEVICE HANDLER!"
                    paragraph title: msg, required: true, ""
                }
            }
            input "locks", "capability.lock", title:"Select Schlage Locks to Monitor", multiple:true, required:true, submitOnChange: true
        }

        section ("Mode/Routine based Alarm settings (optional)"){
            paragraph "Use this page to configure lock Alarm Modes and Sensivity for each Mode/Routine"
            href(name: "toModePresets", title: "Configure lock alarms", page: "modePresetsPage", description: modePresetsDescription(), required: false)
        }

        section("Alarm Monitoring Modes (optional)") {
            paragraph "Enable Alarm notifications/actions only when operating in the following modes."
            input name: "modeMonitor", title: "Monitor only when in this mode(s)", type: "mode", required: false, multiple: true
            input("recipients", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*4447654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
                input "push", "bool", title: "Send Push Notification", required: false
            }
        }

        def modes = getAlarmModes()
        def sensitives = getAlarmSensitives()
        section("Alarm Detected Action Settings (optional)") {
            paragraph "Select the external Alarm device to activate (sound and strobe) when alarm is detected on the locks. When Silent Alarm is enabled, only the strobe light is activated."
            input "alarms", "capability.alarm", title: "External alarm to turn on if lock alarm is detected", multiple: true, required: false
            input "alarmSilent", "bool", title: "Silent external alarm", required: false
            paragraph "Select the lights or switches to activate when alarm is detected on the camera"
            input "lights", "capability.switch", title: "Select lights/switches to turn on if lock alarm is detected", multiple: true, required: false, submitOnChange:true
            if (lights) {
                input "lightTimer", "number", title: "Turn off lights/switches after (minutes)", description: "Leave empty to not turn off lights/switches", required: false
            }
        }
        
        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }
    }
}

def modePresetsPage() {
    dynamicPage(name: "modePresetsPage", title: "", install: false, uninstall: false) {    
        section("About") {
            paragraph "Use this page to configure Alarm Modes and Sensitivity for the lock for each Mode and Routine."
            paragraph "Leave the alarm/sensitivity blank if you don't want an alarm mode/sensitivity assigned to a specific mode/routine."
        }

        def modes = getAlarmModes()
        def sensitives = getAlarmSensitives()
        section ("For each Mode configure the Alarm mode and Sensivitity"){
            paragraph "Configure the Alarm Mode and Sensitivity for each Mode in this section"
            for (mode in location.modes) {
                def lastAlarm = settings."alarm${mode}"
                def lastSensitive = settings."sensitive${mode}"
                log.trace "Last alarm for $mode is $lastAlarm"
                log.trace "Last sensitive for $mode is $lastSensitive"
                if (lastAlarm) {
                    input name: "alarm${mode}", type: "enum", title: "${mode} - Alarm", options: modes, defaultValue: lastAlarm, description: "Select alarm mode", required: false
                } else {
                    input name: "alarm${mode}", type: "enum", title: "${mode} - Alarm", options: modes, description: "Select alarm mode", required: false
                }
                if (lastSensitive) {
                    input name: "sensitive${mode}", type: "enum", title: "${mode} - Sensitivity", options: sensitives, defaultValue: lastSensitive, description: "Select alarm sensitivity level", required: false
                } else {
                    input name: "sensitive${mode}", type: "enum", title: "${mode} - Sensitivity", options: sensitives, description: "Select alarm sensitivity level", required: false
                }
            }
        }

        section ("For each Routine configure the Alarm mode and Sensivitity") {
            paragraph "Configure the Alarm Mode and Sensitivity for each Routine in this section"
            def phrases = location.helloHome?.getPhrases()
            phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
            for (mode in phrases) {
                def lastAlarm = settings."alarm${mode}"
                def lastSensitive = settings."sensitive${mode}"
                log.trace "Last alarm for $mode is $lastAlarm"
                log.trace "Last sensitive for $mode is $lastSensitive"
                if (lastAlarm) {
                    input name: "alarm${mode}", type: "enum", title: "${mode} - Alarm", options: modes, defaultValue: lastAlarm, description: "Select alarm mode", required: false
                } else {
                    input name: "alarm${mode}", type: "enum", title: "${mode} - Alarm", options: modes, description: "Select alarm mode", required: false
                }
                if (lastSensitive) {
                    input name: "sensitive${mode}", type: "enum", title: "${mode} - Sensitivity", options: sensitives, defaultValue: lastSensitive, description: "Select alarm sensitivity level", required: false
                } else {
                    input name: "sensitive${mode}", type: "enum", title: "${mode} - Sensitivity", options: sensitives, description: "Select alarm sensitivity level", required: false
                }
            }
        }
    }
}

private getAlarmModes()
{
    def ret = 	["off", "alert", "tamper", "forced"]
    log.trace "Alarm Modes -> ${ret}"
    return ret
}

private getAlarmSensitives()
{
    def ret = ["highest", "high", "medium", "low", "lowest"]
    log.trace "Alarm Sensivities -> ${ret}"
    return ret
}

private String modePresetsDescription() {
    def pieces = ""
    for (mode in location.modes) {
        def alarm = settings."alarm${mode}"
        def sensitive = settings."sensitive${mode}"
        if (alarm) {
            if (pieces.length() > 0) {
                pieces += "\n"
            }
            pieces += "$mode - $alarm"
        } else {
            if (pieces.length() > 0) {
                pieces += "\n"
            }
            pieces += "$mode - <Not set>"
        }
    }

    def phrases = location.helloHome?.getPhrases()
    phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
    for (mode in phrases) {
        def alarm = settings."alarm${mode}"
        def sensitive = settings."sensitive${mode}"
        if (alarm) {
            if (pieces.length() > 0) {
                pieces += "\n"
            }
            pieces += "$mode - $alarm"
        } else {
            if (pieces.length() > 0) {
                pieces += "\n"
            }
            pieces += "$mode - <Not set>"
        }
    }

    return pieces
}

def installed() {
    log.debug "Installed with settings: ${settings}"

    initialize()
}

def updated() {
    log.debug "Updated with settings: ${settings}"

    unsubscribe()
    unschedule()

    initialize()
}

def initialize() {
    log.debug "Initialize with settings: ${settings}"
    log.debug "Selected Alarm Notify/Action Modes: $modeMonitor"

    subscribe(location, "mode", modeChangeHandler)
    subscribe(locks, "motion.active", motionDetected)
    subscribe(location, "routineExecuted", modeChangeHandler)
    
    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm

}

def modeChangeHandler(evt) {
    def mode
    if (evt.name == "routineExecuted") { // this is a Routine Executed event handler
        mode = evt.displayName
        log.debug "Routine Executed handler called, routine ${mode} was executed"
    } else {
        mode = evt.value
        log.debug "Mode was changed to: ${mode}"
    }
    def alarm = settings."alarm${mode}"
    def sensitive = settings."sensitive${mode}"

    log.debug "Configuring Locks alarms, alarm -> $alarm, sensitive -> $sensitive"

    locks.each { lock ->
        if (alarm) {
            log.info "Setting lock $lock alarm to $alarm"
            sendNotificationEvent("Setting lock $lock alarm to $alarm")
            lock.setAlarm(alarm)
        }
    }
    if (sensitive) {
        log.trace "Updating sensitivity in 15 seconds, giving time for locks to update alarm mode" 
        runIn(15, setSensitive) // Give it a 15 second delay to update the lock alarm mode otherwise setSensitivity uses the old mode
    }
}

def setSensitive() {
    log.trace "setSensitive called, current mode: $location.mode"
    def sensitive = settings."sensitive${location.mode}" // We can use the current mode as it would have changed due to the event
    locks.each { lock ->
        log.info "Setting lock $lock sensitivity to $sensitive"
        sendNotificationEvent("Setting lock $lock sensitivity to $sensitive")
        lock.setSensitivity(sensitive)
    }
}

def motionDetected(event) {
    log.info "Alarm detected from lock ${event.displayName}"

    if (modeMonitor && !modeMonitor.contains(location.mode)) { // Empty means all modes
        log.warn "Current mode ${location.mode} is not in the list of active monitoring modes $modeMonitor, skipping taking actions for Alarm event"
        return
    }

    def lock = locks.find { event.deviceId == it.id }
    if (!lock) {
        log.error "Alarm event is from Lock ${event.displayName} whic is not in the list of selected Locks $locks, this should not happen"
        return
    }

    // turn on the alarms
    log.debug "Turning on alarms $alarms, silent: $alarmSilent"
    alarmSilent ? alarms?.strobe() : alarms?.both()

    // turn on lights
    log.debug "Turning on lights $lights"
    lights?.on()
    if (lightTimer) {
        log.trace "Scheduling lights turn off after $lightTimer minutes"
        runIn(lightTimer * 60, turnOffLights)
    }

    // Send notifications
    def message = "${event.displayName} has detected an Alarm"
    if (location.contactBookEnabled) {
        log.debug "Sending message to $recipients"
        sendNotificationToContacts(message, recipients)
    } else {
        log.debug "SMS: $sms, Push: $push"
        sms ? sendText(sms, message) : ""
        push ? sendPush(message) : sendNotificationEvent(message)
    }
}

def turnOffLights() {
    log.debug "Schedule called, turning off lights $lights"
    lights?.off()
}

private void sendText(number, message) {
    if (number) {
        def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Schlage Lock Alarm Mode and Sensitivity Change and Monitor"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = [ locks, alarms, lights ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (!disableUpdateNotifications) {
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}