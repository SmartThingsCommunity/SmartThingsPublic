/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "07.05.04"
}

/**
* Add and remove multiple user codes for locks with Scheduling and notification options and local actions
*
* Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
*
* Change Log:
* 2018-5-31 - (v07.05.04) Correct RFID case to capitals
* 2018-5-29 - (v07.05.03) Save lock id's instead of names when selecting per user locks to avoid issue of renamed locked/locks with similar names (requires users to reselect locks) and use sensor name instead of lock name for reporting open doors
* 2018-5-11 - (v07.05.02) Update for platform not saving sms settings for individual users
* 2018-5-1 - (v07.05.01) Patch for removing burner codes when multiple locks are used simultaneously
* 2018-4-13 - (v07.05.00) Stop tracking lock users after they are moved from the list of programmed locks, added support for Keypad Locks, fixed bug with arming SHM to Home on lock action
* 2018-4-12 - (v07.04.04) Log/notify if lock failed to program users, show activate/expire time on summary screen
* 2018-4-7 - (v07.04.03) Improvement to sure programming engine - handle lock programming failures for missed code notifications with retries, this indicates a underlying failure of the mesh
* 2018-3-26 - (v07.04.02) Check if ST mobile app saved an invalid start time, handle timezone differences between ST mobile app and hub better
* 2018-3-19 - (v07.04.00) Added support for custom per user notifications, clarified user types text
* 2018-3-9 - (v07.03.00) Maintain support for the legacy ZWave / JHampstead device handlers, improved tracking of changed codes, added support for limiting number of code use notifications
* 2018-3-7 - (v07.02.02) Clarify user type descriptions for easier understanding
* 2018-3-1 - (v07.02.01) Clean up excess users, handle duplicate codes and lost codes better, fix nameSlot notifications
* 2018-2-28 - (v07.02.00) Allow no time for schedled users indicating all day, better identification and compatibility with legacy handler reporting, fix ST UI bug not showing code length and remove fix issue with names being resent to the lock due to spaces
* 2018-2-27 - (v07.01.05) Process code rename from SmartLocks and update name in app
* 2018-2-26 - (v07.01.04) Better validation for legacy device handlers and show names for inactive slots
* 2018-2-23 - (v07.01.03) Automatic reinitailize after detecting code upgrades to avoid errors, increased limit to 120 for code retry interval for legacy users
* 2018-2-23 - (v07.01.02) Improved pin code length checks
* 2018-2-21 - (v07.01.01) Added support to arm SHM to Home when locking via keypad
* 2018-2-14 - (v07.01.00) Fix for ST local DTH bug in updating lock names
* 2018-2-13 - (v07.00.01) Fix for ST error on update
* 2018-2-13 - (v07.00.00) User can define number of retries, optimize user pages, don't rewrite all codes only those that have changed
* 2018-2-5 - (v06.02.00) Added support for locking/unlocking locks and opening/closing garage doors for lock/unlock actions. Added support to change modes for lock actions. Door sensor is now optional for relocking with timeout
* 2018-2-1 - (v06.01.03) Fix for ST breaking selection of Chime devices with mobile app 2.4.13
* 2018-1-22 - (v06.01.02) When deleting a user make removing the name optional, bugfix for ST Android mobile app not refreshing page when clearing the code
* 2018-1-21 - (v06.01.01) Added support for older device handlers to avoid a failure if users forgot to update the device handler
* 2018-1-17 - (v06.01.00) Added support for maxCodes, codeLength, adding names to SmartLocks and other new DTH features
* 2018-1-9 - (v06.00.03) Check if start and end time are entered for scheduled users
* 2018-1-9 - (v06.00.02) Patch for ST not showing separate door enable button value correctly the first time you enable it
* 2017-12-15 - (v06.00.01) Fix for manual unlock notifications not being sent
* 2017-12-4 - (v06.00.00) Added support for stock handler using lock codes, added support for manual lock and unlock actions
* 2017-11-14 - (v06.00.00) Added support for new ST stock DTH, improved code deletion confirmations
* 2017-11-8 - (v05.10.00) Added support for delayed lock actions and added support to arm SHM on lock and added icons and simplified the UI
* 2017-10-18 - (v05.09.00) Added check for disabling hardware autolock to use smartapp autorelock and autounlock features, added support for modes and presence based users, fixed bug with notify modes, simplified UI
* 2017-9-6 - (v05.08.01) Added support for code expirations past midnight
* 2017-8-1 - (v05.08.00) Fixed expire on with no start date/time, don't verify code deletion if disableRetry is enabled, added ablility to turn on/off switch on external keypad lock
* 2017-7-5 - (v05.07.00) Patch for ST platform breaking fast programing causing an error
* 2017-5-31 - (v05.06.00) Code hardering to avoid platform race conditions for one time codes, improved deadbolt automatic unlocking for Schlage locks, added support for playing back on audio systems, added support for bluetooth
* 2017-5-29 - (v05.05.03) Bugfix for unlocking and locking without codes throwing an error
* 2017-5-26 - (v05.05.02) Due to ST phone changes, now separate multiple SMS numbers with a *
* 2017-4-19 - (v05.05.01) Patch for reporting Master Codes
* 2017-4-11 - (v05.05.00) Added ability to select Chimes for when doors are opened and closed, improved user interface/text, added user presence based notifications
* 2017-4-11 - (v05.04.01) Fixed grammar for messages
* 2017-1-25 - (v5.4.0) Added ability to run lock/unlock actions on when the specified users aren't present or not in specific modes, also less verbose messages unless detailed notifications are enabled while running lock and unlock actions
* 2017-1-12 - (v5.3.1) Added ability to report and run actions on unknown users (some locks don't report use code when unlocking via keypad) and master codes
* 2016-11-14 - Improved reliability to programming during initial install to avoid lock getting in programming loop, changed multiple SMS separator from + to ;, added 3 programming schedules, improved smartapp update check
* 2016-10-30 - Added ability to check for new code versions automatically once a week, added ability to check for invalid pin lengths
* 2016-10-23 - Fixed a bug with expire/schedule code start date/time not working and added option to kick start timer with the arrow touch button on the smartapp
* 2016-9-28 - Fix for lock selection not working when lock names are changed
* 2016-9-26 - Fix for broken ST phrases returning null data
* 2016-9-17 - Fixed issue with cannot change notify settings, highlight error messages, improved invalid date checks, code clean up, added name details when deleting users
* 2016-9-16 - Fix for actions page not showing up when there are no routines defined on the hub
* 2016-9-16 - Fix for not being able to enter 0 in the code and fix for ST breaking HREF in 2.2.0
* 2016-9-15 - Added support to select locks for individual users
* 2016-9-15 - Added option for details programming notifications and improved reliability of programming
* 2016-9-13 - Bug fix when mode changes and no sensor is defined for door
* 2016-9-7 - Auto locks and open door notifications will engage if requried when mode changes
* 2016-9-2 - Added ability to specify modes of operations for auto door lock
* 2016-8-30 - Fixed bug with disable all push notifications, it should not disable text notifications and should only work when there is no contact address book
* 2016-8-17 - Added workaround for ST contact address book bug
* 2016-8-6 - Added support to auto relock door if the door hasn't been opened after specified timeout
* 2016-8-5 - Fix for autoRelock and openDoor notifications errors when using large timeout values
* 2016-8-5 - Fix for rare condition when expire on not process correctly
* 2016-7-25 - Added support for working with RFID cards
* 2016-7-22 - Added support for contact address book for customers who have this feature enabled
* 2016-7-19 - Updated code to use harmonized universal DH with type event instead of outsideLockEvent
* 2016-7-17 - Improvement to the unlocking and relocking logic
* 2016-7-17 - Workaround for platform calling installed and updated when installing the SmartApp
* 2016-7-17 - Bugfix for checking if codes are reused (type in code)
* 2016-7-17 - Clear codes on installing the app the first time to avoid conflict with lock and reduce unnecessary delay in programming
* 2016-7-17 - Put in a check to not enable automatic unlock if autolock in the door is enabled
* 2016-7-14 - Improved notifications
* 2016-7-13 - Added support for tamper events and when using user codes to lock the door from the keypad
* 2016-7-10 - Added support for running routine when the door is locked using external keypad lock button
* 2016-7-5 - Added support for notifications if door is left open, added support for delayed relock for multiple door and various minor UI improvements
* 2016-5-15 - Added check for no existent timezone and notify user
* 2016-4-20 - Added client version on main page
* 2016-4-8 - Added support for notification modes for unlocking (and improved UI)
* 2016-4-8 - Bugfix for jammed and manual lock notifications not coming
* 2016-3-21 - Added a heartbeat system to improve the reliability of the code check scheduler to compensate for the issues folks are seeing with the ST platform broken timers
* 2016-2-27 - Renamed option to retry to clarify, now it is to stop reverrification and overwriting all codes (default is incremental updates)
* 2016-2-25 - Added support for tracking deleted codes confirmation from lock and retrying if lock doesn't confirm code deletions
* 2016-2-20 - Added slot notification for unknown users
* 2016-2-15 - Added current date/time stamp on hub for debugging timezone mismatches
* 2016-2-15 - Default coding interval is now 60 seconds as the platform is crapping out in shorter intervals
* 2016-2-15 - Revamped code initialization to work around crappy ST timers and make programming more reliable. Using dual programming strategy now to make it more redundant
* 2016-1-23 - Added user specific unlock actions (override actions)
* 2016-1-19 - Fixed a debug error message about empty slots sharing a null code
* 2016-1-19 - Added comments
* 2016-1-17 - You can specify multiple sms phone numbers by putting a + to separate them
* 2016-1-15 - Validation check, same code cannot be used for more than one user
* 2016-1-13 - Debug message
* 2016-1-10 - Added option to disable retrying code programming on failure
* 2016-1-5 - Revamped code to verify with lock that codes have been successfully added and keep retrying until codes have been added
* 2015-12-18 - Added subcription to random events to kick start timers to work around buggy platform, use runEveryXMinutes where possible to hopefully improve the situation
* 2015-12-8 - Comment clarifications
* 2015-12-2 - Clean up
* 2015-11-28 - Added a delay to locking multiple doors to avoid mesh collisions
* 2015-11-28 - Use atomicState for automatic relocking to avoid race conditions
* 2015-11-28 - Select Door sensor independent of relock
* 2015-11-27 - Added support to relock doors after they have been closed with an optional delay timer and to retract deadbolts if door is open
* 2015-11-25 - Refresh the page after selecting the locks to that the individual options show up
* 2015-11-24 - Added support to show expired codes on configuration page
* 2015-11-22 - Added support for differentiate between manual lock and electronic lock (keypad/remote) while notifying user
* 2015-11-22 - Clarified input text for turning on lights after dark
* 2015-11-21 - Added support for individual door unlock actions
* 2015-11-21 - Added support to turn on lights 30 minutes before sunset (dark)
* 2015-11-21 - Added support to send notitications when too many invalid codes are reported by the lock
* 2015-11-21 - Added option 'Inactive' to the list of code types so one can keep the name/code on the slot but not have it active
* 2015-11-8 - Added option to switch on lights after dark (sunset to next sunrise)
* 2015-10-28 - Optimized disarming SHM as the first action on unlocking to help avoid false alarms
* 2015-10-26 - Added error checking for empty codes
* 2015-10-26 - Fixed a bug with one time codes
* 2015-10-26 - Added support for start date/time for expiration codes
* 2015-10-26 - Improved reliability when controlling multiple locks with a single app instance
* 2015-9-28 - Added support for lock notifications
* 2015-9-26 - Added support to turn on/off switches when a user unlocks the door with a code
* 2015-9-26 - Fixed a bug with mode changes when unlocking
* 2015-9-18 - Added option to disarm Smart Home Monitor mode when unlocking, added option to select modes when notifying on manual unlock
* 2015-9-2 - Fixed issue, don't run home phrase or change mode on manual unlock
* 2015-9-1 - Improve text clarity
* 2015-8-26 - Added support for running a phrase and changing modes when doors are unlocked successfully
* 2015-7-25 - Potential fix for preventing the timers from dying
* 2015-7-23 - Fix for monitoring not working after a mode change
* 2015-7-22 - Added support for advanced scheduling options for individual users codes including permanent, one time, expiration and scheduled
* 2015-7-22 - Use the standard "unknown" lock state to check for jammed
* 2015-7-6 - Fixed issue with code expiry not working
* 2015-6-18 - Added option to change delay between sending codes for users who have issues with communications
* 2015-6-18 - Added notification for jammed door locks
* 2015-6-17 - Fix for dynamic preferences not working after ST platform update
* 2015-6-9 - Added support to disable push notifications only
* 2015-5-27 - Added support for expiration dates
* 2015-2-20 - Fixed issue with SMS not being sent
* 2015-1-9 - Improve reliability with coding
* 2015-1-1 - Created
*
*/

definition(
    name: "Door lock code user management with notifications and automatic relock",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Add and Delete Multiple User Codes for Locks with Scheduling and Notifications",
    category: "Safety & Security",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/Allstate/lock_it_when_i_leave.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Allstate/lock_it_when_i_leave@2x.png"
)

preferences {
    page(name: "setupApp")
    page(name: "usersPage")
    page(name: "unlockLockActionsPage")
    page(name: "unlockKeypadActionsPage")
    page(name: "unlockManualActionsPage")
    page(name: "lockKeypadActionsPage")
    page(name: "lockManualActionsPage")
    page(name: "openCloseDoorPage")
    page(name: "scheduleCodesPage")
    page(name: "userConfigPage")
}

private getDefaultSendDelay() { 15 }
private getDefaultRetries() { 5 }
private getMaxRetries() { retries == null ? defaultRetries : retries }
private codeOptions() {
    def ret = [
        "Permanent": "Permanent",
        "One time": "One time (burner)",
        "Expire on": "Start/end date and time",
        "Scheduled": "Weekly/daily schedule(s)",
        "Presence": "Activate on user presence",
        "Modes": "Activate on mode(s)",
        "Inactive": "Temporarily disabled"
    ]

    return ret
}


def setupApp() {
    log.trace "$settings"

    dynamicPage(name: "setupApp", title: "Lock User Management v${clientVersion()}", install: true, uninstall: true) {
        section("Select Lock(s)") {
            // Check if the lock pin code length match on all the locks
            def pinDetails = getLockPinLengthDetails()
            def pinLen = pinDetails.pinLen // Fixed pin code length
            def maxPinLen = pinDetails.maxPinLen // Variable minimum pin code length
            def minPinLen = pinDetails.minPinLen // Variable maximum pin code length
            def pinLenError = pinDetails.pinLenError
            log.trace "Configured lock fixed code length: $pinLen, max code length: $maxPinLen, min code length: $minPinLen"
            if (pinLenError) {
                def msg = "YOUR LOCKS ARE CONFIGURED TO ACCEPT DIFFERENT CODE DIGIT LENGTHS, PROGRAMMING WILL FAIL!"
                paragraph title: msg, required: true, ""
            }
            input "locks","capability.lock", title: "Lock(s)", multiple: true, submitOnChange: true, image: "http://www.rboyapps.com/images/HandleLock.png"
        }

        section("User Management") {
            def maxCodes = 0
            for (lock in locks) {
                Integer lockMax = lock.hasAttribute("maxCodes") ? lock.currentValue("maxCodes") : 0
                log.trace "$lock has max users: $lockMax"
                maxCodes = maxCodes ? (lockMax ? Math.min(lockMax, maxCodes) as Integer : maxCodes) : (lockMax ?: 0) // Take the least amongst all selected locks
            }
            input name: "maxUserNames", title: "Number of users${maxCodes ? " (1 to ${maxCodes})" : ""}", type: "number", required: true, multiple: false, image: "http://www.rboyapps.com/images/Users.png", range: "1..${maxCodes ?: 999}"
            href(name: "users", title: "Configure users", page: "usersPage", description: "Create users and custom actions", required: false, image: "http://www.rboyapps.com/images/User.png")
        }

        section("General Settings") {
            // Unlock actions for all users (global)
            def hrefParams = [
                user: null, 
                passed: true 
            ]
            href(name: "unlockLockActions", params: hrefParams, title: "Lock/unlock actions", page: "unlockLockActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/LockUnlock.png")
            href(name: "openCloseDoor", title: "Door open/close actions", page: "openCloseDoorPage", description: "", required: false, image: "http://www.rboyapps.com/images/DoorOpenClose.png")

            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false, image: "http://www.rboyapps.com/images/Notifications.png") {
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*+448747654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
                paragraph "Enable the below option if you DON'T want push notifications on your SmartThings phone app."
                input name: "disableAllNotify", title: "Disable all push notifications", type: "bool", defaultValue: "false", required: true
            }
            input "audioDevices", "capability.audioNotification", title: "Play notifications on these devices", required: false, multiple: true, image: "http://www.rboyapps.com/images/Horn.png"
        }

        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }

        section("Code Programming Options (advanced) (optional)", hideable: true, hidden: true) {
            paragraph "Sure-Programming: To improve programming reliability, the app will keep trying to program the user codes until the lock confirms the programming or up to the maximum number of retries"
            input name: "retries", title: "Maximum code programming retries", type: "number", defaultValue: "${defaultRetries}", range: "0..10", required: false
            paragraph "Change this setting if all the user codes aren't being programmed on the lock correctly. This settings determines the time gap between sending each user code to the lock. If the codes are sent too fast, they may fail to be set properly"
            input name: "sendDelay", title: "Delay between codes (seconds):", type: "number", defaultValue: "${defaultSendDelay}", range: "5..120", required: false
            paragraph "Enable this to get additional detailed notifications like code programming, lock responses etc. NOTE: this can generate a lot of messages"
            input name: "detailedNotifications", title: "Get detailed notifications", type: "bool", defaultValue: "false", required: false
        }
        
        remove("Uninstall")
    }
}

def openCloseDoorPage() {
    dynamicPage(name:"openCloseDoorPage", title: "Select door open/close sensor for each door and configure the automatic unlock, relock and notifications of the door", uninstall: false, install: false) {
        section {
            for (lock in locks) {
                def priorRelockDoor = settings."relockDoor${lock}"
                def priorRelockImmediate = settings."relockImmediate${lock}"
                def priorRelockAfter = settings."relockAfter${lock}"
                def priorRetractDeadbolt = settings."retractDeadbolt${lock}"
                def priorNotifyOpen = settings."openNotify${lock}"
                def priorNotifyOpenTimeout = settings."openNotifyTimeout${lock}"
                def priorOpenNotifyModes = settings."openNotifyModes${lock}"
                def priorRelockDoorModes = settings."relockDoorModes${lock}"
                def priorNotifyBeep = settings."openNotifyBeep${lock}"

                paragraph title: "Configure ${lock}", required: true, ""
                if (priorRelockDoor || priorRetractDeadbolt || priorNotifyOpen || priorNotifyBeep) {
                    input "sensor${lock}", "capability.contactSensor", title: "Door open/close sensor", required: ( priorRelockImmediate || priorRetractDeadbolt || priorNotifyOpen || priorNotifyBeep ? true : false) // required for deadbolt, immediate relock or notifications
                }

                // Sanity check do not offer AutoLock is hardware autoLock is engaged
                if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
                    paragraph title: "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features", required: true, ""
                } else {
                    input "relockDoor${lock}", "bool", title: "Relock door automatically after closing", defaultValue: priorRelockDoor, required: false, submitOnChange: true
                    if (priorRelockDoor) {
                        input "relockImmediate${lock}", "bool", title: "Relock immediately", defaultValue: priorRelockImmediate, required: false, submitOnChange: true
                        if (!priorRelockImmediate) {
                            input "relockAfter${lock}", "number", title: "Relock after (minutes)", defaultValue: priorRelockAfter, required: true                   
                        }
                        input "relockDoorModes${lock}", "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorRelockDoorModes, required: false, multiple: true
                    }
                    if (priorRetractDeadbolt) {
                        paragraph "NOTE: Make sure the AutoLock feature on the lock is disabled to avoid an infinite locking/unlocking loop.", required: false, submitOnChange: true
                    }
                    input "retractDeadbolt${lock}", "bool", title: "Unlock door if locked while open", defaultValue: priorRetractDeadbolt, description: "This retracts the deadbolt if it extends while the door is still open", required: false, submitOnChange: true
                }

                input "openNotifyBeep${lock}", "capability.tone", title: "Ring chime when door is opened", multiple: true, required: false, submitOnChange: true
                input "openNotify${lock}", "bool", title: "Notify if door has been left open", defaultValue: priorNotifyOpen, required: false, submitOnChange: true
                if (priorNotifyOpen) {
                    input "openNotifyTimeout${lock}", "number", title: "...for (minutes)", defaultValue: priorNotifyOpenTimeout, required: true, range: "1..*"
                }
                if (priorNotifyOpen || priorNotifyBeep) {
                    input "openNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorOpenNotifyModes, required: false, multiple: true
                }

                paragraph "\r\n"
            }
        }
    }
}

def unlockLockActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    log.trace "Lock/Unlock Action Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockLockActionsPage", title: (user ? "Setup custom actions/notifications for ${name ?: "user ${user}"}" : "Setup lock/unlock actions for each door"), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        def showActions = true
        if (!phrases) {
            log.warn "No Routines found!!!"
        }
        section {
            if (user) { // User specific override options
                paragraph "Enabling custom user actions and notifications will override over the general actions defined on the first page"
                input "userOverrideUnlockActions${user}", "bool", title: "Define custom actions for ${name ?: "user ${user}"}", required: true,  submitOnChange: true
                if (!settings."userOverrideUnlockActions${user}") { // Check if user has enabled specific override actions then show menu
                    showActions = false
                }
            }
            if  (showActions && locks?.size() > 1) {
                input "individualDoorActions${user}", "bool", title: "Separate actions for each door", required: true,  submitOnChange: true
            }
        }
        if (showActions) { // Do we need to show actions?
            if (settings."individualDoorActions${user}") {
                for (lock in locks) {
                    section ("$lock", hideable: false) {
                        def hrefParams = [
                            user: user,
                            lock: lock as String,
                            passed: true 
                        ]
                        href(name: "unlockKeypadActions${lock}", params: hrefParams, title: "Keypad Unlock Actions", page: "unlockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadUnlocked.png")
                        href(name: "lockKeypadActions${lock}", params: hrefParams, title: "Keypad Lock Actions", page: "lockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadLocked.png")
                        if (!user) {
                            href(name: "unlockManualActions${lock}", params: hrefParams, title: "Manual Unlock Actions", page: "unlockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualUnlocked.png")
                            href(name: "lockManualActions${lock}", params: hrefParams, title: "Manual Lock Actions", page: "lockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualLocked.png")
                        }
                    }
                }
            } else {
                section("", hideable: false) {
                    def hrefParams = [
                        user: user,
                        lock: "",
                        passed: true 
                    ]
                    href(name: "unlockKeypadActions", params: hrefParams, title: "Keypad Unlock Actions", page: "unlockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadUnlocked.png")
                    href(name: "lockKeypadActions", params: hrefParams, title: "Keypad Lock Actions", page: "lockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadLocked.png")
                    if (!user) {
                        href(name: "unlockManualActions", params: hrefParams, title: "Manual Unlock Actions", page: "unlockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualUnlocked.png")
                        href(name: "lockManualActions", params: hrefParams, title: "Manual Lock Actions", page: "lockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualLocked.png")
                    }
                }
            }
        }
        section {
            if (user) { // User specific override notification options
                def showCustomNotifications = true
                input "userOverrideNotifications${user}", "bool", title: "Define custom notifications for ${name ?: "user ${user}"}", required: true,  submitOnChange: true
                if (!settings."userOverrideNotifications${user}") { // Check if user has enabled specific override actions then show menu
                    showCustomNotifications = false
                }
                if (showCustomNotifications) {
                    input("recipients${user}", "contact", title: "Send notifications to", multiple: true, required: false, image: "http://www.rboyapps.com/images/Notifications.png") {
                        paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*+448747654321"
                        input "sms${user}", "phone", title: "Send SMS notification to (optional):", required: false
                        paragraph "Enable the below option if you DON'T want push notifications for ${name ?: "user ${user}"} on your SmartThings phone app."
                        input "disableAllNotify${user}", "bool", title: "Disable all push notifications for ${name ?: "user ${user}"}", defaultValue: "false", required: true
                    }
                    input "audioDevices${user}", "capability.audioNotification", title: "Play notifications on these devices", required: false, multiple: true, image: "http://www.rboyapps.com/images/Horn.png"
                }
            }
        }
    }
}

def unlockKeypadActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for user $user, lock $lock"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user, lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    log.trace "Keypad Unlock Action Page, user:$user, name:$name, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockKeypadActionsPage", title: "Setup keypad unlock actions for doors" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Keypad Unlock Actions${lock ? " for $lock" : ""}") {
            def priorHomePhrase = settings."homePhrase${lock}${user}"
            def priorHomeMode = settings."homeMode${lock}${user}"

            paragraph "Run these actions when a user successfully unlocks the door using a code"
            input "homePhrase${lock}${user}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorHomePhrase
            input "homeMode${lock}${user}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            if (lock ? (locks.find{ it.name == lock }?.hasAttribute("armMode") ? !settings."keypadArmDisarm${lock}${user}" : true) : true) { // Hide only if we have have a supported keypad for selected lock and using keypad to control SHM
                input "homeDisarm${lock}${user}", "bool", title: "Disarm Smart Home Monitor", required: false
            }
            if ((lock ? locks.find { it.name == lock } : locks)?.any { keypad -> keypad.hasAttribute("armMode") }) { // Show only if we have a supported keypad (for selected lock or for general settings)
                input "keypadArmDisarm${lock}${user}", "bool", title: "Control Smart Home Monitor using keypad", required: false, submitOnChange: (lock ? true : false)
            }
            input "turnOnSwitchesAfterSunset${lock}${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true
            input "turnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "turnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "unlockLocks${lock}${user}","capability.lock", title: "Unlock lock(s)", required: false, multiple: true
            input "openGarage${lock}${user}","capability.garageDoorControl", title: "Open garage door(s)", required: false, multiple: true

            paragraph title: "Do NOT run the above unlock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleUnlockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeUnlockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true
        }
    }
}

def unlockManualActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for lock $lock"
    } else if (atomicState.params) {
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    log.trace "Manual Unlock Action Page, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockManualActionsPage", title: "Setup manual unlock actions for doors", uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Manual Unlock Actions${lock ? " for $lock" : ""}") {
            def priorHomePhrase = settings."homePhraseManual${lock}"
            def priorHomeMode = settings."homeModeManual${lock}"
            def priorManualNotify = settings."manualNotify${lock}"

            paragraph "Run these actions when a user unlocks the door manually"
            input "homePhraseManual${lock}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorHomePhrase
            input "homeModeManual${lock}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "homeDisarmManual${lock}", "bool", title: "Disarm Smart Home Monitor", required: false
            input "turnOnSwitchesAfterSunsetManual${lock}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true
            input "turnOnSwitchesManual${lock}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "turnOffSwitchesManual${lock}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "unlockLocksManual${lock}","capability.lock", title: "Unlock lock(s)", required: false, multiple: true
            input "openGarageManual${lock}","capability.garageDoorControl", title: "Open garage door(s)", required: false, multiple: true

            paragraph title: "Do NOT run the above unlock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleUnlockActionsManual${lock}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeUnlockActionsManual${lock}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            paragraph "Unlock Notification Options"
            input "manualNotify${lock}", "bool", title: "Notify on manual unlock", required: false, submitOnChange: true
            if (priorManualNotify) {
                input "manualNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", required: false, multiple: true
            }
        }
    }
}

def lockKeypadActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for user $user, lock $lock"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user, lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    log.trace "Keypad Lock Action Page, user:$user, name:$name, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"lockKeypadActionsPage", title: "Setup keypad lock actions for doors" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Keypad Lock Actions${lock ? " for $lock" : ""}") {
            def priorLockPhrase = settings."externalLockPhrase${lock}${user}"
            def priorHomeMode = settings."externalLockMode${lock}${user}"

            paragraph "Some locks can be locked from the keypad outside${user ? " with user codes" : ""}. If your lock has his feature then you can assign actions to execute when it is locked ${user ? "with a user code" : "from the keypad"}"
            input "externalLockPhrase${lock}${user}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
            input "externalLockMode${lock}${user}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            if (lock ? (locks.find{ it.name == lock }?.hasAttribute("armMode") ? !settings."keypadArmDisarm${lock}${user}" : true) : true) { // Hide only if we have have a supported keypad for selected lock and using keypad to control SHM
                input "homeArm${lock}${user}", "bool", title: "Arm Smart Home Monitor to Away", required: false, submitOnChange: true
                if (settings."homeArm${lock}${user}") {
                    input "homeArmStay${lock}${user}", "bool", title: "...arm to Stay instead of Away", required: false
                }
            }
            if ((lock ? locks.find { it.name == lock } : locks)?.any { keypad -> keypad.hasAttribute("armMode") }) { // Show only if we have a supported keypad (for selected lock or for general settings)
                input "keypadArmDisarm${lock}${user}", "bool", title: "Control Smart Home Monitor using keypad", required: false, submitOnChange: (lock ? true : false)
            }
            input "externalLockTurnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "externalLockTurnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "lockLocks${lock}${user}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
            input "closeGarage${lock}${user}","capability.garageDoorControl", title: "Close garage door(s)", required: false, multiple: true

            input "delayLockActions${lock}${user}", "bool", title: "Delay running lock actions", required: false, submitOnChange: true
            if (settings."delayLockActions${lock}${user}") {
                input "delayLockActionsTime${lock}${user}", "number", title: "...by (minutes)", defaultValue: settings."delayLockActionsTime${lock}${user}", required: true, range: "1..*"
            }

            paragraph title: "Do NOT run the above lock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleLockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeLockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            if (!user) { // Users will use the user notify option
                paragraph "Lock Notification Options"
                input "externalLockNotify${lock}", "bool", title: "Notify on keypad lock", required: false, submitOnChange: true
                if (settings."externalLockNotify${lock}") {
                    input "externalLockNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                }
                input "jamNotify${lock}", "bool", title: "Notify on Lock Jam/Stuck", required: false
            }
        }
    }
}

def lockManualActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for lock $lock"
    } else if (atomicState.params) {
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    log.trace "Manual Lock Action Page, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"lockManualActionsPage", title: "Setup manual lock actions for doors", uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Manual Lock Actions${lock ? " for $lock" : ""}") {
            def priorLockPhrase = settings."externalLockPhraseManual${lock}"
            def priorHomeMode = settings."externalLockModeManual${lock}"

            input "externalLockPhraseManual${lock}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
            input "externalLockModeManual${lock}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "homeArmManual${lock}", "bool", title: "Arm Smart Home Monitor to Stay", required: false
            input "externalLockTurnOnSwitchesManual${lock}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "externalLockTurnOffSwitchesManual${lock}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "lockLocksManual${lock}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
            input "closeGarageManual${lock}","capability.garageDoorControl", title: "Close garage door(s)", required: false, multiple: true

            input "delayLockActionsManual${lock}", "bool", title: "Delay running lock actions", required: false, submitOnChange: true
            if (settings."delayLockActionsManual${lock}") {
                input "delayLockActionsTimeManual${lock}", "number", title: "...by (minutes)", defaultValue: settings."delayLockActionsTimeManual${lock}", required: true, range: "1..*"
            }

            paragraph title: "Do NOT run the above lock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleLockActionsManual${lock}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeLockActionsManual${lock}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            paragraph "Lock Notification Options"
            input "lockNotify${lock}", "bool", title: "Notify on manual/auto lock", required: false, submitOnChange: true
            if (settings."lockNotify${lock}") {
                input "lockNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", required: false, multiple: true
            }
        }
    }
}


def usersPage() {
    dynamicPage(name:"usersPage", title: "User Names, Codes and Notification Setup", uninstall: false, install: false) {

        if (!maxUserNames) {
            section("Invalid number of users") {
                paragraph title: "First configure the number of users on the previous page", required: true, ""
            }
        }
        
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            section("INVALID HUB LOCATION") {
                paragraph title: "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately", required: true, ""
            }
        }

        // Check if the lock pin code length match on all the locks
        def pinDetails = getLockPinLengthDetails()
        def pinLen = pinDetails.pinLen // Fixed pin code length
        def maxPinLen = pinDetails.maxPinLen // Variable minimum pin code length
        def minPinLen = pinDetails.minPinLen // Variable maximum pin code length
        def pinLenError = pinDetails.pinLenError
        log.trace "Configured lock fixed code length: $pinLen, max code length: $maxPinLen, min code length: $minPinLen"

        section() {
            for (int i = 1; i <= maxUserNames; i++) {
                def priorName = settings."userNames${i}"
                def priorCode = settings."userCodes${i}"
                def priorNotify = settings."userNotify${i}"
                def priorNotifyModes = settings."userNotifyModes${i}"
                def priorExpireDate = settings."userExpireDate${i}"
                def priorExpireTime = settings."userExpireTime${i}"
                def priorStartDate = settings."userStartDate${i}"
                def priorStartTime = settings."userStartTime${i}"
                def priorUserType = settings."userType${i}"
                def invalidStartDate = false
                def invalidExpiryDate = false
                def userSummary = ""
                def userSlotActive = true
                //log.trace "Initial $i Name: $priorName, Code: $priorCode, Notify: $priorNotify, NotifyModes: $priorNotifyModes, ExpireDate: $priorExpireDate, ExpireTime: $priorExpireTime, StartDate: $priorStartDate, StartTime: $priorStartTime, UserType: $priorUserType"

                // Check for errors and display messages
                if (pinLenError) {
                    def msg = "YOUR LOCKS ARE CONFIGURED TO ACCEPT DIFFERENT CODE DIGIT LENGTHS, PROGRAMMING WILL FAIL!"
                    paragraph title: msg, required: true, ""
                }

                if (priorCode) { // Do all the checks only if user has been configured
                    // Sanity check, codes cannot be reused in the same lock (codes have to be unique to the same slot
                    for (int j = 1; j <= maxUserNames; j++) {
                        if (priorCode && (i != j) && (priorCode == settings."userCodes${j}")) {
                            def msg = "CHANGE CODE - THIS CODE HAS BEEN USED FOR USER $j"
                            log.warn "CHANGE CODE FOR USER $i - THIS CODE HAS BEEN USED FOR USER $j"
                            userSummary += (userSummary ? "\n" : "") + msg
                        }
                    }

                    // Check if the user has entered a non digit string
                    if ((priorCode?.size() > 0) && !priorCode?.isNumber()) {
                        def msg = "WARNING: CODE IS NOT A NUMBER, PROGRAMMING WILL FAIL!"
                        log.warn msg
                        userSummary += (userSummary ? "\n" : "") + msg
                    }

                    // Check if the lock pin code length match the pin code length entered by the user
                    def userLocks = settings."userLocks${i}" ?: locks*.id // Use the defined locks or if not defined then check all locks
                    for (lock in locks) {
                        if (userLocks?.contains(lock.id) && (pinLen || (maxPinLen && minPinLen))) { // Check if the lock support reporting pin length and it has a valid number to report (not 0 or null)
                            if ((priorCode?.size() > 0) && (pinLen ? pinLen != priorCode.size() : ((priorCode.size() < minPinLen) || (priorCode.size() > maxPinLen)))) { // If we have a code to program
                                def msg = "YOUR LOCK IS CONFIGURED TO ACCEPT ${pinLen ?: "${minPinLen}-${maxPinLen}"} DIGIT CODES ONLY, PROGRAMMING WILL FAIL!"
                                log.warn msg
                                userSummary += (userSummary ? "\n" : "") + msg
                                break // one message is enough
                            }
                        }
                    }

                    // Sanity check for expiration date formats
                    switch (priorUserType) {
                        case 'Expire on':
                            if (priorStartDate) {
                                //log.trace "Found start date in setup"
                                try {
                                    def df = new java.text.SimpleDateFormat("yyyy-MM-dd")
                                    df.setLenient(false) // we want strict formatting
                                    df.parse(priorStartDate)
                                    invalidStartDate = false
                                }
                                catch (Exception e) {
                                    log.warn "Invalid start date for user $i"
                                    invalidStartDate = true
                                }
                            }
                            if (priorExpireDate) {
                                //log.trace "Found expiry date in setup"
                                try {
                                    def df = new java.text.SimpleDateFormat("yyyy-MM-dd")
                                    df.setLenient(false) // we want strict formatting
                                    df.parse(priorExpireDate)
                                    invalidExpiryDate = false // We passed it's a valid date
                                }
                                catch (Exception e) {
                                    log.warn "Invalid expiry date for user $i"
                                    invalidExpiryDate = true
                                }
                            }

                            if (!invalidExpiryDate && !invalidStartDate) {
                                if (priorExpireDate) {
                                    def expired = false
                                    if (priorExpireTime) {
                                        // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally
                                        def exp = Date.parse("yyyy-MM-ddHH:mmZ", priorExpireDate + timeToday(priorExpireTime, timeZone).format("HH:mmZ", timeZone))
                                        if (exp.getTime() < now()) {
                                            def msg = "Code EXPIRED!"
                                            userSummary += (userSummary ? "\n" : "") + msg
                                            expired = true
                                            userSlotActive = false
                                        } else {
                                            if (priorStartDate && priorStartTime && !expired) {
                                                def start = Date.parse("yyyy-MM-ddHH:mmZ", priorStartDate + timeToday(priorStartTime, timeZone).format("HH:mmZ", timeZone))
                                                if (start.getTime() > now()) {                                                
                                                    def msg = "Activates ${start.format("EEE MMM dd HH:mm", timeZone)}"
                                                    userSummary += (userSummary ? "\n" : "") + msg
                                                }
                                            }
                                            def msg = "Expires ${exp.format("EEE MMM dd HH:mm", timeZone)}"
                                            userSummary += (userSummary ? "\n" : "") + msg
                                        }
                                    }
                                }
                            } else {
                                def msg = "INVALID Date!"
                                userSummary += (userSummary ? "\n" : "") + msg
                                userSlotActive = false
                            }
                            break

                        case 'One time':
                            if (state.trackUsedOneTimeCodes?.contains(i as String)) {
                                def msg = "One time code USED!"
                                userSummary += (userSummary ? "\n" : "") + msg
                                userSlotActive = false
                            }
                            break

                        case 'Scheduled':
                        	if (!(('A'..'C').any { schedule -> settings."userDayOfWeek${schedule}${i}" })) { // If no schedules are defined
                                def msg = "No schedule defined!"
                                userSummary += (userSummary ? "\n" : "") + msg
                                userSlotActive = false
                            }
                        	break
                            
                        case 'Presence':
                        	if (!(settings."userPresent${i}" || settings."userNotPresent${i}")) { // No conditions is specified
                                def msg = "No presence defined!"
                                userSummary += (userSummary ? "\n" : "") + msg
                                userSlotActive = false
                            }
                            break
                        
                        case 'Inactive':
                        	userSlotActive = false
                        	break
                            
                        default:
                            break
                    }
                    
                    if (!userSummary) { // If there are no messages or warnings then indicate user type
                        userSummary += priorUserType
                    }
                } else if (priorName) { // Incomplete configuration
                    def msg = "No code defined!"
                    userSummary += (userSummary ? "\n" : "") + msg
                    userSlotActive = false
                } else { // Not configured
                    userSlotActive = false
                }

                // Params for user
                def hrefParams = [
                    user: i as String,
                    passed: true 
                ]
                href(name: "userConfig${i}", params: hrefParams, title: "${priorName ?: "< blank >"}", page: "userConfigPage", description: userSummary, required: false, image: (userSlotActive ? "http://www.rboyapps.com/images/User.png" : "http://www.rboyapps.com/images/UserInactive.png"))
            }
        } 
    } 
}

def userConfigPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get user from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.user) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user:$user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user:$user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""
    def i = user as Integer

    log.trace "User Codes Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    // Check if the lock pin code length match on all the locks
    def pinDetails = getLockPinLengthDetails()
    def pinLen = pinDetails.pinLen // Fixed pin code length
    def maxPinLen = pinDetails.maxPinLen // Variable minimum pin code length
    def minPinLen = pinDetails.minPinLen // Variable maximum pin code length
    def pinLenError = pinDetails.pinLenError
    log.trace "Configured lock fixed code length: $pinLen, max code length: $maxPinLen, min code length: $minPinLen"

    dynamicPage(name:"userConfigPage", title: "User Management Slot #${i}", uninstall: false, install: false) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            section("INVALID HUB LOCATION") {
                paragraph title: "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately", required: true, ""
            }
        }

        section() {
            def priorName = settings."userNames${i}"
            def priorCode = settings."userCodes${i}"
            def priorNotify = settings."userNotify${i}"
            def priorNotifyModes = settings."userNotifyModes${i}"
            def priorExpireDate = settings."userExpireDate${i}"
            def priorExpireTime = settings."userExpireTime${i}"
            def priorStartDate = settings."userStartDate${i}"
            def priorStartTime = settings."userStartTime${i}"
            def priorUserType = settings."userType${i}"
            def invalidStartDate = false
            def invalidExpiryDate = false
            log.trace "Initial $i Name: $priorName, Code: $priorCode, Notify: $priorNotify, NotifyModes: $priorNotifyModes, ExpireDate: $priorExpireDate, ExpireTime: $priorExpireTime, StartDate: $priorStartDate, StartTime: $priorStartTime, UserType: $priorUserType"

            // Check for errors and display messages
            if (pinLenError) {
                def msg = "YOUR LOCKS ARE CONFIGURED TO ACCEPT DIFFERENT CODE DIGIT LENGTHS, PROGRAMMING WILL FAIL!"
                paragraph title: msg, required: true, ""
            }

            if (priorCode) { // Do all the checks only if user has been configured
                // Sanity check, codes cannot be reused in the same lock (codes have to be unique to the same slot
                for (int j = 1; j <= maxUserNames; j++) {
                    if (priorCode && (i != j) && (priorCode == settings."userCodes${j}")) {
                        log.warn "CHANGE CODE FOR USER $i - THIS CODE HAS BEEN USED FOR USER $j"
                        paragraph title: "CHANGE CODE - THIS CODE HAS BEEN USED FOR USER $j", required: true, ""
                    }
                }

                // Check if the user has entered a non digit string
                if ((priorCode?.size() > 0) && !priorCode?.isNumber()) {
                    def msg = "WARNING: CODE IS NOT A NUMBER, PROGRAMMING WILL FAIL!"
                    paragraph title: msg, required: true, ""
                }

                // Check if the lock pin code length match the pin code length entered by the user
                def userLocks = settings."userLocks${i}" ?: locks*.id // Use the defined locks or if not defined then check all locks
                for (lock in locks) {
                    if (userLocks?.contains(lock.id) && (pinLen || (maxPinLen && minPinLen))) { // Check if the lock support reporting pin length and it has a valid number to report (not 0 or null)
                        if ((priorCode?.size() > 0) && (pinLen ? pinLen != priorCode.size() : ((priorCode.size() < minPinLen) || (priorCode.size() > maxPinLen)))) { // If we have a code to program
                            def msg = "YOUR LOCK IS CONFIGURED TO ACCEPT ${pinLen ?: "${minPinLen}-${maxPinLen}"} DIGIT CODES ONLY, PROGRAMMING WILL FAIL!"
                            paragraph title: msg, required: true, ""
                            break // one message is enough
                        }
                    }
                }

                // Sanity check for expiration date formats
                switch (priorUserType) {
                    case 'Expire on':
                        if (priorStartDate) {
                            //log.trace "Found start date in setup"
                            try {
                                def df = new java.text.SimpleDateFormat("yyyy-MM-dd")
                                df.setLenient(false) // we want strict formatting
                                log.trace "Start:" + df.parse(priorStartDate)
                                invalidStartDate = false
                            }
                            catch (Exception e) {
                                log.warn "Invalid start date in setup"
                                invalidStartDate = true
                            }
                        }
                        if (priorExpireDate) {
                            //log.trace "Found expiry date in setup"
                            try {
                                def df = new java.text.SimpleDateFormat("yyyy-MM-dd")
                                df.setLenient(false) // we want strict formatting
                                log.trace "Expire:" + df.parse(priorExpireDate)
                                invalidExpiryDate = false // We passed it's a valid date
                            }
                            catch (Exception e) {
                                log.warn "Invalid expiry date in setup"
                                invalidExpiryDate = true
                            }
                        }

                        if (!invalidExpiryDate && !invalidStartDate) {
                            if (priorExpireDate) {
                                def expired = false
                                if (priorExpireTime) {
                                    // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally
                                    def exp = Date.parse("yyyy-MM-ddHH:mmZ", priorExpireDate + timeToday(priorExpireTime, timeZone).format("HH:mmZ", timeZone))
                                    if (exp.getTime() < now()) {
                                        paragraph title: "Code EXPIRED!", required: true, ""
                                        expired = true
                                    } else {
                                        if (priorStartDate && priorStartTime && !expired) {
                                            def start = Date.parse("yyyy-MM-ddHH:mmZ", priorStartDate + timeToday(priorStartTime, timeZone).format("HH:mmZ", timeZone))
                                            if (start.getTime() > now()) {
                                                def startStr = start.format("EEE MMM dd yyyy HH:mm z", timeZone)
                                                paragraph title: "Code activates on ${startStr}", required: true, ""
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break

                    case 'One time':
                        if (state.trackUsedOneTimeCodes?.contains(i as String)) {
                            paragraph title: "One time code USED!", required: true, ""
                        }
                        break

                    default:
                        break
                }
            }

            // User and code details/types
            input "userNames${i}", "text", description: "Tap to set", title: "Name", multiple: false, required: (settings."userCodes${i}" ? true : false), submitOnChange: false, image: "http://www.rboyapps.com/images/User.png"
            input "userCodes${i}", "text", description: "Tap to set", title: "Code${pinLen ? " (${pinLen} digits)" : ((minPinLen && maxPinLen) ? " (${minPinLen}-${maxPinLen} digits)" : "")}", multiple: false, required: false, submitOnChange: true, image: "http://www.rboyapps.com/images/Code.png" // Input it type text otherwise users can't enter the number starting with 0

            // Lock selection
            if (locks?.size() > 1) {
                input "userLocks${i}", "enum", description: "Select locks", title: "Only on these lock(s) (optional)", options: selectLocks, multiple: true, required: false, image: "http://www.rboyapps.com/images/HandleLock.png"
            }

            // User Type (Permanent, One Time, Scheduled, etc)
            input "userType${i}", "enum", title: "Select User Type", required: true, multiple: false, options: codeOptions(), defaultValue: 'Permanent', submitOnChange: true, image: "http://www.rboyapps.com/images/Schedule.png"

            // Expiration/Scheduling options
            switch (priorUserType) {
                case 'Expire on':
                    if (invalidStartDate == true) {
                        paragraph title: "INVALID START DATE - PLEASE CHECK YOUR DATE FORMAT", required: true, ""
                    }
                    input "userStartDate${i}", "date", title: "...code start date (YYYY-MM-DD) (optional)", description: "Date on which the code should be enabled", required: false,  submitOnChange: true
                    if (priorStartDate) {
                        input "userStartTime${i}", "time", title: "...code start time", description: "The code would be enabled within 2 minutes of this time", required: true,  submitOnChange: false
                    }
                    if (invalidExpiryDate == true) {
                        paragraph title: "INVALID EXPIRY DATE - PLEASE CHECK YOUR DATE FORMAT", required: true, ""
                    }
                    input "userExpireDate${i}", "date", title: "...code expiration date (YYYY-MM-DD)", description: "Date on which the code should be deleted", required: true, submitOnChange: true
                    input "userExpireTime${i}", "time", title: "...code expiration time", description: "The code would be deleted within 2 minutes of this time", required: true, submitOnChange: false
                    break

                case 'Scheduled':
                    // 3 schedule options for each user
                    ('A'..'C').each { schedule ->
                        def hrefParams = [
                            user: i as String,
                            schedule: schedule,
                            passed: true
                        ]
                        href(name: "schedule${schedule}", params: hrefParams, title: "...click here to define schedule ${schedule}", page: "scheduleCodesPage", description: getUserScheduleDescription(i, schedule, timeZone), required: false)
                    }
                    break

                case 'Presence':
                    input "userPresent${i}", "capability.presenceSensor", title: "...if any these people are present", description: "Code should be active when any of these people are present", required: false, multiple: true
                    input "userNotPresent${i}", "capability.presenceSensor", title: "...and none of these people are present", description: "when all these people are not present", required: false, multiple: true
                    break

                case 'Modes':
                    input "userModes${i}", "mode", title: "...when in this mode(s)", description: "Code should be active only during these modes", required: true, multiple: true
                    break

                default:
                    break
            }

            // Notifications for each user
            input "userNotify${i}", "bool", title: "Notify on use", defaultValue: true, required: false, submitOnChange: true, image: "http://www.rboyapps.com/images/Notifications.png"
            if (priorNotify != false) {
                input "userNotifyUseCount${i}", "number", title: "...limit to only this many times", description: "No limit", required: false, range: "1..*"
                input "userNotifyModes${i}", "mode", title: "...only when in this mode(s)", description: "Notify only when in any of these modes", required: false, multiple: true
                input "userXNotifyPresence${i}", "capability.presenceSensor", title: "...and none of these people are present", description: "when all these people are not present", required: false, multiple: true
            }

            // Unlock actions for each user
            def hrefParams = [
                user: i as String, 
                passed: true 
            ]
            href(name: "unlockLockActions", params: hrefParams, title: "Custom actions/notifications", page: "unlockLockActionsPage", description: (settings."userOverrideUnlockActions${user}" || settings."userOverrideNotifications${user}") ? "Configured" : "", required: false, image: "http://www.rboyapps.com/images/LockUnlock.png")
        }
    }
}

private getSelectLocks() {
    return (locks?.collectEntries { [ (it.id) : (it.displayName) ] })?.sort { it.value.toLowerCase() } // Get lock_id:lock_name and sort by name
}

private getUserScheduleDescription(i, schedule, timeZone) {
    def retVal = "Not defined"
    if (settings."userDayOfWeek${schedule}${i}") {
        retVal = ""
        settings."userDayOfWeek${schedule}${i}".each { retVal += (retVal ? ", " : "") + it }// DOW
        retVal += ": " + (settings."userStartTime${schedule}${i}" ? timeToday(settings."userStartTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : "") // Start Time
        retVal += " - " + (settings."userEndTime${schedule}${i}" ? timeToday(settings."userEndTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : "") // EndTime
    }
    return retVal
}

def scheduleCodesPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def schedule = ""
    // Get user from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.user) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    // Get schedule from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.schedule) {
        schedule = params.schedule ?: ""
        log.trace "Passed from main page, using params lookup for schedule $schedule"
    } else if (atomicState.params) {
        schedule = atomicState.params.schedule ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for schedule $schedule"
    } else {
        log.error "Invalid params, no schedule found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Schedule Codes Page, schedule:$schedule, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"scheduleCodesPage", title: "Define schedule ${schedule}" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        section() {
            def i = user as Integer
            def priorUserDayOfWeek = settings."userDayOfWeek${schedule}${i}"
            def priorUserStartTime = settings."userStartTime${schedule}${i}"
            def priorUserEndTime = settings."userEndTime${schedule}${i}"
            log.trace "Schedule:$schedule, User:$i, Name: $name, UserDayOfWeek: $priorUserDayOfWeek, UserStartTime: $priorUserStartTime, UserEndTime: $priorUserEndTime"

            input "userStartTime${schedule}${i}", "time", title: "Start Time", required: false
            input "userEndTime${schedule}${i}", "time", title: "End Time", required: false
            input "userDayOfWeek${schedule}${i}",
                "enum",
                title: "Which day of the week?",
                description: "Not defined",
                required: false,
                multiple: true,
                options: [
                    'All Week',
                    'Monday to Friday',
                    'Saturday & Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday',
                    'Sunday'
                ]
        }
    }
}

// Check if the lock pin code length match on all the locks
// pinLen - Fixed pin code length
// maxPinLen - Variable minimum pin code length
// minPinLen - Variable maximum pin code length
// pinLenError - true / false
private getLockPinLengthDetails() {
    def pinLen = null // Fixed pin code length
    def maxPinLen = null // Variable minimum pin code length
    def minPinLen = null // Variable maximum pin code length
    def pinLenError = false

    for (lock in locks) {
        def codeLen = lock.hasAttribute("pinLength") ? lock.currentValue("pinLength") : (lock.hasAttribute("codeLength") ? lock.currentValue("codeLength") : null)
        def maxCodeLen = lock.hasAttribute("maxPINLength") ? lock.currentValue("maxPINLength") : null
        def minCodeLen = lock.hasAttribute("minPINLength") ? lock.currentValue("minPINLength") : null
        log.trace "$lock fixed code length: $codeLen, max code length: $maxCodeLen, min code length: $minCodeLen"
        if (codeLen && pinLen) { // If lock has fixed pin length and previous lock also had fixed pin length
            if ((codeLen != pinLen) || (maxPinLen && (codeLen > maxPinLen)) || (minPinLen && (codeLen < minPinLen))) { // Check if we have pin mismatches
                pinLenError = true // All locks must have the same pinLength
            }
        } else if (codeLen) { // If lock has fixed pin length
            pinLen = codeLen // Save the length for future use
        } else if (minCodeLen && maxCodeLen) { // Check for range validation
            if (!minPinLen || (minCodeLen > minPinLen)) {
                minPinLen = minCodeLen
            }
            if (!maxPinLen || (maxCodeLen < maxPinLen)) {
                maxPinLen = maxCodeLen
            }
        }
    }
    
    return [ pinLen: pinLen, maxPinLen: maxPinLen, minPinLen: minPinLen, pinLenError: pinLenError ]
}



def installed()
{
    log.debug "Install Settings: $settings"
    state.clearCodes = true // On a fresh install start by clearing all codes to avoid issues
    appTouch()
}

def updated()
{
    log.debug "Update Settings: $settings"
    if (!state.clearCodes) { // Some bug in the platform, calls updated on install so skip it
        appTouch()
    }
}

def appTouch() {
    state.clientVersion = clientVersion() // Update our local stored client version to detect code upgrades
    
    unschedule() // clear all pending updates
    unsubscribe()

    // Sanity check for codes
    for (int i = 1; i <= maxUserNames; i++) {
        def name1 = settings."userNames${i}"
        def code1 = settings."userCodes${i}"
        for (int j = 1; j <= maxUserNames; j++) {
            def name2 = settings."userNames${j}"
            def code2 = settings."userCodes${j}"
            if (code1 && (i != j) && (code1 == code2)) { // Don't print error on null codes
                def msg = "CODE CONFLICT LOCK PROGRAMMING MAY FAIL - USER $name1 IN SLOT $i and USER $name2 IN SLOT $j SHARE THE SAME CODE $code1.\r\nMULTIPLE USERS CANNOT HAVE THE SAME CODE!!"
                log.error msg
                sendNotifications(msg)
            }
        }
        
        // Check if the user has entered a non digit string
        if ((code1?.size() > 0) && !code1?.isNumber()) {
            def msg = "CODE IS NOT A NUMBER, PROGRAMMING WILL FAIL - USER $name1 IN SLOT $i DOES NOT CONTAIN A NUMERIC PIN"
            log.error msg
            sendNotifications(msg)            
        }
        
        // Check if the lock pin code length match the pin code length entered by the user
        def userLocks = settings."userLocks${i}" ?: locks*.id // Use the defined locks or if not defined then check all locks
        for (lock in locks) {
            def codeLen = lock.hasAttribute("pinLength") ? lock.currentValue("pinLength") : (lock.hasAttribute("codeLength") ? lock.currentValue("codeLength") : null)
            def maxCodeLen = lock.hasAttribute("maxPINLength") ? lock.currentValue("maxPINLength") : null
            def minCodeLen = lock.hasAttribute("minPINLength") ? lock.currentValue("minPINLength") : null
            if (userLocks?.contains(lock.id) && (codeLen || (maxCodeLen && minCodeLen))) { // Check if the lock support reporting pin length and it has a valid number to report (not 0 or null)
                if ((code1?.size() > 0) && (codeLen ? codeLen != code1.size() : ((code1.size() < minCodeLen) || (code1.size() > maxCodeLen)))) { // If we have a code to program
                    def msg = "CODE LENGTH DOES NOT MATCH LOCK PROGRAMMING LENGTH, PROGRAMMING WILL FAIL - USER $name1 IN SLOT $i REQUIRES ${codeLen ?: "${minCodeLen}-${maxCodeLen}"} DIGITS FOR LOCK ${lock}"
                    log.error msg
                    sendNotifications(msg)
                }
            }
        }
    }

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
    
    // subscribe to random events to kick start timers again due to buggy platform killing the timers after a while and presence/mode events to update code states
    subscribe(location, "mode", changeHandler)
    subscribe(location, "position", changeHandler)
    subscribe(location, "sunset", changeHandler)
    subscribe(location, "sunrise", changeHandler)
    subscribe(location, "routineExecuted", changeHandler)
    subscribe(app, changeHandler) // Capture user intent to reinitialize timers
    def presence = []// subscribe to presence
    for (int i = 1; i <= maxUserNames; i++) {
		if (settings."userType${i}" == "Presence") {
        	presence = (presence + (settings."userPresent${i}" ?: []) + (settings."userNotPresent${i}" ?: [])).unique()
        }
    }
    log.trace "Subscribing to people: $presence"
    subscribe(presence, "presence", changeHandler)

    subscribe(locks, "lock", lockHandler) // Subscribe to lock events to take action as defined as user
    subscribe(locks, "tamper", lockHandler) // Subscribe to tamper events
    subscribe(locks, "codeReport", codeResponse, [filterEvents:false]) // Subscribe to code report events to see if the code update was successful
    subscribe(locks, "codeChanged", codeResponse, [filterEvents:false]) // Subscribe to code report events to see if the code update was successful

    // Reset the code update trackers and heartbeat system
    state.lastCheck = 0
    state.lastHeartBeat = 0

    locks.each { lock -> // check each lock individually
        if (settings."sensor${lock}") {
            log.trace "Subscribing to sensor ${settings."sensor${lock}"} for ${lock}"
            subscribe(settings."sensor${lock}", "contact", sensorHandler)
        }
        if (lock.hasAttribute('invalidCode')) {
            log.trace "Found attribute 'invalidCode' on lock $lock, enabled support for invalid code detection"
            subscribe(lock, "invalidCode", lockHandler)
        }
    }

    state.usedOneTimeCodes = [:]
    state.trackUsedOneTimeCodes = [] // Track for reporting purposes
    state.retryCodeCount = [:] // Number of times a code programming has been retried
    state.codeUseCount = [:] // Number of times codes were used
    if (!state.lockCodes) {
        state.lockCodes = [:] // Save list of programmed codes, initialize only if not already done
    }
    state.updateLockList = []
    state.expiredLockList = []
    atomicState.reLocks = [:] // List of lock to relock after a timed delay
    atomicState.notifyOpenDoors = [:] // List of locks to check for open notifications
    atomicState.immediateLocks = [] // List of lock to lock immediately after a short delay
    atomicState.unLocks = [] // List of lock to unlock after a short delay
    for (lock in locks) {
        state.codeUseCount[lock.id] = [:] // Number of times a code usage was used for this lock
        state.usedOneTimeCodes[lock.id] = [] // List of used one time codes for this lock
        state.retryCodeCount[lock.id] = [:] // Number of times a code programming has been retried for the lock
        if (!state.lockCodes[lock.id]) {
            state.lockCodes[lock.id] = [:] /// Track programmed codes for this lock, initialize only if not already done
        }
        state.updateLockList.add(lock.id) // reset the state for each lock to be processed with update
        state.expiredLockList.add(lock.id) // reset the state for each lock to be processed with expired
        //log.trace "Added $lock id ${lock.id} to unprocessed locks update list ${state.updateLockList} and expire list ${state.expiredLockList}"
    }
    state.lockCodes.each { lockID, userMap ->
        if (!locks?.any { lock -> lock.id == lockID }) {
            log.debug "Lock with ID ${lockID} is no longer being programmed, stop tracking users from the lock"
            state.lockCodes[lockID] = [:] /// Stop tracking codes from this lock once we exclude the lock from our main list
        }
    }        
    state.updateNextCode = 1 // set next code to be set for the update loop
    state.expiredNextCode = 1 // set next code to be set for the expired loop

    log.trace "Install complete, code updates starting with code $state.updateNextCode"

    if (state.clearCodes) {
        clearAllCodes()
    } else {
        kickStart() // Initialize codes
    }
}

// Handle changes, reinitialize the code check timers after a change, this is to workaround the issue of a buggy ST platform where the timers die randomly for some users
def changeHandler(evt) {
    log.trace "Reinitializing code check timer on event notification, name: ${evt?.name}, value: ${evt?.value}, device: ${evt?.device}"
    
    if (evt?.name == "mode") { // Mode change notification
        for (lock in locks) { // Check all locks
            def sensor = settings."sensor${lock}" // Find the lock for this sensor, match by ID and not objects
            if (sensor) {
                log.trace "Checking for any pending door sensor activites that need to be done for lock $lock with sensor $sensor in mode ${evt.value}"
                def sensorEvt = [name: sensor.name, displayName: sensor.displayName, value: sensor.latestValue("contact"), device: sensor]
                sensorHandler(sensorEvt)
            }
        }
    }

    // Do a code check and restart the scheduler if required
    // Reset the lock list and start from 1st code in first lock and check all codes
    state.expiredLockList = []
    state.expiredNextCode = 1 // reset back to 1 for the next lock
    for (lock in locks) {
        state.expiredLockList.add(lock.id) // reset the state for each lock to be processed
        //log.trace "Added $lock id ${lock.id} back to unprocessed locks list ${state.expiredLockList}"
    }
    
    kickStart()
}

def sensorHandler(evt) {
    log.trace "Event name $evt.name, value $evt.value, device $evt.displayName"

    def sensor = evt.device

    def lock = locks.find { settings."sensor${it}"?.id == sensor.id } // Find the lock for this sensor, match by ID and not objects
    log.trace "Sensor ${sensor} belongs to Lock ${lock}"

    if (evt.value == "closed") { // Door was closed
        if (lock && settings."relockDoor${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
            if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
                log.warn "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features"
            } else {
                if (settings."relockImmediate${lock}") {
                    log.debug "Relocking ${lock} immediately in 3 seconds"
                    def immediatelocks = atomicState.immediateLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    if (!immediatelocks.contains(lock.id)) { // Don't re add the same lock again
                        //log.trace "Adding ${lock.id} to the list of immediate locks"
                        immediatelocks.add(lock.id) // Atomic to ensure we get upto date info here
                        atomicState.immediateLocks = immediatelocks // Set it back, we can't work direct on atomicState
                    }
                    immediateLockDoor() // Lock it right away
                } else if (settings."relockAfter${lock}") {
                    log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
                    def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    //log.trace "Adding ${lock.id} to the list of relocks"
                    reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                    atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
                    reLockDoor() // Call relock door it'll take of delaying the lock as required
                } else {
                    log.error "Invalid configuration, no relock timeout defined"
                }
            }
        }
    } else { // Door was opened
        // Chime bell
        if (settings."openNotifyBeep${lock}") {
            if (!settings."openNotifyModes${lock}" || (settings."openNotifyModes${lock}"?.find{it == location.mode})) {
                log.debug "Door ${sensor} was opened, chiming bell ${settings."openNotifyBeep${lock}"}"
                settings."openNotifyBeep${lock}".beep() // Beep
            } else {
                log.trace "${lock} chiming not set for Mode ${location.mode}"
            }
        }

        // Notify user
        if (settings."openNotify${lock}") {
            if (!settings."openNotifyModes${lock}" || (settings."openNotifyModes${lock}"?.find{it == location.mode})) {
                log.debug "Scheduling ${lock} to notify user of open door in ${settings."openNotifyTimeout${lock}"} minutes"
                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                atomicState.notifyOpenDoors = notifyOpenDoors // Set it back, we can't work direct on atomicState
                notifyOpenDoor() // Notify, it'll take of delaying it if it's too soon
            } else {
                log.trace "${lock} open notification not set for Mode ${location.mode}"
            }
        }
    }
}

// Check for any pending door unlocks
def unLockDoor() {
    def unLocksIDs = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending door unlocks ${unLocksIDs}"

    unLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "UnLocking the door ${lock} immediately"
        lock.unlock() // unlock it
        def unlocks = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending unlocks"
        unlocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.unLocks = unlocks // set it back to atomicState
        //log.trace "Checking for any pending door unlocks in 3 seconds"
        startTimer(3, unLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending immediate door locks
def immediateLockDoor() {
    def immediateLocksIDs = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending immediate door locks ${immediateLocksIDs}"

    immediateLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "Locking the door ${lock} immediately"
        lock.lock() // lock it
        def immediatelocks = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending immediate locks"
        immediatelocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.immediateLocks = immediatelocks // set it back to atomicState
        //log.trace "Checking for any pending immediate door locks in 3 seconds"
        startTimer(3, immediateLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending delayed door relocks
def reLockDoor() {
    def reLocksIDs = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking door sensor state and relocking ${reLocksIDs}"

    Long shortestPendingTime = 0 // in seconds
    
    reLocksIDs?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        Long timeLeft = (((60 * 1000 * settings."relockAfter${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (!lockSensor) { // If we don't have a sensor then just lock on schedule
                log.info "No sensor found on ${lock} when closed, locking the door"
                lock.lock() // lock it
                //log.trace "Removing ${lockid} from the list of pending relocks"
                def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                reLocks.remove(lockid) // We are done with this lock, remove it from the list
                atomicState.reLocks = reLocks // set it back to atomicState
                //log.trace "Checking for any pending relocks in 3 seconds"
                startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                return // We're done here
            } else if (lockSensor.latestValue("contact") == "closed") {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is closed, locking the door"
                lock.lock() // lock it
                //log.trace "Removing ${lockid} from the list of pending relocks"
                def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                reLocks.remove(lockid) // We are done with this lock, remove it from the list
                atomicState.reLocks = reLocks // set it back to atomicState
                //log.trace "Checking for any pending relocks in 3 seconds"
                startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                return // We're done here
            } else {
                log.debug "Sensor ${lockSensor} is reporting door ${lock} is not closed, will check again in 60 seconds"
                startTimer(60, reLockDoor) // Check back again in some time
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."relockAfter${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), reLockDoor) // Check back again after shortest pending timeout
    }
}

// Notify if the doors are left open
def notifyOpenDoor() {
    def notifyOpenDoorsIds = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking Locks ${notifyOpenDoorsIds} door sensor state"

    Long shortestPendingTime = 0 // in seconds
    
    notifyOpenDoorsIds?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        Long timeLeft = (((60 * 1000 * settings."openNotifyTimeout${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (lockSensor.latestValue("contact") == "closed") {
                log.trace "Sensor ${lockSensor} is reporting door ${lock} is closed, no notification required"
                //log.trace "Removing ${lockid} from the list of pending notifications"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors.remove(lock.id) // We are done with this lock, remove it from the list
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState
            } else {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is open, notifying user and checking again after ${settings."openNotifyTimeout${lock}"} minutes"
                def msg = "$lockSensor has been open for ${settings."openNotifyTimeout${lock}"} minutes"

                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState

                startTimer(60, notifyOpenDoor) // Check back again after short timeout so we don't overwrite a short wait with a long wait
                sendNotifications(msg) // Do it in the end to avoid a timeout
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."openNotifyTimeout${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), notifyOpenDoor) // Check back again after shortest pending timeout
    }
}

def codeResponse(evt) {
    def lock = evt.device
    def user = evt.value?.isInteger() ? evt.value as Integer : null
    def type = null
    if (!user) { // For new handler codeChanged doesn't report the user slot, we need to extract it (we only subscribe to codeChanged and codeReport)
    	def value = evt.value?.split(" ")?.first()?.trim()
        user = value?.isInteger() ? value as Integer : null
        if (evt.value?.split(" ")?.size() > 1) {
            type = evt.value?.split(" ")?.last()?.trim() // Get the transaction type
        }
    }
    def code = evt.data ? parseJson(evt.data)?.code : "" // Not all locks return a code due to a bug in the base Z-Wave lock device code
    def desc = evt.descriptionText // Description can have "is set" or "was added" or "changed" when code was added successfully
    def name = settings."userNames${user}"

    log.trace "$lock code report ${evt.name} returned Name:${name ?: ""}, User:${user}, Code:${code}, Desc:${desc}, Value: ${evt.value}, Type: ${type}"
    
    if ((evt.name == "codeChanged") && (evt.value == "all deleted" || evt.value == "all")) { // Special case, when lock is reset all codes are deleted, we don't have a user id for this one
        // First update tracking lists for used one time codes - to avoid a race condition with programmed codes
        state.usedOneTimeCodes[lock.id] = [] // Reset list as all codes are deleted
        state.codeUseCount[lock.id] = [:] // Reset code usage count
        state.lockCodes[lock.id] = [:] // Reset list
        state.retryCodeCount[lock.id] = [:] // Reset list
        def msg = "All user codes were deleted from $lock"
        log.info msg
        sendNotifications(msg) // This is mandatory as a special exception
        return // We're done here
    } else if (!user) {
        log.warn "No user slot/id found in code reponse from lock, ignoring report"
        return // We're done here
    }

    switch (type) { // For new device handler we already have a type and so lets use it
        case "set":
        case "changed":
        	type = "added" // Update the type
            break
            
        case "deleted":
        case "unset":
        	type = "deleted"
            break
            
        case "failed":
        	if (desc?.contains("duplicate")) { // DTH inaccurately reports some failed programming codes as duplicate so check extended event for real reason
                type = "duplicate"
            } // If a previous code reponse notification was lost it will report failed, but don't try to add it because a genuine failure cannot be captures. This is an issue to lock communication with z-wave mesh which needs to be addressed
            break
            
        case "renamed":
        	type = "renamed"
            break
            
        case null: // This is if we are using the device handlers which use codeReport
            if (evt.name == "codeReport") {
                if ((["is set", "added", "changed"].any { desc?.contains(it) }) && !(["unset"].any { desc?.contains(it) })) { // Bug with new ST handler uses the words changed and unset in CodeChanged event
                    type = "added"
                } else if (["is not set", "deleted"].any { desc?.contains(it) }) {
                    type = "deleted"
                } else if (["duplicate"].any { desc?.contains(it) }) {
                    type = "duplicate"
                }
            }
            break
            
        default:
            log.warn "Ignoring transaction from $lock for user $user: ${desc}"
	        return // We're done here
            break
    }
    
    if (!type) {
        log.warn "Ignoring transaction from $lock for user $user: ${desc}"
        return // We're done here
    }
    
    def currentCode = settings."userCodes${user}" as String

    if (!(state.lockCodes[lock.id].(user as String)) && (type == "failed")) { // Only process duplicate code notitications if the user is not already programmed in our list
        def msg = "$lock failed to add user $user. Retrying again"
        log.warn msg
        detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg) // It can fail if the user was added by other means, so we only report if needed
        return // We're done here
    }
    
    if (!(state.lockCodes[lock.id].(user as String)) && (type == "duplicate")) { // Only process duplicate code notitications if the user is not already programmed in our list
        def msg = "$lock reported user $user is a duplicate code! Please clear extra codes from your lock"
        log.warn msg
        sendNotifications(msg) // This is mandatory, cannot ignore
        return // We're done here
    }
    
    if ((state.lockCodes[lock.id].(user as String)) && (type == "renamed")) { // Only rename slots that we have in our list
        def newName = desc?.split('" to "')?.last()?.replaceAll('"', '') // Get new name and remove quotes
        if (newName && (newName != name)) { // Cannot be blank and should be different
            updateSetting("userNames${user}", newName)
            def msg = "$lock renamed user $user from $name to $newName"
            log.info msg
            detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
        }
        return // We're done here
    }
    
    if ((state.lockCodes[lock.id].(user as String) != currentCode) && (type == "added")) { // We can get the notifications multiple times
        state.lockCodes[lock.id][user as String] = currentCode
        state.retryCodeCount[lock.id][user as String] = 0 // Reset the retry
        def msg = "Confirmed $lock added $name to user $user"
        log.info msg
        detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
        return // We're done here
    }

    if ((state.lockCodes[lock.id].(user as String)) && (type == "deleted")) { // We can get the notifications multiple times (don't track "was reset" as that's an intermediary notification while setting a code)
        // First update tracking lists for used one time codes - to avoid a race condition with programmed codes
        if (state.usedOneTimeCodes[lock.id].contains(user as String)) {
            state.usedOneTimeCodes[lock.id].remove(user as String)
            log.trace "Deleted code was a used one time code, removing it from list of used one time codes"
        }
        state.codeUseCount[lock.id].remove(user as String) // Don't track the usage for this code anymore
        state.lockCodes[lock.id].remove(user as String)
        state.retryCodeCount[lock.id][user as String] = 0 // Reset the retry
        def msg = "Confirmed ${name ?: ""} user $user was deleted from $lock"
        log.info msg
        detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
        return // We're done here
    }
}

// Lock event handler
def lockHandler(evt) {
    def data = null
    def lock = evt.device
    
    log.trace "Lock event name $evt.name, value $evt.value, device $evt.displayName, description $evt.descriptionText, data $evt.data"

    def evtMap = [name:evt.name, value:evt.value, displayName:evt.displayName, descriptionText:evt.descriptionText, data:evt.data, lockId: evt.device.id]

    if (evt.name == "lock") { // LOCK UNLOCK EVENTS
        if (evt.value == "unlocked") { // UNLOCKED
            unschedule(processLockActions) // If there was a pending delayed actions and user operated the lock then cancel it
            processUnlockEvent(evtMap)
        } else if (evt.value == "locked") { // LOCKED MANUALLY OR VIA KEYPAD OR ELECTRONICALLY
            unschedule(processLockActions) // If there was a pending delayed actions and user operated the lock then cancel it
            processLockEvent(evtMap)
        } else if (evt.value == "unknown") { // JAMMED CODE EVENT
            log.debug "Lock $evt.displayName Jammed!"
            if ((!settings."individualDoorActions" && jamNotify) ||
                (settings."individualDoorActions" && settings."jamNotify${lock}")) {
                def msg = "$evt.displayName lock is Jammed!"
                sendNotifications(msg)
            }        	
        }
    } else if (evt.name == "invalidCode") { // INVALID LOCK CODE EVENT
        log.debug "Lock $evt.displayName, invalid user code: ${evt.value}"
        def msg = "Too many invalid user codes detected on lock $evt.displayName"
        sendNotifications(msg)
    } else if (evt.name == "tamper" && evt.value == "detected") { // Tampering of the lock
        log.debug "Lock $evt.displayName tamper detected with description $evt.descriptionText"
        def msg = "Tampering detected on lock $evt.displayName. ${evt.descriptionText ?: ""}"
        sendNotifications(msg)
    }
}

def processUnlockEvent(evt) {
    def data = null
    def lock = locks.find { it.id == evt.lockId }

	log.trace "Processing $lock unlock event: $evt"

    // Check if we have delayed relock is enabled, if so then start the timer now just incase the user never opens the door (reLockDoor will take care of sensor if present, immediate relock should never happen without a sensor)
    if (settings."relockDoor${lock}" && settings."relockAfter${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
        if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
            log.warn "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features"
        } else {
            log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
            def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
            //log.trace "Adding ${lock.id} to the list of relocks"
            reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
            atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
            reLockDoor() // Call relock door it'll take of delaying the lock as required
        }
    } else {
        log.trace "Relock conditions not met, not scheduling relock"
    }

    if (evt.data) { // Was it unlocked using a code
        data = parseJson(evt.data)
    }
    def lockMode = data?.type ?: (data?.method ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically"))
    // Fix for proper grammar
    switch (lockMode) {
        case "manual":
        lockMode = "manually"
        break

        case "rfid":
        lockMode = "via RFID"
        break

        case "bluetooth":
        lockMode = "via bluetooth"
        break

        case "keypad":
        lockMode = "via keypad"
        break

        case "remote":
        case "command":
        lockMode = "remotely"
        break

        case "auto":
        lockMode = "via internal autolock"
        break

        default:
            break
    }

    if ((data?.usedCode == null) && !(["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) })) { // No extended data, must be a manual/auto/keyed unlock, NOTE: some locks don't send keypad user codes
        log.trace "$evt.displayName was unlocked manually. Source type: $lockMode"

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // First disarm SHM since it goes off due to other events
        if (settings."runXPeopleUnlockActionsManual${lockStr}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleUnlockActionsManual${lockStr}"?.find{it.currentPresence == "present"}} is present, not running unlock actions for door $lock"
        } else if (settings."runXModeUnlockActionsManual${lockStr}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running unlock actions for door $lock"
        } else {
            def msg = "$evt.displayName was unlocked $lockMode"

            if (settings."homeDisarmManual${lockStr}") {
                log.info "Disarming Smart Home Monitor"
                sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
            }

            if (settings."homeModeManual${lockStr}") {
                log.info "Changing mode to ${settings."homeModeManual${lockStr}"}"
                if (location.modes?.find{it.name == settings."homeModeManual${lockStr}"}) {
                    setLocationMode(settings."homeModeManual${lockStr}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."homeModeManual${lockStr}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."homeModeManual${lockStr}"}" : ""
            }

            if (settings."homePhraseManual${lockStr}") {
                log.info "Running unlock Phrase ${settings."homePhraseManual${lockStr}"}"
                location.helloHome.execute(settings."homePhraseManual${lockStr}") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", running routine ${settings."homePhraseManual${lockStr}"}" : ""
            }

            if (settings."turnOnSwitchesAfterSunsetManual${lockStr}") {
                def cdt = new Date(now())
                def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                    log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunsetManual${lockStr}"} since it's after sunset but before sunrise"
                    settings."turnOnSwitchesAfterSunsetManual${lockStr}"?.on()
                    msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunsetManual${lockStr}"}" : ""
                }
            }

            if (settings."turnOnSwitchesManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitchesManual${lockStr}"}"
                settings."turnOnSwitchesManual${lockStr}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitchesManual${lockStr}"}" : ""
            }

            if (settings."turnOffSwitchesManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitchesManual${lockStr}"}"
                settings."turnOffSwitchesManual${lockStr}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitchesManual${lockStr}"}" : ""
            }

            if (settings."unlockLocksManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, unlocking ${settings."unlockLocksManual${lockStr}"}"
                settings."unlockLocksManual${lockStr}"?.unlock()
                msg += detailedNotifications ? ", unlocking ${settings."unlockLocksManual${lockStr}"}" : ""
            }

            if (settings."openGarageManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, opening ${settings."openGarageManual${lockStr}"}"
                settings."openGarageManual${lockStr}"?.open()
                msg += detailedNotifications ? ", opening ${settings."openGarageManual${lockStr}"}" : ""
            }

            if (settings."manualNotify${lockStr}" && (settings."manualNotifyModes${lockStr}" ? settings."manualNotifyModes${lockStr}".find{it == location.mode} : true)) {
                sendNotifications(msg)
            }
        }
    } else { // KEYPAD / RFID UNLOCK
        Integer i = data.usedCode as Integer
        def name = settings."userNames${i}"
        def notify = settings."userNotify${i}"
        def notifyCount = settings."userNotifyUseCount${i}"
        def notifyModes = settings."userNotifyModes${i}"
        def notifyXPresence = settings."userXNotifyPresence${i}"

        log.trace "Lock $evt.displayName unlocked by $name, notify $notify, notify count: $notifyCount, notify modes $notifyModes, notify NOT present $notifyXPresence, Source type: $lockMode"

        def msg = ""

        if (i == 0) {
            name = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
            notify = true // always inform about master users
        }

        if (name == null) { // will handle usedCode null errors
            notify = true // always inform about unknown users
            msg = "$evt.displayName was unlocked by Unknown User from slot $i $lockMode"
        } else {
            msg = "$evt.displayName was unlocked by $name $lockMode"
        }

        // Check if we have user override unlock actions defined
        def user = ""
        if (settings."userOverrideUnlockActions${i as String}") {
            log.trace "Found per user unlock actions"
            user = i as String
        }

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions${user}") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // First disarm SHM since it goes off due to other events
        if (settings."runXPeopleUnlockActions${lockStr}${user}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleUnlockActions${lockStr}${user}"?.find{it.currentPresence == "present"}} is present, not running unlock actions for door $lock"
        } else if (settings."runXModeUnlockActions${lockStr}${user}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running unlock actions for door $lock"
        } else {
            // If we have a specific mode passed by the keypad lets use that otherwise use configured options
            if (settings."keypadArmDisarm${lockStr}${user}" && (data instanceof org.codehaus.groovy.grails.web.json.JSONObject ? !data?.isNull("armMode") : (data?.armMode != null))) { // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442
                switch (data.armMode) { // Set Keypad lock state
                    case "disarmed":
                    	log.info "Disarming Smart Home Monitor"
                    	sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                        lock.setDisarmed()
                        msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
                    	break
                        
                    default:
                        log.warn "Invalid SHM mode detected: ${data.armMode}"
                        msg += ", invalid Smart Home Monitor mode ${data.armMode}"
                        break
                }
            } else if (settings."homeDisarm${lockStr}${user}") {
                log.info "Disarming Smart Home Monitor"
                sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
            }

            if (settings."homeMode${lockStr}${user}") {
                log.info "Changing mode to ${settings."homeMode${lockStr}${user}"}"
                if (location.modes?.find{it.name == settings."homeMode${lockStr}${user}"}) {
                    setLocationMode(settings."homeMode${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."homeMode${lockStr}${user}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."homeMode${lockStr}${user}"}" : ""
            }

            if (settings."homePhrase${lockStr}${user}") {
                log.info "Running unlock Phrase ${settings."homePhrase${lockStr}${user}"}"
                location.helloHome.execute(settings."homePhrase${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", running routine ${settings."homePhrase${lockStr}${user}"}" : ""
            }

            if (settings."turnOnSwitchesAfterSunset${lockStr}${user}") {
                def cdt = new Date(now())
                def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                    log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${lockStr}${user}"} since it's after sunset but before sunrise"
                    settings."turnOnSwitchesAfterSunset${lockStr}${user}"?.on()
                    msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunset${lockStr}${user}"}" : ""
                }
            }

            if (settings."turnOnSwitches${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${lockStr}${user}"}"
                settings."turnOnSwitches${lockStr}${user}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitches${lockStr}${user}"}" : ""
            }

            if (settings."turnOffSwitches${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${lockStr}${user}"}"
                settings."turnOffSwitches${lockStr}${user}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitches${lockStr}${user}"}" : ""
            }
            
            if (settings."unlockLocks${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, unlocking ${settings."unlockLocks${lockStr}${user}"}"
                settings."unlockLocks${lockStr}${user}"?.unlock()
                msg += detailedNotifications ? ", unlocking ${settings."unlockLocks${lockStr}${user}"}" : ""
            }

            if (settings."openGarage${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, opening ${settings."openGarage${lockStr}${user}"}"
                settings."openGarage${lockStr}${user}"?.open()
                msg += detailedNotifications ? ", opening ${settings."openGarage${lockStr}${user}"}" : ""
            }
        }

        // Check for one time codes and disable them if required
        def userType = settings."userType${i}" // User type
        def userLocks = settings."userLocks${i}" // Configured locks
        if (((locks?.size() == 1) || !userLocks || userLocks?.contains(lock.id)) && (userType == 'One time')) {
            if (!state.usedOneTimeCodes[lock.id].contains(i as String)) {
                log.trace "Marking one time code as used and requesting removal from lock"
                state.usedOneTimeCodes[lock.id].add(i as String) // mark the user slot used
                codeCheck() // Check the expired code and remove from lock
            } else {
                log.warn "One time code is ALREADY marked as used"
            }
        }

        // Send notifications
        if (i) { // If we have a known user, increment the usage count
            state.codeUseCount[lock.id][i as String] = (state.codeUseCount[lock.id][i as String] ?: 0) + 1
        }
        if (notify && (
            	(notifyModes ? notifyModes?.find{it == location.mode} : true) &&
            	(notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
            ) && (
            	!i || (notifyCount ? (state.codeUseCount[lock.id][i as String] <= notifyCount) : true)
        )) {
            sendNotifications(msg, settings."userOverrideNotifications${user}" ? user : "")
        }
    }
}

def processLockEvent(evt) {
    def data = null
    def lock = locks.find { it.id == evt.lockId }

    log.trace "Processing $lock lock event: $evt"

    def msgs = [] // Message to send
    def lockStr = "" // Individual lock actions
    def user = "" // User slot used
    
    if (evt.data) { // Was it locked using a user code
        data = parseJson(evt.data)
    }
    def lockMode = data?.type ?: (data?.method ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically"))
    // Fix for proper grammar and additional lock types mapping
    switch (lockMode) {
        case "manual":
        lockMode = "manually"
        break

        case "rfid":
        lockMode = "via RFID"
        break

        case "bluetooth":
        lockMode = "via bluetooth"
        break

        case "keypad":
        lockMode = "via keypad"
        break

        case "remote":
        case "command":
        lockMode = "remotely"
        break

        case "auto":
        lockMode = "via internal autolock"
        break

        default:
            break
    }

    evt.lockMode = lockMode // Save the lockMode calculated
    evt.data = data // Update the data to be passed
    user = (data?.usedCode as String) ?: "" // get the user if present
    log.trace "$lock locked by user $user $lockMode"

    // Check if we have user override unlock actions defined
    if (user && !settings."userOverrideUnlockActions${user}") {
        log.trace "Did not find per user lock actions, falling back to global lock actions"
        user = ""
    }

    // Check if we have individual actions for each lock
    if (settings."individualDoorActions${user}") {
        lockStr = lock as String
    } else {
        lockStr = ""
    }

    if ((["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) }) || (data?.usedCode != null)) { // LOCKED VIA KEYPAD/RFID
        // Check if we have a delayed action and process accordingly
        if (settings."delayLockActions${lockStr}${user}") {
            log.debug "Delaying keypad lock actions by ${settings."delayLockActionsTime${lockStr}${user}"} minutes"
            evt.sendNotifications = true // Since it's delayed we request notifications be sent
            startTimer(settings."delayLockActionsTime${lockStr}${user}" * 60, processLockActions, evt)
        } else {
            msgs += processLockActions(evt) // Take the message back to send out
        }
    } else { // MANUAL LOCK
        // Check if we have a delayed action and process accordingly
        if (settings."delayLockActionsManual${lockStr}") {
            log.debug "Delaying manual lock actions by ${settings."delayLockActionsTimeManual${lockStr}"} minutes"
            evt.sendNotifications = true // Since it's delayed we request notifications be sent
            startTimer(settings."delayLockActionsTimeManual${lockStr}" * 60, processLockActions, evt)
        } else {
            msgs += processLockActions(evt) // Take the message back to send out
        }
    }

    // Check if we need to retract a deadbolt lock it was locked while the door was still open
    if (settings."retractDeadbolt${lock}") {
        def sensor = settings."sensor${lock}"
        if (sensor.latestValue("contact") == "open") {
            if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) { // Do not unlock if autolock features on the lock are enabled, avoid infinite loop
                def msg = "Disable AutoLock on $lock lock to avoid an infinite locking/unlocking loop while using the 'Unlock on door open' feature"
                log.warn msg
                msgs << msg
            } else {
                log.debug "$lock was locked while the door was still open, unlocking it in 10 seconds"
                def unlocks = atomicState.unLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                if (!unlocks.contains(lock.id)) { // Don't re add the same lock again
                    //log.trace "Adding ${lock.id} to the list of unlocks"
                    unlocks.add(lock.id) // Atomic to ensure we get upto date info here
                    atomicState.unLocks = unlocks // Set it back, we can't work direct on atomicState
                }
                startTimer(10, unLockDoor) // Schedule the unlock in 10 seconds since the door may have just locked and avoid Z-Wave conflict and some locks like Schlage deadbolt have timing limitations which cause a busy conflict if done too soon
            }
        } else {
            log.trace "$lock was locked while the door was closed, we're good"
        }
    }

    // Last thing to do because it can timeout
    for (msg in msgs) {
        sendNotifications(msg, settings."userOverrideNotifications${user}" ? user : "")
    }
}

def processLockActions(evt) {
    def data = evt.data
    def lock = locks.find { it.id == evt.lockId }
    def msgs = [] // Message to send
    def lockMode = evt.lockMode

    log.trace "Processing $lock lock actions: $evt"

    if ((["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) }) || (data?.usedCode != null)) { // LOCKED VIA KEYPAD/RFID
        def user = ""
        def name, notify, notifyCount, notifyModes, notifyXPresence, extLockNotify, extLockNotifyModes, userOverrideActions

        if ((data instanceof org.codehaus.groovy.grails.web.json.JSONObject ? !data?.isNull("usedCode") : (data?.usedCode != null)) && (data?.usedCode >= 0)) { // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442
            Integer i = data.usedCode as Integer

            if (i == 0) {
                name = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
                notify = true // always inform about master users
            } else {
                user = i as String
                name = settings."userNames${i}"
                notify = settings."userNotify${i}"
                notifyCount = settings."userNotifyUseCount${i}"
                notifyModes = settings."userNotifyModes${i}"
                notifyXPresence = settings."userXNotifyPresence${i}"
                userOverrideActions = settings."userOverrideUnlockActions${i}"

                // Check if we have user override lock actions defined
                if (!userOverrideActions) {
                    log.trace "No user $name specific lock action found, falling back to global actions"
                    user = "" // We don't have a user specific action defined, fall back to global actions
                }
            }
        } else {
            log.trace "No usercode found in extended data for external user lock"
        }

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions${user}") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        extLockNotify = settings."externalLockNotify${lockStr}"
        extLockNotifyModes = settings."externalLockNotifyModes${lockStr}"

        log.trace "Lock $evt.displayName locked by $name, user notify $notify, notify count: $notifyCount, user notify modes $notifyModes, notify NOT present $notifyXPresence, external notify $extLockNotify, external notify modes $extLockNotifyModes, user override action $userOverrideActions, Source type: $lockMode"

        def msg = "$evt.displayName was locked ${name ? "by " + name + " " : ""}$lockMode" // Default message to send

        if (settings."runXPeopleLockActions${lockStr}${user}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleLockActions${lockStr}${user}"?.find{it.currentPresence == "present"}} is present, not running lock actions for door $lock"
        } else if (settings."runXModeLockActions${lockStr}${user}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running lock actions for door $lock"
        } else {
            // If we have a specific mode passed by the keypad lets use that otherwise use configured options
            if (settings."keypadArmDisarm${lockStr}${user}" && (data instanceof org.codehaus.groovy.grails.web.json.JSONObject ? !data?.isNull("armMode") : (data?.armMode != null))) { // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442
                switch (data.armMode) { // Set Keypad lock state
                    case "armedStay":
                    case "armedNight":
                    	log.info "Arming Smart Home Monitor to Stay"
                        lock.setArmedStay()
                        sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Stay" : ""
                    	break
                    
                    case "armedAway":
                    	log.info "Arming Smart Home Monitor to Away"
                        lock.setArmedAway()
                        sendLocationEvent(name: "alarmSystemStatus", value: "away")
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Away" : ""
                    	break
                        
                    default:
                        log.warn "Invalid SHM mode detected: ${data.armMode}"
                    	msg += ", invalid Smart Home Monitor mode ${data.armMode}"
                        break
                }
            } else if (settings."homeArm${lockStr}${user}") {
                if (settings."homeArmStay${lockStr}${user}") {
                    log.info "Arming Smart Home Monitor to Stay"
                    sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                    msg += detailedNotifications ? ", Arming Smart Home Monitor to Stay" : ""
                } else {
                    log.info "Arming Smart Home Monitor to Away"
                    sendLocationEvent(name: "alarmSystemStatus", value: "away")
                    msg += detailedNotifications ? ", Arming Smart Home Monitor to Away" : ""
                }
            }

            if (settings."externalLockMode${lockStr}${user}") {
                log.info "Changing mode to ${settings."externalLockMode${lockStr}${user}"}"
                if (location.modes?.find{it.name == settings."externalLockMode${lockStr}${user}"}) {
                    setLocationMode(settings."externalLockMode${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."externalLockMode${lockStr}${user}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."externalLockMode${lockStr}${user}"}" : ""
            }

            if (settings."externalLockPhrase${lockStr}${user}") {
                log.info "Running $lock specific locked Phrase ${settings."externalLockPhrase${lockStr}${user}"} for ${name ?: "external lock"}"
                location.helloHome.execute(settings."externalLockPhrase${lockStr}${user}")
                msg += detailedNotifications ? ", running ${settings."externalLockPhrase${lockStr}${user}"}" : ""
            } else {
                log.trace "No individual routine configured to run when locked $lockMode for $lock"
            }

            if (settings."externalLockTurnOnSwitches${lockStr}${user}") {
                log.info "$evt.displayName was locked successfully, turning on switches ${settings."externalLockTurnOnSwitches${lockStr}${user}"}"
                settings."externalLockTurnOnSwitches${lockStr}${user}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."externalLockTurnOnSwitches${lockStr}${user}"}" : ""
            }

            if (settings."externalLockTurnOffSwitches${lockStr}${user}") {
                log.info "$evt.displayName was locked successfully, turning off switches ${settings."externalLockTurnOffSwitches${lockStr}${user}"}"
                settings."externalLockTurnOffSwitches${lockStr}${user}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."externalLockTurnOffSwitches${lockStr}${user}"}" : ""
            }
            
            if (settings."lockLocks${lockStr}${user}") {
                log.info "$evt.displayName was locked successfully, locking ${settings."lockLocks${lockStr}${user}"}"
                settings."lockLocks${lockStr}${user}"?.lock()
                msg += detailedNotifications ? ", locking ${settings."lockLocks${lockStr}${user}"}" : ""
            }

            if (settings."closeGarage${lockStr}${user}") {
                log.info "$evt.displayName was locked successfully, closing garage ${settings."closeGarage${lockStr}${user}"}"
                settings."closeGarage${lockStr}${user}"?.close()
                msg += detailedNotifications ? ", closing garage ${settings."closeGarage${lockStr}${user}"}" : ""
            }
        }

        // Send a notification if required (message would be updated)
        if (i) { // If we have a known user, increment the usage count
            state.codeUseCount[lock.id][i as String] = (state.codeUseCount[lock.id][i as String] ?: 0) + 1
        }
        if ((user && notify && (
            	(notifyModes ? notifyModes?.find{it == location.mode} : true) &&
            	(notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
            ) && (
            	!i || (notifyCount ? (state.codeUseCount[lock.id][i as String] <= notifyCount) : true)
        )) ||
            (extLockNotify && (extLockNotifyModes ? extLockNotifyModes.find{it == location.mode} : true))) {
            msgs << msg
        }
    } else { // MANUAL LOCK
        log.trace "Lock $evt.displayName locked manually, Source type: $lockMode"

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        def msg = "$evt.displayName was locked $lockMode" // Default message to send

        if (settings."runXPeopleLockActionsManual${lockStr}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleLockActionsManual${lockStr}"?.find{it.currentPresence == "present"}} is present, not running lock actions for door $lock"
        } else if (settings."runXModeLockActionsManual${lockStr}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running lock actions for door $lock"
        } else {
            if (settings."homeArmManual${lockStr}") {
                log.info "Arming Smart Home Monitor to Stay"
                sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                msg += detailedNotifications ? ", Arming Smart Home Monitor to Stay" : ""
            }

            if (settings."externalLockModeManual${lockStr}") {
                log.info "Changing mode to ${settings."externalLockModeManual${lockStr}"}"
                if (location.modes?.find{it.name == settings."externalLockModeManual${lockStr}"}) {
                    setLocationMode(settings."externalLockModeManual${lockStr}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."externalLockModeManual${lockStr}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."externalLockModeManual${lockStr}"}" : ""
            }

            if (settings."externalLockPhraseManual${lockStr}") {
                log.info "Running $lock specific locked Phrase ${settings."externalLockPhraseManual${lockStr}"} for ${name ?: "external lock"}"
                location.helloHome.execute(settings."externalLockPhraseManual${lockStr}")
                msg += detailedNotifications ? ", running ${settings."externalLockPhraseManual${lockStr}"}" : ""
            } else {
                log.trace "No individual routine configured to run when locked $lockMode for $lock"
            }

            if (settings."externalLockTurnOnSwitchesManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, turning on switches ${settings."externalLockTurnOnSwitchesManual${lockStr}"}"
                settings."externalLockTurnOnSwitchesManual${lockStr}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."externalLockTurnOnSwitchesManual${lockStr}"}" : ""
            }

            if (settings."externalLockTurnOffSwitchesManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, turning off switches ${settings."externalLockTurnOffSwitchesManual${lockStr}"}"
                settings."externalLockTurnOffSwitchesManual${lockStr}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."externalLockTurnOffSwitchesManual${lockStr}"}" : ""
            }

            if (settings."lockLocksManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, locking ${settings."lockLocksManual${lockStr}"}"
                settings."lockLocksManual${lockStr}"?.lock()
                msg += detailedNotifications ? ", locking ${settings."lockLocksManual${lockStr}"}" : ""
            }

            if (settings."closeGarageManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, closing garage ${settings."closeGarageManual${lockStr}"}"
                settings."closeGarageManual${lockStr}"?.close()
                msg += detailedNotifications ? ", closing garage ${settings."closeGarageManual${lockStr}"}" : ""
            }
        }

        // Send notitications for manual and electronic locking only, keypad is handled above with lock actions
        if (settings."lockNotify${lockStr}" && (!(["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) })) && (settings."lockNotifyModes${lockStr}" ? settings."lockNotifyModes${lockStr}".find{it == location.mode} : true)) {
            msgs << msg
        }
    }
    
    // Check if we are asked to send the notifications or return them back
    if (evt.sendNotifications) {
        // Last thing to do because it can timeout
        for (msg1 in msgs) {
            sendNotifications(msg1, settings."userOverrideNotifications${user}" ? user : "")
        }
    } else {
        return msgs
    }
}

def clearAllCodes() {
    log.trace "Clearing codes from locks"
    
    def msgs = []

    for (lock in locks) {
        if (state.updateLockList.contains(lock.id)) { // this lock codes hasn't been completely initiated
            //log.trace "Clearing codes for $lock"
            while (state.updateNextCode <= maxUserNames) {
                def i = state.updateNextCode
                def user = state.updateNextCode as Integer // which user slot are we using
                def name = settings."userNames${i}" // Get the name for the slot
                def code = settings."userCodes${i}" // Get the code for the slot
                def userLocks = settings."userLocks${i}" // Get if locks to program for this user
                
                // ST can't clear too many codes at once, so lets prioritize since this is a fresh install of the app
                // If we are adding a code to the slot then clear it here, otherwise mark the previous code as populated so the app will clear it eventually
                if (code && !((locks?.size() > 1) && userLocks && !userLocks?.contains(lock.id))) {
                    deleteCode(lock, user) // Delete the user
                    def msg = "Requesting $lock to clear user $user ${name ?: ""}"
                    log.debug msg
                } else {
                    state.lockCodes[lock.id][user as String] = "1" // Indicate (special) previous code so the app will clear it later
                }
                
                state.updateNextCode = state.updateNextCode + 1 // move onto the next code
                
                // Lets do this quickly with without waiting for the lock to delete each code since we are just clearing the DH database to have a fresh start, actual deleting would happen during initialization
                //startTimer(5, clearAllCodes) // It takes the lock about 5 seconds to clear each code and get a response (give lock time to finish up programming actions)

                // Last thing to do since it could timeout
                //detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                //return // We are done here, exit out as we've scheduled the next update
            }

            state.updateLockList.remove(lock.id) // we are done with this lock
            state.updateNextCode = 1 // reset back to 1 for the next lock
            //log.trace "$lock id $lock.id code clearing complete, unprocessed locks ${state.updateLockList}, reset next code update to $state.updateNextCode"

            msgs << "Clearing all codes from lock $lock"
        }
    }
    
    state.clearCodes = false // We're done with the initialization
    state.updateLockList = []
    for (lock in locks) {
        state.updateLockList.add(lock.id) // reset the state for each lock to be processed with initialize
        //log.trace "Added $lock id ${lock.id} to unprocessed locks update list ${state.updateLockList}"
    }

    msgs << "Starting code programming in 15 seconds"
    log.trace msgs?.last()
    startTimer(15, kickStart) // It takes the lock about 15 seconds to clear the codes and finish up pending commands

    // Last thing to do since it could timeout
    for (msg in msgs) {
        detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
    }
}

def codeCheck() {
    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion != clientVersion()) {
        def msg = "NOTE: ${app.name} detected a code upgrade. Updating configuration, please open the app and click on Save to re-validate your settings"
        log.warn msg
        startTimer(1, appTouch) // Reinitialize the app offline to avoid a loop as appTouch calls codeCheck
        sendNotifications(msg) // Do this in the end as it may timeout
        return
    }
    
    log.warn "READ THIS BEFORE PROCCEDING: IT IS NORMAL TO SEE DEBUG MESSAGES EVERY MINUTE, IT CONFIRMS THAT THE APP IS HEALTHY AND RUNNING IN THE CLOUD. IT DOES NOT COMMUNICATE WITH THE LOCK UNLESS YOU SEE A MESSAGE BOX SAYING 'REQUESTED LOCK TO XXXXX'."

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }

    log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Hack for broken ST timers - Schedule the Heartbeat
    if (((state.lastHeartBeat ?: 0) + ((10+5)*60*1000) < now()) && canSchedule()) { // Since we are scheduling the heartbeat every 10 minutes, give it a 5 minute grace
        log.warn "Heartbeat not called in last 15 minutes, rescheduling heartbeat"
        schedule("* */10 * * * ?", heartBeatMonitor) // run the heartbeat every 10 minutes
        state.lastHeartBeat = now() // give it 10 minutes before you schedule it again
    }

    // Update the last time we can code check
    state.lastCheck = now()

    for (lock in locks) {
        if (state.expiredLockList.contains(lock.id)) { // this lock codes hasn't been completely initiated
            //log.trace "If you're seeing this every few minutes, then ST is alive and kicking - ST cloud codes status for $lock"
            while (state.expiredNextCode <= maxUserNames) { // cycle through all the codes
                //log.trace "ST Cloud status for code $state.expiredNextCode on $lock"
                def i = state.expiredNextCode
                def name = settings."userNames${i}"?.trim() // Get the name for the slot and clear and leading or trailing spaces
                def code = settings."userCodes${i}" as String // Get the code for the slot
                def userType = settings."userType${i}" // User type
                def expDate = settings."userExpireDate${i}" // Get the expiration date
                def expTime = settings."userExpireTime${i}" // Get the expiration time
                def startDate = settings."userStartDate${i}" // Get the start date
                def startTime = settings."userStartTime${i}" // Get the start time
                def userPresent = settings."userPresent${i}" // Get user presence
                def userNotPresent = settings."userNotPresent${i}" // Get user not presence
                def userModes = settings."userModes${i}" // Get user modes
                def userLocks = settings."userLocks${i}"
                def user = i as Integer // which user slot are we using, convert to integer to be sure

                //log.trace "CodeCheck $i, Name: $name, Code: $code, UserType: $userType, ExpireDate: $expDate, ExpireTime: $expTime, StartDate: $startDate, StartTime: $startTime, Present: $userPresent, Not Present: $userNotPresent, UserModes: $userModes, Locks: $userLocks"

                // Check if we have more than one lock and use has not selected this lock for programming then delete it
                if ((locks?.size() > 1) && userLocks && !userLocks?.contains(lock.id)) {
                    if (state.lockCodes[lock.id].(user as String)) {
                        deleteCode(lock, user)
                        def msg = "Requesting $lock to delete unconfigured user $user ${name ?: ""}"
                        log.debug msg
                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                            log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                            state.lockCodes[lock.id].remove(user as String)
                        }

                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                        
                        // Last thing to do since it could timeout
                        detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                        return // We are done here, exit out as we've scheduled the next update
                    } else {
                        log.debug "$lock ${name ?: ""} user $user already unconfigured"
                    }
                } else {
                    // Check code type
                    switch (userType) {
                        case 'Expire on':
                        if (code != null) {
                            def doAdd = false
                            def msg
                            if (expDate && expTime) {
                                try {
                                    // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally
                                    def exp = Date.parse("yyyy-MM-ddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                                    def expStr = exp.format("EEE MMM dd yyyy HH:mm z", timeZone)
                                    if (exp.getTime() > now()) {
                                        if (startDate && startTime) {
                                            try {
                                                def start = Date.parse("yyyy-MM-ddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone))
                                                def startStr = start.format("EEE MMM dd yyyy HH:mm z", timeZone)
                                                if (start.getTime() <= now()) {
                                                    msg = "Requesting $lock to add $name to user $user, code: $code, because it is scheduled to start at $startStr"
                                                    doAdd = true // we need to add the code
                                                    log.trace "$lock User $user $name is scheduled to start at $startStr and expire on $expStr"
                                                } else {
                                                    msg = "Requesting $lock to delete future user $user $name, start on $startStr"
                                                    log.trace "$lock user $user $name's code is set to start in future on $startStr"
                                                }
                                            } catch (Exception e) {
                                                log.error "User $user $name set to Start but does not have a valid Start Date: $startDate"
                                            }
                                        } else if (startDate && !startTime) {
                                            log.error "User $user $name set to Start but does not have a valid Start Date/Time: $startDate or Time: $startTime"
                                        } else {
                                            msg = "Requesting $lock to add $name to user $user, code: $code, it is set to expire on $expStr"
                                            doAdd = true // we need to add the code
                                            log.trace "$lock User $user $name is set to expire on $expStr"
                                        }
                                    } else {
                                        msg = "Requesting $lock to delete expired user $user $name, expired on $expStr"
                                    }
                                } catch (Exception e) {
                                    log.error "User $user $name set to Expire but does not have a valid Expiry Date: $expDate or Time: $expTime"
                                }
                            } else {
                                log.error "$lock User $user $name set to Expire but does not have a Expiration Date: $expDate or Time: $expTime"
                            }

                            if (doAdd) {
                                if (state.lockCodes[lock.id].(user as String) != code) { // Only if code has changed
                                    setCode(lock, user, code, name)
                                    log.debug msg
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                        log.info "Retry programming exceeded, assuming user was added successfully to the lock"
                                        state.lockCodes[lock.id][user as String] = code
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                } else {
                                    if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                        updateCodeName(lock, user, name)
                                    }
                                    log.debug "$lock User $user $name is already active"
                                }
                            } else {
                                if (state.lockCodes[lock.id].(user as String)) {
                                    deleteCode(lock, user)
                                    msg = msg ?: "Requesting $lock to delete user $user ${name ?: ""}"
                                    log.debug msg
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                        log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                        state.lockCodes[lock.id].remove(user as String)
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                } else {
                                    log.debug "$lock User $user $name is already deleted"
                                }
                            }
                        } else if (state.lockCodes[lock.id].(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                            deleteCode(lock, user)
                            def msg = "Requesting $lock to delete user $user ${name ?: ""}"
                            log.debug msg
                            if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                state.lockCodes[lock.id].remove(user as String)
                            }

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                            startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                            // Last thing to do since it could timeout
                            detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already deleted"
                        }
                        break

                        case 'One time':
                        if (code != null) {
                            if (state.usedOneTimeCodes[lock.id].contains(user as String)) {
                                if (!state.trackUsedOneTimeCodes.contains(user as String)) {
                                    state.trackUsedOneTimeCodes.add(user as String) // track it for reporting purposes
                                }
                                deleteCode(lock, user)
                                def msg = "Requesting $lock to delete one time user $user $name"
                                log.debug msg
                                if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                    log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                    state.lockCodes[lock.id].remove(user as String)
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                // Last thing to do since it could timeout
                                detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                return // We are done here, exit out as we've scheduled the next update
                            } else if (!state.trackUsedOneTimeCodes.contains(user as String)) { // If it's not been used add it to the lock
                                if (state.lockCodes[lock.id].(user as String) != code) { // Only if code has changed
                                    setCode(lock, user, code, name)
                                    def msg = "Requesting $lock to add one time code $name to user $user, code: $code"
                                    log.debug msg
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                        log.info "Retry programming exceeded, assuming user was added successfully to the lock"
                                        state.lockCodes[lock.id][user as String] = code
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                } else {
                                    if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                        updateCodeName(lock, user, name)
                                    }
                                    log.debug "$lock User $user $name is a one time code but it has not been used yet"
                                }
                            } else {
                                log.debug "$lock one time user $user $name is already used"
                            }
                        } else if (state.lockCodes[lock.id].(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                            deleteCode(lock, user)
                            def msg = "Requesting $lock to delete user $user ${name ?: ""}"
                            log.debug msg
                            if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                state.lockCodes[lock.id].remove(user as String)
                            }

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                            startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                            // Last thing to do since it could timeout
                            detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already deleted"
                        }
                        break

                        case 'Scheduled':
                        if (code != null) {
                            def doAdd = false
                            
                            ('A'..'C').each { schedule ->
                                if (checkSchedule(i, schedule)) { // Check if we are within operating schedule
                                    doAdd = true
                                    def msg = "Schedule $schedule active $lock to add $name to user $user, code: $code, because it is scheduled to work between ${settings."userDayOfWeek${schedule}${i}"}: ${settings."userStartTime${schedule}${i}" ? timeToday(settings."userStartTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : ""} to ${settings."userEndTime${schedule}${i}" ? timeToday(settings."userEndTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : ""}"
                                    log.trace msg
                                } else {
                                    def msg = "Schedule $schedule NOT active for $lock $name user $user, scheduled to work between ${settings."userDayOfWeek${schedule}${i}"}: ${settings."userStartTime${schedule}${i}" ? timeToday(settings."userStartTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : ""} to ${settings."userEndTime${schedule}${i}" ? timeToday(settings."userEndTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : ""}"
                                    log.trace msg
                                }
                            }
                            
                            if (doAdd) {
                                if (state.lockCodes[lock.id].(user as String) == code) { // If code hasn't changed, don't add it
                                    if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                        updateCodeName(lock, user, name)
                                    }
                                    log.debug "$lock scheduled user $user $name is already active, not adding again"
                                } else {
                                    setCode(lock, user, code, name)
                                    def msg = "Requesting $lock to add active scheduled $name to user $user, code: $code"
                                    log.debug msg
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                        log.info "Retry programming exceeded, assuming user was added successfully to the lock"
                                        state.lockCodes[lock.id][user as String] = code
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                }
                            } else { // Outside operating schedule
                                if (!state.lockCodes[lock.id].(user as String)) {
                                    log.debug "$lock scheduled user $user $name is already inactive, not removing again"
                                } else {
                                    deleteCode(lock, user)
                                    def msg = "Requesting $lock to delete inactive scheduled user $user $name"
                                    log.debug msg
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                        log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                        state.lockCodes[lock.id].remove(user as String)
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                }
                            }
                        } else if (state.lockCodes[lock.id].(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                            deleteCode(lock, user)
                            def msg = "Requesting $lock to delete user $user ${name ?: ""}"
                            log.debug msg
                            if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                state.lockCodes[lock.id].remove(user as String)
                            }

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                            startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                            // Last thing to do since it could timeout
                            detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already deleted"
                        }
                        break

                        case 'Permanent':
                        if (code != null) {
                            if (state.lockCodes[lock.id].(user as String) != code) { // Only if code has changed
                                setCode(lock, user, code, name)
                                def msg = "Requesting $lock to add permanent code $name to user $user, code: $code"
                                log.debug msg
                                if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                    log.info "Retry programming exceeded, assuming user was added successfully to the lock"
                                    state.lockCodes[lock.id][user as String] = code
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                // Last thing to do since it could timeout
                                detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                        updateCodeName(lock, user, name)
                                }
                                log.debug "$lock User $user $name is a permanent code and is already active"
                            }
                        } else if (state.lockCodes[lock.id].(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                            deleteCode(lock, user)
                            def msg = "Requesting $lock to delete user $user ${name ?: ""}"
                            log.debug msg
                            if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                state.lockCodes[lock.id].remove(user as String)
                            }

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                            startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                            // Last thing to do since it could timeout
                            detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already deleted"
                        }
                        break

                        case 'Presence':
                        if (code != null) {
                            def doAdd = false
                            
                            // Any of the 'present' users AND none of the 'not present' users are there then the code is active
                            if ((userPresent || userNotPresent) && // Atleast one condition is specified
                                (userPresent ? userPresent.any{it.currentPresence == "present"} : true) &&
                                (userNotPresent ? userNotPresent.every{it.currentPresence != "present"} : true)
                               ) {
                                doAdd = true // the code
                                def msg = "$lock user $user $name is being added because ${userPresent ? "${userPresent.findAll{it.currentPresence == "present"}} are present" : (userNotPresent ? "${userNotPresent} are not present" : "")}"
                                log.debug msg
                            } else {
                                def msg = "$lock user $user $name is being deleted because${(userPresent || userNotPresent) ? (userPresent.every{it.currentPresence != "present"} ? " ${userPresent} are not present" : (userNotPresent ? " ${userNotPresent.findAll{it.currentPresence == "present"}} are present" : "")) : " no user presence is defined"}"
                                log.debug msg
                            }
                            
                            if (doAdd) {
                                if (state.lockCodes[lock.id].(user as String) == code) { // If code hasn't changed, don't add it
                                    if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                        updateCodeName(lock, user, name)
                                    }
                                    log.debug "$lock presence user $user $name is already active, not adding again"
                                } else {
                                    setCode(lock, user, code, name)
                                    def msg = "Requesting $lock to add presence based $name to user $user, code: $code"
                                    log.debug msg
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                        log.info "Retry programming exceeded, assuming user was added successfully to the lock"
                                        state.lockCodes[lock.id][user as String] = code
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                }
                            } else { // Presence conditions not satisfied
                                if (!state.lockCodes[lock.id].(user as String)) {
                                    log.debug "$lock presence user $user $name is already inactive, not removing again"
                                } else {
                                    deleteCode(lock, user)
                                    def msg = "Requesting $lock to delete presence based user $user $name"
                                    log.debug msg
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                        log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                        state.lockCodes[lock.id].remove(user as String)
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                }
                            }
                        }
                        break
                        
                        case 'Modes':
                        if (code != null) {
                            def doAdd = false
                            
                            // Any of the selected modes are active then activate the codes
                            if (userModes?.find{it == location.mode}) {
                                doAdd = true // the code
                                def msg = "$lock user $user $name is being added because mode ${location.mode} is active"
                                log.debug msg
                                sendNotificationEvent(msg)
                            } else {
                                def msg = "$lock user $user $name is not being deleted because mode ${location.mode} is not in the selected modes"
                                log.debug msg
                                sendNotificationEvent(msg)
                            }
                            
                            if (doAdd) {
                                if (state.lockCodes[lock.id].(user as String) == code) { // If code hasn't changed, don't add it
                                    if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                        updateCodeName(lock, user, name)
                                    }
                                    log.debug "$lock mode user $user $name is already active, not adding again"
                                } else {
                                    setCode(lock, user, code, name)
                                    def msg = "Requesting $lock to add mode based $name to user $user, code: $code"
                                    log.debug msg
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                        log.info "Retry programming exceeded, assuming user was added successfully to the lock"
                                        state.lockCodes[lock.id][user as String] = code
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                }
                            } else { // Presence conditions not satisfied
                                if (!state.lockCodes[lock.id].(user as String)) {
                                    log.debug "$lock mode user $user $name is already inactive, not removing again"
                                } else {
                                    deleteCode(lock, user)
                                    def msg = "Requesting $lock to delete mode based user $user $name"
                                    log.debug msg
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                        log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                        state.lockCodes[lock.id].remove(user as String)
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                }
                            }
                        }
                        break

                        case 'Inactive':
                        if (state.lockCodes[lock.id].(user as String)) { // Delete the code is hasn't been deleted
                            deleteCode(lock, user)
                            def msg = "Requesting $lock to delete inactive user $user ${name ?: ""}"
                            log.debug msg
                            if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                state.lockCodes[lock.id].remove(user as String)
                            }

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                            startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                            // Last thing to do since it could timeout
                            detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already inactive"
                        }
                        break

                        default: // No user type selected, it's empty delete code
                            if (state.lockCodes[lock.id].(user as String)) { // Delete the code is hasn't been deleted
                                deleteCode(lock, user)
                                def msg = "Requesting $lock to delete empty user $user ${name ?: ""}"
                                log.debug msg
                                if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                                    log.info "Retry programming exceeded, assuming user was deleted successfully from the lock"
                                    state.lockCodes[lock.id].remove(user as String)
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                // Last thing to do since it could timeout
                                detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                log.debug "$lock ${name ?: ""} user $user is empty, code already deleted"
                            }
                        break
                    }
                }

                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
            }
            
            // We're done with all the programmed codes for this lock, check of see if any excess codes are left behind from a change in number of user slots and clean them up
            if (state.lockCodes[lock.id]?.any { i, code ->
                def user = i as Integer
                if (user > maxUserNames) { // This is an excess code, clean it up
                    deleteCode(lock, user)
                    def msg = "Requesting $lock to delete excess user $user ${name ?: ""}"
                    log.debug msg
                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > maxRetries) {
                        log.info "Retry programming exceeded, assuming excess user was deleted successfully from the lock"
                        state.lockCodes[lock.id].remove(user as String)
                    }

                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                    // Last thing to do since it could timeout
                    detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
                    return true// We are done here, exit out as we've scheduled the next update
                }
            }) { // If had a match then exit as we've scheduled the next iteration
                return // We're done here
            }

            state.expiredLockList.remove(lock.id) // we are done with this lock
            state.expiredNextCode = 1 // reset back to 1 for the next lock
            //log.trace "$lock id $lock.id code check complete, unprocessed locks ${state.expiredLockList}, reset next code update to $state.expiredNextCode"
        }
    }

    // All done now reset the lock list and add the locks back for next check cycle
    state.expiredNextCode = 1 // reset back to 1 for the next lock
    for (lock in locks) {
        state.expiredLockList.add(lock.id) // reset the state for each lock to be processed
        //log.trace "Added $lock id ${lock.id} back to unprocessed locks list ${state.expiredLockList}"
    }
}

// Sets the code on the lock and also updates the username
private setCode(lock, user, code, name) {
    !(lock.hasAttribute("pinLength") || lock.hasCommand("deleteAllCodes")) ? lock.setCode(user, code, name) : lock.setCode(user, code) // Keep support for older device handlers
}

// Deletes a code from the lock
private deleteCode(lock, user) {
    lock.deleteCode(user)
}

// Update the name on the lock for a user on a lock
private updateCodeName(lock, user, name) {
    if (!(lock.hasAttribute("pinLength") || lock.hasCommand("deleteAllCodes"))) { // Older devices don't have this option
        log.info "Updating user $user name to $name on lock $lock"
        lock.nameSlot(user, name)
    }
}

// Gets the name of the code on the lock
private getCodeName(lock, user) {
    def name = !(lock.hasAttribute("pinLength") || lock.hasCommand("deleteAllCodes")) ? lock.currentState("lockCodes")?.jsonValue?."$user"?.trim() : null // Older handlers don't support this
    //log.trace "Got name $name from $lock for user $user"
    return name
}

// Kick start the code check routine
def kickStart() {
    schedule("* */1 * * * ?", codeCheck) // run codeCheck every 1 minute
    codeCheck()
}

// Heartbeat system to ensure that the MonitorTask doesn't die when it's supposed to be running
def heartBeatMonitor() {
    log.trace "Heartbeat monitor called"

    state.lastHeartBeat = now() // Save the last time we were executed

    log.trace "Last code check was done " + ((now() - (state.lastCheck ?: 0))/1000) + " seconds ago"
    if (((state.lastCheck ?: 0) + (3*60*1000)) < now()) { // Kick start the motion detection monitor if didn't update for more than 3 minutes
        log.warn "Code check hasn't been run a long time, calling it to kick start it"
        kickStart()
    }
}

def startTimer(seconds, function, dataMap = null) {
    log.trace "Scheduled to run $function in $seconds seconds"

    //def runTime = new Date(now() + ((Long)seconds * 1000)) // for runOnce
    //runOnce(runTime, function, [overwrite: true]) // runIn isn't reliable, runOnce is more reliable but isn't as accurate
    if (dataMap) {
        runIn(seconds, function, [overwrite: true, data: dataMap]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
    } else {
        runIn(seconds, function, [overwrite: true]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
    }
}

// Checks if we are within the current operating scheduled
// Inputs to the function are user (i) and schedule (x) (there can be multiple schedules)
// Preferences required in user input settings are:
// settings."userStartTime${x}${i}"
// settings."userEndTime${x}${i}"
// settings."userDayOfWeek${x}${i}"
private checkSchedule(def i, def x) {
    log.trace "Checking operating schedule $x for user $i"

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone)
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK)
    def currentDT = new Date(now())

    // some debugging in order to make sure things are working correclty
    log.trace "Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Check if we are within operating times
    if (settings."userStartTime${x}${i}" != null && settings."userEndTime${x}${i}" != null) {
        def scheduledStart = timeToday(settings."userStartTime${x}${i}", timeZone)
        def scheduledEnd = timeToday(settings."userEndTime${x}${i}", timeZone)

        if (scheduledEnd <= scheduledStart) { // End time is next day
            def localHour = currentDT.getHours() + (int)(timeZone.getOffset(currentDT.getTime()) / 1000 / 60 / 60)
            //log.trace "Local hour is $localHour"
            if (( localHour >= 0) && (localHour < 12)) // If we between midnight and midday
            {
                log.trace "End time is before start time and we are past midnight, assuming start time is previous day"
                scheduledStart = scheduledStart.previous() // Get the start time for yesterday
            } else {
                log.trace "End time is before start time and we are past midday, assuming end time is the next day"
                scheduledEnd = scheduledEnd.next() // Get the end time for tomorrow
            }
        }

        log.trace "Operating Start ${scheduledStart.format("HH:mm z", timeZone)}, End ${scheduledEnd.format("HH:mm z", timeZone)}"

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            log.debug "Outside operating time schedule"
            return false
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.trace "Operating DOW(s): ${settings."userDayOfWeek${x}${i}"}"

    if(!settings."userDayOfWeek${x}${i}") {
        log.debug "Day of week not specified for operating schedule $x for user $i"
        return false
    } else if(settings."userDayOfWeek${x}${i}".contains('All Week')) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Monday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Tuesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Wednesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Thursday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Friday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Saturday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Sunday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }

    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
        log.debug("Within operating schedule")
        return true
    }
    else {
        log.debug("Outside operating schedule")
        return false
    }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private void sendNotifications(message, user = "") {
	if (!message) {
		return
    }
    
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, settings."recipients${user}")
    } else {
        if (!settings."disableAllNotify${user}") {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (settings."sms${user}") {
            sendText(settings."sms${user}", message)
        }
    }
    if (settings."audioDevices${user}") {
        settings."audioDevices${user}"*.playText(message)
    }
}

// Temporarily override the user settings
private updateSetting(name, value) {
    app.updateSetting(name, value) // For SmartApps UI
    settings[name] = value // For Device Handlers and SmartApps
}

private deleteSetting(name) {
    //app.deleteSetting(name) // For SmartApps delete it, TODO: Gives and error
    //settings.remove(name) // For Device Handlers
    clearSetting(name) // For SmartApps
}

private clearSetting(name) {
    app.updateSetting(name, '') // For SmartApps 
    settings[name] = '' // For Device Handlers and SmartApps
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Lock Multi User Code Management"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def devices = locks?.findAll { it.hasAttribute("codeVersion") }
                for (device in devices) {
                    if (device) {
                        def deviceName = device?.currentValue("dhName")
                        def deviceVersion = ret.data?."$deviceName"
                        if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                            def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                            log.info msg
                            if (!disableUpdateNotifications) {
                                sendPush(msg)
                            }
                        } else {
                            log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}

// THIS IS THE END OF THE FILE