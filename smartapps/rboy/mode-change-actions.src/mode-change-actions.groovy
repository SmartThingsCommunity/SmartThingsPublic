/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() { return "01.10.00" }

/**
 * Mode Based Actions - Notify if any doors/windows/switches/lock/values/shades are open or closed on when a routine changes the mode and take actions
 *
 * Copyright RBoy Apps, redistribution of code is not allowed without permission
 *
 * 2020-09-28 - (v01.10.00) Added support for WiFi Garage door controllers
 * 2020-01-20 - (v01.09.02) Update icons for broken ST Android app 2.18
 * 2019-10-11 - (v01.09.01) Add support for the new Sonos integration (auto detect)
 * 2019-05-01 - (v01.09.00) Added option to partially open/close shades (where supported)
 * 2019-04-09 - (v01.08.02) Add windows to message for doors
 * 2018-12-11 - (v01.08.01) Fix for saved (dynamic) settings not showing due to change in ST app behavior
 * 2018-09-26 - (v01.08.00) Added support for announcing messages over a TTS device
 * 2018-07-27 - (v01.07.05) Consolidate messages to the end to avoid a timeout
 * 2017-08-01 - (v01.07.04) Consolidate messages to reduce number of messages to one per group
 * 2017-06-15 - (v01.07.03) Update for ST firmware bug for valves
 * 2017-05-26 - (v01.07.02) Update to ST platform, now separate multiple SMS numbers with a *
 * 2017-05-10 - (v01.07.01) Minor fix to text layout
 * 2017-05-08 - (v01.07.00) Added ability to check for closed windows/doors/garge doors/locks when mode is changed, fixed bug with closing garage doors and ability for window shades and water valves
 * 2016-11-05 - Added ability to check for new app and device versions, fixed an issue withe mode based notifications
 * 2016-09-16 - Added support to check for switches left off which should be on
 * 2016-09-16 - Patch for broken HREF in ST app 2.2.0
 * 2016-08-17 - Added workaround for ST contact address book bug
 * 2016-07-30 - Added support for delayed actions
 * 2016-07-30 - Added support for contact address books notifications
 * 2016-06-06 - Fix for Android phones HREF bug
 * 2016-06-03 - Fixed list of items to be checked shown on first page
 * 2016-06-03 - Added support to notify if any garage doors are left open and option to close them
 * 2016-06-03 - Added support to notify if any doors are left unlocked and option to lock them
 * 2016-06-02 - Added support to notify if any switches are left on and option to turn them off
 * 2016-06-01 - Initial release
*/
definition(
    name: "Mode Change Actions",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Notify if there are any doors/window/switches that are open/unlocked and closes/locks them when a mode changes. E.g. when leaving the house the mode changes to away it will notify the user if any doors are left open.",
    category: "Safety & Security",
    iconUrl: "https://www.rboyapps.com/images/OpenDoor.png",
    iconX2Url: "https://www.rboyapps.com/images/OpenDoor.png",
    iconX3Url: "https://www.rboyapps.com/images/OpenDoor.png")

preferences {
    page(name: "loginPage")
    page(name: "loginPage2")
    page(name: "setupApp")
    page(name: "modeDoorMonitorPage")
}

def loginPage() {
    log.trace "Login page"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage", "loginPage2")
    }
}

def loginPage2() {
    log.trace "Login page2"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage2", "loginPage")
    }
}

private loginSection(name, nextPage) {
    dynamicPage(name: name, title: "Mode Change Actions v${clientVersion()}", install: state.loginSuccess, uninstall: true, nextPage: state.loginSuccess ? "" : nextPage) {
        section() {
            if (state.loginError) {
                log.warn "Authenticating failed: ${state.loginError}"
                paragraph title: "Login failed", image: "https://www.rboyapps.com/images/RBoyApps.png", required: true, "${state.loginError}"
            } else {
                log.debug "Check authentication credentials, Login: $username"
                paragraph title: "Login", image: "https://www.rboyapps.com/images/RBoyApps.png", required: false, "Enter your RBoy Apps username\nYou can retrieve your username from www.rboyapps.com lost password page"
            }

            input name: "username", type: "text", title: "Username", capitalization: "none", submitOnChange: false, required: false
        }
    }
}

def setupApp() {
    dynamicPage(name: "setupApp", title: "Mode Change Actions v${clientVersion()}", install: true, uninstall: true) {
        section() {
            paragraph "Click on each Mode below to configure notification options and actions for doors/windows/switches/locks/valves/shades. When the hub changes to the selected mode and if any of the selected doors/windows/switches/locks/valves/shades are found open/closed/locked/unlocked, this app will notify you and take actions."
        }

        def modes = location.modes
        if (modes) {
            for (mode in modes) {
                section {
                    // Unlock actions for each mode
                    def hrefParams = [
                        mode: mode as String, 
                        passed: true 
                    ]
                    log.trace "HREF Mode $mode"
                    href(name: "modeDoorMonitor", params: hrefParams, title: "When switching to mode ${mode}", page: "modeDoorMonitorPage", description: getCheckingDescription(mode), required: false)
                }
            }
            
            section("Delay Actions and Notifications") {
                paragraph "Enable this option to allow the routines to complete their actions after a mode change before checking for any open doors/windows/switches. It waits for about a minute or two before checking"
                input name: "delayAction", title: "Delay checking", type: "bool", required: false
            }
        } else {
            section("Error initializing SmartApp") {
                paragraph "No modes found on the Hub! Contact ST support"
            }
        }

        section("General Notification Options") {
            input("recipients", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                input name: "notify", title: "Send push notifications", type: "bool", defaultValue: true, required: false
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*+18747654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
            }
            input "audioDevices", "capability.audioNotification", title: "Speak notifications on", required: false, multiple: true, submitOnChange: true, image: "https://www.rboyapps.com/images/Horn.png"
            if (audioDevices) {
                input "audioVolume", "number", title: "...at this volume level (optional)", description: "keep current", required: false, range: "1..100"
            }
        }

        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "updateNotifications", title: "Check for new versions of the app", type: "bool", defaultValue: true, required: false
        }
        section("Confidential", hideable: true, hidden: true) {
            paragraph("RBoy Apps Username: " + (username?.toLowerCase() ?: "Unlicensed") + (state.loginSuccess ? "" : ", contact suppport"))
        }
    }
}

private getCheckingDescription(mode) {
    def description = ""

    def devices = [
        			settings."doors${mode}",
        			settings."doorsflip${mode}",
        			settings."garagedoors${mode}",
                   	settings."garagedoorsflip${mode}",
        			settings."locks${mode}",
               	    settings."locksflip${mode}",
               	    settings."switches${mode}",
               	    settings."switchesflip${mode}",
               	    settings."shades${mode}",
               	    settings."shadesflip${mode}",
                   	settings."valves${mode}",
        			settings."valvesflip${mode}",
    			]
    
    for (device in devices) {                   
        description += device ? (description ? "\n  " : "") + device?.join("\n  ") : ""
    }

    if (!description) { // Nothing selected
        description = "No doors/windows selected"
    } else {
        description = "Check:\n  " + description // Add the header
    }

    return description
}

def modeDoorMonitorPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def mode = ""
    // Get mode from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.mode) {
        mode = params.mode
        log.trace "Passed from main page, using params lookup for mode $mode"
    } else if (atomicState.params) {
        mode = atomicState.params.mode ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for mode $mode"
    } else {
        log.error "Invalid params, no mode found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Mode Door Monitor, mode:$mode, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"modeDoorMonitorPage", title: "Configure notification options when changing to Mode " + (mode ?: ""), uninstall: false, install: false) {
        section("Choose Door(s) and Window(s)") {
            paragraph "Notify if any of these doors or windows are left open/closed when the hub changes to $mode mode"
            input "doors${mode}", "capability.contactSensor", title: "Check for Open doors/windows", required: false, multiple:true
            input "doorsflip${mode}", "capability.contactSensor", title: "Check for Closed doors/windows", required: false, multiple:true
        }

        section("Choose Garage Door(s)") {
            paragraph "Notify if any of these selected garage doors are left open/closed when the hub changes to $mode mode"
            input "garagedoors${mode}", "capability.doorControl", title: "Check for Open garage doors", required: false, multiple:true, submitOnChange: true
            if (settings."garagedoors${mode}") {
                input "garagedoorsoff${mode}", "bool", title: "...close them", required: false
            }
            input "garagedoorsflip${mode}", "capability.doorControl", title: "Check for Closed garage doors", required: false, multiple:true, submitOnChange: true
            if (settings."garagedoorsflip${mode}") {
                input "garagedoorsopen${mode}", "bool", title: "...open them", required: false
            }
        }

        section("Choose Lock(s)") {
            paragraph "Notify if any of these selected locks are Unlocked/Locked when the hub changes to $mode mode"
            input "locks${mode}", "capability.lock", title: "Check for Unlocked locks", required: false, multiple:true, submitOnChange: true
            if (settings."locks${mode}") {
                input "locksoff${mode}", "bool", title: "...lock them", required: false
            }
            input "locksflip${mode}", "capability.lock", title: "Check for Locked locks", required: false, multiple:true, submitOnChange: true
            if (settings."locksflip${mode}") {
                input "locksopen${mode}", "bool", title: "...unlock them", required: false
            }
        }

        section("Choose Switch(s)") {
            paragraph "Notify if any of these selected switches are On/Off when the hub changes to $mode mode"
            input "switches${mode}", "capability.switch", title: "Check for switches left On", required: false, multiple:true, submitOnChange: true
            if (settings."switches${mode}") {
                input "switchesoff${mode}", "bool", title: "...turn them off", required: false
            }
            input "switchesflip${mode}", "capability.switch", title: "Check for switches left Off", required: false, multiple:true, submitOnChange: true
            if (settings."switchesflip${mode}") {
                input "switcheson${mode}", "bool", title: "...turn them on", required: false
            }
        }

        section("Choose Windows Shade/Blind(s)") {
            paragraph "Notify if any of these selected window shades/blinds are Open/Closed when the hub changes to $mode mode"
            input "shades${mode}", "capability.windowShade", title: "Check for shades left Open", required: false, multiple:true, submitOnChange: true
            if (settings."shades${mode}") {
                input "shadesoff${mode}", "bool", title: "...close them", required: false, submitOnChange: true
                if (settings."shadesoff${mode}") {
                    input "shadesofflevel${mode}", "number", title: "...partial close (%)", description: "optional (1-99)", range: "1..99", required: false
                }
            }
            input "shadesflip${mode}", "capability.windowShade", title: "Check for shades left Closed", required: false, multiple:true, submitOnChange: true
            if (settings."shadesflip${mode}") {
                input "shadeson${mode}", "bool", title: "...open them", required: false, submitOnChange: true
                if (settings."shadeson${mode}") {
                    input "shadesonlevel${mode}", "number", title: "...partial open (%)", description: "optional (1-99)", range: "1..99", required: false
                }
            }
        }

        section("Choose Valve(s)") {
            paragraph "Notify if any of these selected valves are Open/Closed when the hub changes to $mode mode"
            input "valves${mode}", "capability.valve", title: "Check for valves left Open", required: false, multiple:true, submitOnChange: true
            if (settings."valves${mode}") {
                input "valvesoff${mode}", "bool", title: "...close them", required: false
            }
            input "valvesflip${mode}", "capability.valve", title: "Check for valves left Closed", required: false, multiple:true, submitOnChange: true
            if (settings."valvesflip${mode}") {
                input "valveson${mode}", "bool", title: "...open them", required: false
            }
        }

        section("Mode Specific Notification Options") {
            paragraph "Enabling mode specific notifications will override over any general notifications defined on the first page"
            input "modeOverrideNotifications${mode}", "bool", title: "Enable $mode mode specific notifications", required: false,  submitOnChange: true
            if (settings."modeOverrideNotifications${mode}") {
                input("recipients${mode}", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                    input "notify${mode}", "bool", title: "Send push notifications", defaultValue: true, required: false
                    paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*4447654321"
                    input "sms${mode}", "phone", title: "Send SMS notification to (optional):", required: false
                }
                input "audioDevices${mode}", "capability.audioNotification", title: "Speak notifications on", required: false, multiple: true, image: "https://www.rboyapps.com/images/Horn.png"
            }
        }
    }
}

def installed()
{
    log.debug "Installed"

    subscribeToEvents()
}

def updated()
{
    log.debug "Updated"

    unsubscribe()
    unschedule()
    subscribeToEvents()
}

def subscribeToEvents() {
    log.trace settings

    state.queuedActions = [] // initialize it
    
    log.trace "Scheduling heartbeat for every 1 minute"
    schedule("* */1 * * * ?", heartBeat) // Schedule the heartbeat

    subscribe(location, "mode", modeChangeHandler)

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("* 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
}

def heartBeat() {
	log.trace "Heartbeat called, pending actions: $state.queuedActions"
    def unprocessedActions = []
    def actions = []
    
    synchronized(state) {
        if (state.queuedActions == null) { // Initialize it if it doesn't exist
            log.debug "Initializing queued Actions"
            state.queuedActions = [] // initialize it
        }

        actions = state.queuedActions.clone() // make a copy instead of working on original
        //log.warn "BEFORE CLEAR:$state.queuedActions"
        state.queuedActions.clear() // Clear it
        //log.warn "AFTER CLEAR:$state.queuedActions"
        //log.warn "EXECUTE:$actions"
    }

    for (action in actions) {
        //log.trace "Processing:$action"
        def now = now()
        if (now >= action.time) {
            log.trace "Checking state of doors/windows"
            modeChangeHandler()
        } else {
            unprocessedActions.add(action)
            log.trace "Waiting ${(((action.time - now) as Float)/1000).round()} seconds to process deferred action ${action}"
        }
    }

    if (unprocessedActions) { // If anything is pending
        log.trace "Adding unprocessed actions back to queue: $unprocessedActions"
        // Synchronize these lists otherwise we have a race condition
        synchronized(state) {
            state.queuedActions = state.queuedActions + unprocessedActions // Add back any pending actions (since we are adding an array of maps, use + and not << or .add())
            //log.warn "END:$state.queuedActions"
        }
    }
    
    log.trace "Heartbeat actions finished, pending actions: $state.queuedActions"
}

def modeChangeHandler(evt) {
    log.debug "Mode change notification, ${evt ? "name: ${evt.name}, value: ${evt.value}" : "delayed checking"}"

    // Check if we need a delayed actions
    if (evt && delayAction) {
        log.trace "Delaying checking by 1 minute"
        
        // Synchronize these lists otherwise we have a race condition
        synchronized(state) {
            if (state.queuedActions == null) { // Initialize it if it doesn't exist
                log.debug "Initializing queued Actions"
                state.queuedActions = [] // initialize it
            }

            //state.queuedActions.clear() // DEBUG CLEAR
            //log.warn "QUEUED ACTIONS: $state.queuedActions" // DEBUG

            state.queuedActions = [[time:(now() + (1 * 60 * 1000) as Long)]] // Delay checking by 1 minute (don't add map to the array only keep 1 map in the array, check for latest mode change)

            //state.queuedActions.clear() // DEBUG CLEAR
            log.trace "Queued actions: $state.queuedActions" // DEBUG
        }
        
        return
    }

    def mode = location.mode // This should the new mode
    def msgs = []

    // Check for open doors/windows left open
    if (settings."doors${mode}") {
        def message = ""
        for (door in settings."doors${mode}") {
            if (door.currentValue("contact") == "open") {
                message += ", $door"
            } else {
                log.debug "$door is currently Closed"
            }
        }

        if(message) {
            message = "These doors/windows were Open when hub was changed to $mode mode" + message
            log.info message
            msgs << message
        }
    } else {
        log.trace "No doors/windows found to check for open when hub changed to $mode mode"
    }    

    // Check for open doors/windows left closed
    if (settings."doorsflip${mode}") {
        def message = ""
        for (door in settings."doorsflip${mode}") {
            if (door.currentValue("contact") == "closed") {
                message += ", $door"
            } else {
                log.debug "$door is currently Open"
            }
        }

        if(message) {
            message = "These doors/windows were Closed when hub was changed to $mode mode" + message
            log.info message
            msgs << message
        }
    } else {
        log.trace "No doors/windows found to check for closed when hub changed to $mode mode"
    }    

    // Check for switches left on
    if (settings."switches${mode}") {
        def message = ""
        for (switchs in settings."switches${mode}") {
            if (switchs.currentValue("switch") == "on") {
                message += ", $switchs"
                if (settings."switchesoff${mode}") {
                    switchs.off()
                }
            } else {
                log.debug "$switchs is currently Off"
            }
        }

        if(message) {
            if (settings."switchesoff${mode}") {
                message = "These switches were On when hub was changed to $mode mode, turning them Off" + message
            } else {
                message = "These switches were On when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No switches found to check for on when hub changed to $mode mode"
    }    

    // Check for switches left off
    if (settings."switchesflip${mode}") {
        def message = ""
        for (switchs in settings."switchesflip${mode}") {
            if (switchs.currentValue("switch") == "off") {
                message += ", $switchs"
                if (settings."switcheson${mode}") {
                    switchs.on()
                }
            } else {
                log.debug "$switchs is currently On"
            }
        }

        if(message) {
            if (settings."switcheson${mode}") {
                message = "These switches were Off when hub was changed to $mode mode, turning them On" + message
            } else {
                message = "These switches were Off when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No switches found to check for off when hub changed to $mode mode"
    }    

    // Check for locks left unlocked
    if (settings."locks${mode}") {
        def message = ""
        for (lock in settings."locks${mode}") {
            if (lock.currentValue("lock") == "unlocked") {
                message += ", $lock"
                if (settings."locksoff${mode}") {
                    lock.lock()
                }
            } else {
                log.debug "$lock is currently Locked"
            }
        }

        if(message) {
            if (settings."locksoff${mode}") {
                message = "These locks were Unlocked when hub was changed to $mode mode, Locking them" + message
            } else {
                message = "These locks were Unlocked when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No locks found to check for unlocked when hub changed to $mode mode"
    }    

    // Check for locks left locked
    if (settings."locksflip${mode}") {
        def message = ""
        for (lock in settings."locksflip${mode}") {
            if (lock.currentValue("lock") == "locked") {
                message += ", $lock"
                if (settings."locksopen${mode}") {
                    lock.unlock()
                }
            } else {
                log.debug "$lock is currently Unlocked"
            }
        }

        if(message) {
            if (settings."locksopen${mode}") {
                message = "These locks were Locked when hub was changed to $mode mode, Unlocking them" + message
            } else {
                message = "These locks were Locked when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No locks found to check for locked when hub changed to $mode mode"
    }    

    // Check for garage doors left open
    if (settings."garagedoors${mode}") {
        def message = ""
        for (garagedoor in settings."garagedoors${mode}") {
            if (garagedoor.currentValue("door") != "closed") {
                message += ", $garagedoor"
                if (settings."garagedoorsoff${mode}") {
                    garagedoor.close()
                }
            } else {
                log.debug "$garagedoor is currently Closed"
            }
        }

        if(message) {
            if (settings."garagedoorsoff${mode}") {
                message = "These doors were Open when hub was changed to $mode mode, Closing them" + message
            } else {
                message = "These doors were Open when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No garage doors found to check for open when hub changed to $mode mode"
    }    

    // Check for garage doors left closed
    if (settings."garagedoorsflip${mode}") {
        def message = ""
        for (garagedoor in settings."garagedoorsflip${mode}") {
            if (garagedoor.currentValue("door") != "open") {
                message += ", $garagedoor"
                if (settings."garagedoorsopen${mode}") {
                    garagedoor.open()
                }
            } else {
                log.debug "$garagedoor is currently Open"
            }
        }

        if(message) {
            if (settings."garagedoorsopen${mode}") {
                message = "These doors were Closed when hub was changed to $mode mode, Opening them" + message
            } else {
                message = "These doors were Closed when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No garage doors found to check for closed when hub changed to $mode mode"
    }    

    // Check for shades left open
    if (settings."shades${mode}") {
        def message = ""
        for (shade in settings."shades${mode}") {
            if (shade.currentValue("windowShade") != "closed") {
                message += ", $shade"
                if (settings."shadesoff${mode}") {
                    if (settings."shadesofflevel${mode}") {
                        try { // Not all DTH's implement this
                            shade.setLevel(settings."shadesofflevel${mode}")
                        } catch (e) {
                            log.error "$shade does not support partial controls: $e"
                            shade.close() // Just do a regular close
                        }
                    } else {
                        shade.close()
                    }
                }
            } else {
                log.debug "$shade is currently Closed"
            }
        }

        if(message) {
            if (settings."shadesoff${mode}") {
                message = "These shades were Open when hub was changed to $mode mode, Closing them" + message
            } else {
                message = "These shades were Open when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No window shades found to check for open when hub changed to $mode mode"
    }    

    // Check for window shades left closed
    if (settings."shadesflip${mode}") {
        def message = ""
        for (shade in settings."shadesflip${mode}") {
            if (shade.currentValue("windowShade") != "open") {
                message += ", $shade"
                if (settings."shadeson${mode}") {
                    if (settings."shadesonlevel${mode}") {
                        try { // Not all DTH's implement this
                            shade.setLevel(settings."shadesonlevel${mode}")
                        } catch (e) {
                            log.error "$shade does not support partial controls: $e"
                            shade.open() // Just do a regular open
                        }
                    } else {
                        shade.open()
                    }
                }
            } else {
                log.debug "$shade is currently Open"
            }
        }

        if(message) {
            if (settings."shadeson${mode}") {
                message = "These shades were Closed when hub was changed to $mode mode, Opening them" + message
            } else {
                message = "These shades were Closed when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No window shades found to check for closed when hub changed to $mode mode"
    }    

    // Check for valves left open
    if (settings."valves${mode}") {
        def message = ""
        for (valve in settings."valves${mode}") {
            if (valve.currentValue("valve") == "open" || valve.currentValue("contact") == "open") { // ST doesn't use valve due to firmware bug - https://community.smartthings.com/t/documentation-error-for-valve-or-platform-bug/88037/19
                message += ", $valve"
                if (settings."valvesoff${mode}") {
                    valve.close()
                }
            } else {
                log.debug "$valve is currently Closed"
            }
        }

        if(message) {
            if (settings."valvesoff${mode}") {
                message = "These valves were Open when hub was changed to $mode mode, Closing them" + message
            } else {
                message = "These valves were Open when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No valves found to check for open when hub changed to $mode mode"
    }    

    // Check for valves left closed
    if (settings."valvesflip${mode}") {
        def message = ""
        for (valve in settings."valvesflip${mode}") {
            if (valve.currentValue("valve") == "closed" || valve.currentValue("contact") == "closed") { // ST doesn't use valve firmware bug - https://community.smartthings.com/t/documentation-error-for-valve-or-platform-bug/88037/19
                message += ", $valve"
                if (settings."valveson${mode}") {
                    valve.open()
                }
            } else {
                log.debug "$valve is currently Open"
            }
        }

        if(message) {
            if (settings."valveson${mode}") {
                message = "These valves were Closed when hub was changed to $mode mode, Opening them" + message
            } else {
                message = "These valves were Closed when hub was changed to $mode mode" + message
            }
            log.info message
            msgs << message
        }
    } else {
        log.trace "No valves found to check for closed when hub changed to $mode mode"
    }
    
    // Last this to do is send messages since these can time out
    log.trace "Sending messages"

    for (message in msgs) {
        if (settings."modeOverrideNotifications${mode}") {
            log.trace "Using mode specific notifications"
            sendMessages(mode, message)
        } else {
            log.trace "Using general notifications"
            sendMessages(null, message)
        }
    }
}

private sendText(number, message) {
    if (number) {
        def phones = number.replaceAll("[;,#]", "*").split("\\*") // Some users accidentally use ;,# instead of * and ST can't handle *,#+ in the number except for + at the beginning
        for (phone in phones) {
            try {
                sendSms(phone, message)
            } catch (Exception e) {
                sendPush "Invalid phone number $phone"
            }
        }
    }
}

private sendMessages(mode, message) {
    if (mode) {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, settings."recipients${mode}")
        } else {
            if (settings."notify${mode}") {
                sendPush message
            }

            if (settings."sms${mode}") {
                sendText(settings."sms${mode}", message)
            }
        }
        
        settings."audioDevices${mode}"?.each { audioDevice -> // Play audio notifications
            if (audioDevice.hasCommand("playText")) { // Check if it supports TTS
                if (audioVolume) { // Only set volume if defined as it also resumes playback
                    audioDevice.playTextAndResume(message, audioVolume)
                } else {
                    audioDevice.playText(message)
                }
            } else {
                if (audioVolume) { // Only set volume if defined as it also resumes playback
                    audioDevice.playTrackAndResume(textToSpeech(message)?.uri, audioVolume) // No translations at this time
                } else {
                    audioDevice.playTrack(textToSpeech(message)?.uri) // No translations at this time
                }
            }
        }
    } else {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, recipients)
        } else {
            if (notify) {
                sendPush message
            }

            if (sms) {
                sendText(sms, message)
            }
        }

        settings."audioDevices"?.each { audioDevice -> // Play audio notifications
            if (audioDevice.hasCommand("playText")) { // Check if it supports TTS
                if (audioVolume) { // Only set volume if defined as it also resumes playback
                    audioDevice.playTextAndResume(message, audioVolume)
                } else {
                    audioDevice.playText(message)
                }
            } else {
                if (audioVolume) { // Only set volume if defined as it also resumes playback
                    audioDevice.playTrackAndResume(textToSpeech(message)?.uri, audioVolume) // No translations at this time
                } else {
                    audioDevice.playTrack(textToSpeech(message)?.uri) // No translations at this time
                }
            }
        }
    }
}

private loginCheck() {
    log.trace "Login check"
	
    authUpdate("check") { resp ->
        if (resp?.status == 401) { // Invalid username
            state.loginError = "Invalid username" // No response from website - we should not be here
            state.loginSuccess = false
        } else if ((resp?.status == 200) && resp?.data) {
            def ret = resp.data
            if (ret?.Authenticated) {
                state.loginError = ""
                state.loginSuccess = true
            } else {
                state.loginError = ret?.Error
                state.loginSuccess = false
            }
        } else {
            state.loginError = "Unable to authenticate license, please try again later" // No response from website - we should not be here
            state.loginSuccess = false
        }
    }
}

private authUpdate(String action, Closure closure = null) {
    if (!username) {
    	return
    }
    
    def params = [
        uri: "https://auth.rboyapps.com/v1/license",
        headers: [
            Authorization: "Basic ${"${username?.trim()?.toLowerCase()}:${username?.trim()?.toLowerCase()}".getBytes().encodeBase64()}",
        ],
        body: [
            AppId: app.id,
            Timestamp: new Date(now()).format("yyyy-MM-dd'T'HH:mm:ssXXX", location.timeZone ?: TimeZone.getDefault()), // ISO_8601
            State: action,
            Username: username?.trim()?.toLowerCase(),
            LocationId: location.id,
            LocationName: location.name,
            AccountId: app.accountId,
            AppName: "Mode Change Actions",
            AppInstallName: app.label,
            AppVersion: clientVersion(),
        ]
    ]
    
    log.trace "Calling AuthUpdate\n${params}"

    try {
        httpPostJson(params) { resp ->
            /*resp?.headers.each {
                log.trace "${it.name} : ${it.value}"
            }
            log.trace "response contentType: ${resp?.contentType}"*/
            log.debug "response data: ${resp?.data}"
            if (closure) {
                closure(resp)
            }
        }
    } catch (e) {
        //log.error "Auth response:\n${e.response?.data}\n\n${e.response?.allHeaders}\n\n${e.response?.status}\n\n${e.response?.statusLine}\n\n$e"
        if ("${e}"?.contains("HttpResponseException")) { // If it's a HTTP error with non 200 status
            log.warn "Auth status: ${e?.response?.status}, response: ${e?.response?.statusLine}"
            if (closure) {
                closure(e?.response)
            }
        } else { // Some other error
            log.error "Auth error: $e"
            if (closure) {
                closure(null)
            }
        }
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Open Door/Window/Switch/Lock Notification and Action on Mode Change"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (updateNotifications != false) { // The default true may not be registered
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = []
                for (mode in location.modes) {
                    caps.add(settings."doors${mode}")
                    caps.add(settings."doorsflip${mode}")
                    caps.add(settings."garagedoors${mode}")
                    caps.add(settings."garagedoorsflip${mode}")
                    caps.add(settings."locks${mode}")
                    caps.add(settings."locksflip${mode}")
                    caps.add(settings."switches${mode}")
                    caps.add(settings."switchesflip${mode}")
                    caps.add(settings."shades${mode}")
                    caps.add(settings."shadesflip${mode}")
                    caps.add(settings."valves${mode}")
                    caps.add(settings."valvesflip${mode}")
                }
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device handler for ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (updateNotifications != false) { // The default true may not be registered
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}


// THIS IS THE END OF THE FILE