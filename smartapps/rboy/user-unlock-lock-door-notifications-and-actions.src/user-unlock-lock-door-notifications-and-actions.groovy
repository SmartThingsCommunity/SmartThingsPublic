/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed to share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "04.05.02"
}

/**
* User Door Unlock/Lock Notifications and Actions. Mirror of Multi User Lock Code Mgmt without the code programming, reuse existing lock programming
*
* Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
*
* Change Log:
* 2018-12-13 - (v04.05.02) Improve reinitialization after new version detected (requires app to be opened and saved to initiate changes)
* 2018-12-04 - (v04.05.01) Improve UI layout, separate page for notifications
* 2018-11-26 - (v04.05.00) Sync up actions with baseline 07.08.00
* 2018-09-11 - (v04.04.02) Sync up actions with baseline 07.07.06
* 2018-08-20 - (v04.04.01) Improve text for automatic relock
* 2018-08-01 - (v04.04.00) Added support for Arming/disarming ADT and resume playing the audio after notifications
* 2018-06-27 - (v04.03.00) Added support for custom user notifications settings, limiting number of notifications and keypads
* 2018-05-31 - (v04.02.04) Correct RFID case to capitals
* 2018-05-11 - (v04.02.03) Update for platform not saving sms settings for individual users, fixed arming to Arm Stay
* 2018-02-21 - (v04.02.01) Added support to arm SHM to Home when locking via keypad
* 2018-02-14 - (v04.02.00) Improved user configuration experience
* 2018-02-05 - (v04.01.00) Added support for locking/unlocking locks and opening/closing garage doors for lock/unlock actions. Added support to change modes for lock actions. Door sensor is now optional for relocking with timeout
* 2018-02-01 - (v04.00.04) Fix for ST breaking selection of Chime devices with mobile app 2.4.13
* 2018-01-21 - (v04.00.03) Added support for older device handlers to avoid a failure if users forgot to update the device handler
* 2018-01-17 - (v04.00.02) Added support for maxCodes, fix for ST Mobile app changes
* 2017-12-15 - (v04.00.01) Fix for manual unlock notifications not being sent
* 2017-12-04 - (v04.00.00) Added support for stock handler using lock codes, added support for manual lock and unlock actions
* 2017-11-14 - (v04.00.00) Added support for new ST stock DTH, improved code deletion confirmations
* 2017-11-08 - (v03.07.00) Added support for delayed lock actions and added support to arm SHM on lock and added icons and simplified the UI
* 2017-10-18 - (v03.06.00) Added check for disabling hardware autolock to use smartapp autorelock and autounlock features, fixed bug with notify modes, simplified UI
* 2017-05-31 - (v03.05.00) Improved deadbolt automatic unlocking for Schlage locks, added support for playing back on audio systems, added support for bluetooth
* 2017-05-29 - (v03.04.03) Bugfix for unlocking and locking without codes throwing an error
* 2017-05-26 - (v03.04.02) Due to ST phone changes, now separate multiple SMS numbers with a *
* 2017-04-19 - (v03.04.01) Patch for reporting Master Codes
* 2017-04-11 - (v03.04.00) Added ability to select Chimes for when doors are opened and closed, improved user interface/text, added user presence based notifications
* 2017-04-11 - (v03.03.01) Fixed grammar for messages
* 2017-01-25 - (v3.3.0) Added ability to run lock/unlock actions on when the specified users aren't present or not in specific modes, also less verbose messages unless detailed notifications are enabled while running lock and unlock actions
* 2017-01-12 - (v3.2.2) Added ability to report and run actions on unknown users (some locks don't report use code when unlocking via keypad) and master codes
* 2016-11-14 - Improved code update checks and now use ; instead of + for separating multiple SMS numbers
* 2016-10-30 - Fixed an issue with notifications not working and added code update notifications
* 2016-09-26 - Fix for broken ST phrases returning null data
* 2016-09-17 - Fixed issue with cannot change notify settings, highlight error messages, improved invalid date checks, code clean up
* 2016-09-16 - Fix for actions page not showing up when there are no routines defined on the hub
* 2016-09-16 - Patch for broken HREF pages in ST app 2.2.0
* 2016-09-13 - Bug fix when mode changes and no sensor is defined for door
* 2016-09-07 - Auto locks and open door notifications will engage if requried when mode changes
* 2016-09-02 - Added ability to specify modes of operations for auto door lock
* 2016-08-30 - Fixed bug with disable all push notifications, it should not disable text notifications and should only work when there is no contact address book
* 2016-08-17 - Added workaround for ST contact address book bug
* 2016-08-06 - Added support to auto relock door if the door hasn't been opened after specified timeout
* 2016-08-05 - Fix for autoRelock and openDoor notifications errors when using large timeout values
* 2016-07-25 - Added support for working with RFID cards
* 2016-07-22 - Added support for contact address book for customers who have this feature enabled
* 2016-07-19 - Updated code to use harmonized universal DH with type event instead of outsideLockEvent
* 2016-07-17 - Improvement to the unlocking and relocking logic
* 2016-07-17 - Workaround for platform calling installed and updated when installing the SmartApp
* 2016-07-17 - Put in a check to not enable automatic unlock if autolock in the door is enabled
* 2016-07-14 - Improved notifications
* 2016-07-13 - Added support for tamper events and when using user codes to lock the door from the keypad
* 2016-07-10 - Added support for running routine when the door is locked using external keypad lock button
* 2016-07-05 - Added support for notifications if door is left open, added support for delayed relock for multiple door and various minor UI improvements
* 2016-07-05 - Added client version on main page
* 2016-04-08 - Added support for notification modes for unlocking (and improved UI)
* 2016-04-08 - Bugfix for jammed and manual lock notifications not coming
* 2016-02-20 - Added slot notification for unknown users 
* 2016-02-07 - Revamped from scratch
*
*/
definition(
    name: "User Unlock/Lock Door Notifications and Actions",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Execute actions when users unlock/lock doors",
    category: "Safety & Security",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/Solution/doors-locks-active.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Solution/doors-locks-active@2x.png"
)

preferences {
    page(name: "setupApp")
    page(name: "usersPage")
    page(name: "notificationsPage")
    page(name: "unlockLockActionsPage")
    page(name: "unlockKeypadActionsPage")
    page(name: "unlockManualActionsPage")
    page(name: "armKeypadActionsPage")
    page(name: "lockKeypadActionsPage")
    page(name: "lockManualActionsPage")
    page(name: "openCloseDoorPage")
    page(name: "userConfigPage")
}

def setupApp() {
    log.trace "$settings"

    dynamicPage(name: "setupApp", title: "User Door Unlock/Lock Notifications and Actions v${clientVersion()}", install: true, uninstall: true) {    
        if (state.clientVersion) { // If the app has already been installed
            section("Select Lock(s)") {
                input "locks","capability.lock", title: "Lock(s)", multiple: true, submitOnChange: true, image: "http://www.rboyapps.com/images/HandleLock.png"
            }

            section("How many users do you want to monitor?") {
                def maxCodes = 0
                for (lock in locks) {
                    Integer lockMax = lock.hasAttribute("maxCodes") ? lock.currentValue("maxCodes") : 0
                    log.trace "$lock has max users: $lockMax"
                    maxCodes = maxCodes ? (lockMax ? Math.max(lockMax, maxCodes) as Integer : maxCodes) : (lockMax ?: 0) // Take the highest amongst all selected locks
                }
                input name: "maxUserNames", title: "Number of users${maxCodes ? " (1 to ${maxCodes})" : ""}", type: "number", required: true, multiple: false, image: "http://www.rboyapps.com/images/Users.png", range: "1..${maxCodes ?: 999}"
                href(name: "users", title: "Manage users", page: "usersPage", description: "User names and custom actions", required: false, image: "http://www.rboyapps.com/images/User.png")
            }

            section("General Settings") {
                // Unlock actions for all users (global)
                def hrefParams = [
                    user: null, 
                    passed: true 
                ]
                href(name: "unlockLockActions", params: hrefParams, title: "Lock/unlock actions", page: "unlockLockActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/LockUnlock.png")
                href(name: "openCloseDoor", title: "Door open/close actions", page: "openCloseDoorPage", description: "", required: false, image: "http://www.rboyapps.com/images/DoorOpenClose.png")
                href(name: "notifications", params: hrefParams, title: "Notifications", page: "notificationsPage", description: "", required: false, image: "http://www.rboyapps.com/images/NotificationsD.png")
            }

            section() {
                label title: "Assign a name for this SmartApp (optional)", required: false
                input name: "updateNotifications", title: "Check for new versions of the app", type: "bool", defaultValue: true, required: false
            }

            section("Advanced Options (optional)", hideable: true, hidden: true) {
                paragraph "Enable this to get additional detailed notifications about lock/unlock/open/close actions being executed"
                input name: "detailedNotifications", title: "Get detailed notifications", type: "bool", defaultValue: "false", required: false
            }
        } else {
            section() {
                paragraph "Click on 'Save' to install the app\n\nThen you can open it from the 'Automations' tab to finish configuring it"
                label title: "Assign a name for this SmartApp (optional)", required: false
            }
        }
        
        remove("Uninstall")
    }
}

def notificationsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    log.trace "Notifications Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"notificationsPage", title: (user ? "Setup custom notifications for ${name ?: "user ${user}"}" : "Setup notification options"), uninstall: false, install: false) {
        section {
            input "audioDevices${user}", "capability.audioNotification", title: "Play notifications on these devices", required: false, multiple: true, image: "http://www.rboyapps.com/images/Horn.png"
            input("recipients${user}", "contact", title: "Send notifications to", multiple: true, required: false, image: "http://www.rboyapps.com/images/Notifications.png") {
                paragraph "You can enter multiple phone numbers by separating them with a '*'\nE.g. 5551234567*+448747654321"
                input "sms${user}", "phone", title: "Send SMS notification to", required: false, image: "http://www.rboyapps.com/images/Notifications.png"
                input "disableAllNotify${user}", "bool", title: "Disable all push notifications${user ? " for " + (name ?: "user ${user}") : ""}", defaultValue: false, required: false
            }
        }
    }
}

def openCloseDoorPage() {
    dynamicPage(name:"openCloseDoorPage", title: "Select door open/close sensor for each door and configure the automatic unlock, relock and notifications of the door", uninstall: false, install: false) {
        section {
            for (lock in locks) {
                def priorRelockDoor = settings."relockDoor${lock}"
                def priorRelockImmediate = settings."relockImmediate${lock}"
                def priorRelockAfter = settings."relockAfter${lock}"
                def priorRetractDeadbolt = settings."retractDeadbolt${lock}"
                def priorNotifyOpen = settings."openNotify${lock}"
                def priorNotifyOpenTimeout = settings."openNotifyTimeout${lock}"
                def priorOpenNotifyModes = settings."openNotifyModes${lock}"
                def priorRelockDoorModes = settings."relockDoorModes${lock}"
                def priorNotifyBeep = settings."openNotifyBeep${lock}"
                def priorSensor = settings."sensor${lock}"
                def reqDoorSensor = priorRelockImmediate || priorRetractDeadbolt || priorNotifyOpen || priorNotifyBeep

                paragraph title: "Configure ${lock}", required: true, ""
                if (priorRelockDoor || priorRetractDeadbolt || priorNotifyOpen || priorNotifyBeep) {
                    input "sensor${lock}", "capability.contactSensor", title: "Door open/close sensor${reqDoorSensor ? "" : " (optional)"}", required: ( reqDoorSensor ? true : false), submitOnChange: true // required for deadbolt, immediate relock or notifications
                }

                // Sanity check do not offer AutoLock is hardware autoLock is engaged
                if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
                    paragraph title: "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features", required: true, ""
                } else {
                    input "relockDoor${lock}", "bool", title: "Relock door automatically", defaultValue: priorRelockDoor, required: false, submitOnChange: true
                    if (priorRelockDoor) {
                        input "relockImmediate${lock}", "bool", title: "Relock immediately after closing", defaultValue: priorRelockImmediate, required: false, submitOnChange: true
                        if (!priorRelockImmediate) {
                            input "relockAfter${lock}", "number", title: "Relock after ${priorSensor ? "closing" : "unlocking"} (minutes)", defaultValue: priorRelockAfter, required: true                   
                        }
                        input "relockDoorModes${lock}", "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorRelockDoorModes, required: false, multiple: true
                    }
                    if (priorRetractDeadbolt) {
                        paragraph "NOTE: Make sure the AutoLock feature on the lock is disabled to avoid an infinite locking/unlocking loop.", required: false, submitOnChange: true
                    }
                    input "retractDeadbolt${lock}", "bool", title: "Unlock door if locked while open", defaultValue: priorRetractDeadbolt, description: "This retracts the deadbolt if it extends while the door is still open", required: false, submitOnChange: true
                }

                input "openNotifyBeep${lock}", "capability.tone", title: "Ring chime when door is opened", multiple: true, required: false, submitOnChange: true
                input "openNotify${lock}", "bool", title: "Notify if door has been left open", defaultValue: priorNotifyOpen, required: false, submitOnChange: true
                if (priorNotifyOpen) {
                    input "openNotifyTimeout${lock}", "number", title: "...for (minutes)", defaultValue: priorNotifyOpenTimeout, required: true, range: "1..*"
                }
                if (priorNotifyOpen || priorNotifyBeep) {
                    input "openNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorOpenNotifyModes, required: false, multiple: true
                }

                paragraph "\r\n"
            }
        }
    }
}

def unlockLockActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    def name = user ? settings."userNames${user}" : ""

    log.trace "Lock/Unlock Action Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockLockActionsPage", title: (user ? "Setup custom actions/notifications for ${name ?: "user ${user}"}" : "Setup lock/unlock actions for each door"), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        def showActions = true
        if (!phrases) {
            log.warn "No Routines found!!!"
        }
        section {
            if (user) { // User specific override options
                paragraph "Enabling custom user actions and notifications will override over the general actions defined on the first page"
                input "userOverrideUnlockActions${user}", "bool", title: "Define custom actions for ${name ?: "user ${user}"}", required: true,  submitOnChange: true
                if (!settings."userOverrideUnlockActions${user}") { // Check if user has enabled specific override actions then show menu
                    showActions = false
                }
            }
            if  (showActions && locks?.size() > 1) {
                input "individualDoorActions${user}", "bool", title: "Separate actions for each door", required: true,  submitOnChange: true
            }
        }
        if (showActions) { // Do we need to show actions?
            if (settings."individualDoorActions${user}") {
                for (lock in locks) {
                    section ("$lock", hideable: false) {
                        def hrefParams = [
                            user: user,
                            lock: lock as String,
                            passed: true 
                        ]
                        href(name: "unlockKeypadActions${lock}", params: hrefParams, title: "Keypad Unlock Actions", page: "unlockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadUnlocked.png")
                        href(name: "lockKeypadActions${lock}", params: hrefParams, title: "Keypad Lock Actions", page: "lockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadLocked.png")
                        if (!user) {
                            href(name: "unlockManualActions${lock}", params: hrefParams, title: "Manual Unlock Actions", page: "unlockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualUnlocked.png")
                            href(name: "lockManualActions${lock}", params: hrefParams, title: "Manual Lock Actions", page: "lockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualLocked.png")
                        }
                    }
                }
            } else {
                section("", hideable: false) {
                    def hrefParams = [
                        user: user,
                        lock: "",
                        passed: true 
                    ]
                    href(name: "unlockKeypadActions", params: hrefParams, title: "Keypad Unlock Actions", page: "unlockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadUnlocked.png")
                    href(name: "lockKeypadActions", params: hrefParams, title: "Keypad Lock Actions", page: "lockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadLocked.png")
                    if (!user) {
                        href(name: "unlockManualActions", params: hrefParams, title: "Manual Unlock Actions", page: "unlockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualUnlocked.png")
                        href(name: "lockManualActions", params: hrefParams, title: "Manual Lock Actions", page: "lockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualLocked.png")
                    }
                }
            }
        }
        section {
            if (user && settings."userNotify${user}") { // User specific override notification options
                def showCustomNotifications = true
                input "userOverrideNotifications${user}", "bool", title: "Define custom notifications for ${name ?: "user ${user}"}", required: true,  submitOnChange: true
                if (!settings."userOverrideNotifications${user}") { // Check if user has enabled specific override actions then show menu
                    showCustomNotifications = false
                }
                if (showCustomNotifications) {
                    def hrefParams = [
                        user: user, 
                        passed: true 
                    ]
                    href(name: "notifications", params: hrefParams, title: "Notifications", page: "notificationsPage", description: "", required: false, image: "http://www.rboyapps.com/images/NotificationsD.png")
                }
            }
        }
    }
}

def unlockKeypadActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for user $user, lock $lock"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user, lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    def name = user ? settings."userNames${user}" : ""

    log.trace "Keypad Unlock Action Page, user:$user, name:$name, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockKeypadActionsPage", title: "Setup keypad unlock actions for doors" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Keypad Unlock Actions${lock ? " for $lock" : ""}") {
            def priorHomePhrase = settings."homePhrase${lock}${user}"
            def priorHomeMode = settings."homeMode${lock}${user}"
            def isLockKeypad = locks?.find{ it.name == lock }?.hasAttribute("armMode") // Check if the current lock (lock specific option) is a keypad
            def isAnyLockKeypad = locks?.any { keypad -> keypad.hasAttribute("armMode") } // Check if any lock (for global options) is a keypad
            def areAllLockKeypad = locks?.every { keypad -> keypad.hasAttribute("armMode") } // Check every lock (for global options) is a keypad
            
            paragraph "Run these actions when a user successfully unlocks the door using a code"
            if (lock ? isLockKeypad : isAnyLockKeypad) { // Show only if we have a supported keypad (for selected lock or for general settings)
                input "keypadArmDisarm${lock}${user}", "bool", title: "Control SHM/ADT using keypad", required: false, submitOnChange: true
            }
            if (lock ? (isLockKeypad ? !settings."keypadArmDisarm${lock}${user}" : true) : (areAllLockKeypad ? !settings."keypadArmDisarm${lock}${user}" : true)) { // Hide only if we have have a supported keypad for selected lock and using keypad to control SHM
                input "homeDisarm${lock}${user}", "bool", title: "Disarm Smart Home Monitor", required: false
                input "adtDisarm${lock}${user}", "bool", title: "Disarm ADT", required: false, submitOnChange: true
            }
            if (((lock ? (isLockKeypad ? !settings."keypadArmDisarm${lock}${user}" : true) : (areAllLockKeypad ? !settings."keypadArmDisarm${lock}${user}" : true)) && settings."adtDisarm${lock}${user}") ||
                ((lock ? isLockKeypad : isAnyLockKeypad) && settings."keypadArmDisarm${lock}${user}")) { // If we have a seleted an ADT option
                input "adtDevices", "capability.battery", title: "Select ADT panel(s)", multiple: true, required: (settings."adtDisarm${lock}${user}" ? true : false) // Required if we select ADT
            }
            input "homePhrase${lock}${user}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorHomePhrase
            input "homeMode${lock}${user}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "turnOnSwitchesAfterSunset${lock}${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true
            input "turnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "turnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "unlockLocks${lock}${user}","capability.lock", title: "Unlock lock(s)", required: false, multiple: true
            input "openGarage${lock}${user}","capability.garageDoorControl", title: "Open garage door(s)", required: false, multiple: true	    

            paragraph title: "Do NOT run the above unlock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleUnlockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeUnlockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true
        }
    }
}

def unlockManualActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for lock $lock"
    } else if (atomicState.params) {
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Manual Unlock Action Page, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockManualActionsPage", title: "Setup manual unlock actions for doors", uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Manual Unlock Actions${lock ? " for $lock" : ""}") {
            def priorHomePhrase = settings."homePhraseManual${lock}"
            def priorHomeMode = settings."homeModeManual${lock}"
            def priorManualNotify = settings."manualNotify${lock}"

            paragraph "Run these actions when a user unlocks the door manually"
            input "homeDisarmManual${lock}", "bool", title: "Disarm Smart Home Monitor", required: false
            input "adtDisarmManual${lock}", "bool", title: "Disarm ADT", required: false, submitOnChange: true
            if (settings."adtDisarmManual${lock}") { // If we have a seleted an ADT option
                input "adtDevices", "capability.battery", title: "Select ADT panel(s)", multiple: true, required: true // Required if we select ADT
            }
            input "homePhraseManual${lock}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorHomePhrase
            input "homeModeManual${lock}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "turnOnSwitchesAfterSunsetManual${lock}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true
            input "turnOnSwitchesManual${lock}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "turnOffSwitchesManual${lock}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "unlockLocksManual${lock}","capability.lock", title: "Unlock lock(s)", required: false, multiple: true
            input "openGarageManual${lock}","capability.garageDoorControl", title: "Open garage door(s)", required: false, multiple: true	    

            paragraph title: "Do NOT run the above unlock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleUnlockActionsManual${lock}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeUnlockActionsManual${lock}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            paragraph "Unlock Notification Options"
            input "manualNotify${lock}", "bool", title: "Notify on manual unlock", required: false, submitOnChange: true
            if (priorManualNotify) {
                input "manualNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", required: false, multiple: true
            }
        }
    }
}

def armKeypadActionsPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
        log.trace "Passed from main page, using params lookup ${params}"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState lookup ${atomicState.params}"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def user = params?.user ?: ""
    def lock = params?.lock ?: ""
    def arm = params?.arm ?: ""

    def name = user ? settings."userNames${user}" : ""

    log.trace "Arm Keypad Action Page, user:$user, name:$name, lock $lock, arm $arm, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"armKeypadActionsPage", title: "Setup Arm ${arm?.capitalize()} button actions for ${lock ?: "keypad"}" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section {
            input "keypadArmActions${lock}${user}${arm}", "bool", title: "Enable custom actions", required: false, submitOnChange: true
            if (settings."keypadArmActions${lock}${user}${arm}") {
                def priorLockPhrase = settings."externalLockPhrase${lock}${user}${arm}"
                def priorHomeMode = settings."externalLockMode${lock}${user}${arm}"

                input "externalLockPhrase${lock}${user}${arm}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
                input "externalLockMode${lock}${user}${arm}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
                input "externalLockTurnOnSwitches${lock}${user}${arm}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                input "externalLockTurnOffSwitches${lock}${user}${arm}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
                input "lockLocks${lock}${user}${arm}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
                input "closeGarage${lock}${user}${arm}","capability.garageDoorControl", title: "Close garage door(s)", required: false, multiple: true
            }
        }
    }
}

def lockKeypadActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for user $user, lock $lock"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user, lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    def name = user ? settings."userNames${user}" : ""

    log.trace "Keypad Lock Action Page, user:$user, name:$name, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"lockKeypadActionsPage", title: "Setup keypad lock actions for doors" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Keypad Lock Actions${lock ? " for $lock" : ""}") {
            def priorLockPhrase = settings."externalLockPhrase${lock}${user}"
            def priorHomeMode = settings."externalLockMode${lock}${user}"
            def isLockKeypad = locks?.find{ it.name == lock }?.hasAttribute("armMode") // Check if the current lock (lock specific option) is a keypad
            def isAnyLockKeypad = locks?.any { keypad -> keypad.hasAttribute("armMode") } // Check if any lock (for global options) is a keypad
            def areAllLockKeypad = locks?.every { keypad -> keypad.hasAttribute("armMode") } // Check every lock (for global options) is a keypad
            
            paragraph "Some locks can be locked from the keypad outside${user ? " with user codes" : ""}. If your lock has his feature then you can assign actions to execute when it is locked ${user ? "with a user code" : "from the keypad"}"
            if (lock ? isLockKeypad : isAnyLockKeypad) { // Show only if we have a supported keypad (for selected lock or for general settings)
                input "keypadArmDisarm${lock}${user}", "bool", title: "Control SHM/ADT using keypad", required: false, submitOnChange: true
            }
            if (lock ? (isLockKeypad ? !settings."keypadArmDisarm${lock}${user}" : true) : (areAllLockKeypad ? !settings."keypadArmDisarm${lock}${user}" : true)) { // Hide only if we have have a supported keypad for selected lock and using keypad to control SHM
                input "homeArm${lock}${user}", "bool", title: "Arm Smart Home Monitor to Away", required: false, submitOnChange: true
                input "adtArm${lock}${user}", "bool", title: "Arm ADT to Away", required: false, submitOnChange: true
                if (settings."homeArm${lock}${user}" || settings."adtArm${lock}${user}") {
                    input "homeArmStay${lock}${user}", "bool", title: "...arm to Stay instead of Away", required: false
                }
            }
            if (((lock ? (isLockKeypad ? !settings."keypadArmDisarm${lock}${user}" : true) : (areAllLockKeypad ? !settings."keypadArmDisarm${lock}${user}" : true)) && settings."adtArm${lock}${user}") ||
                ((lock ? isLockKeypad : isAnyLockKeypad) && settings."keypadArmDisarm${lock}${user}")) { // If we have a seleted an ADT option
                input "adtDevices", "capability.battery", title: "Select ADT panel(s)", multiple: true, required: (settings."adtArm${lock}${user}" ? true : false) // Required if we select ADT
            }
            if (lock ? isLockKeypad : isAnyLockKeypad) { // Show only if we have a supported keypad (for selected lock or for general settings)
                def hrefParams = [
                    user: user,
                    lock: lock as String,
                    passed: true 
                ]
                href(name: "armAwayKeypadActions${lock}", params: hrefParams + [arm: "away"], title: "Away/On button actions", page: "armKeypadActionsPage", description: "", required: false, image: "")
                href(name: "armStayKeypadActions${lock}", params: hrefParams + [arm: "stay"], title: "Stay/Partial button actions", page: "armKeypadActionsPage", description: "", required: false, image: "")
                href(name: "armNightKeypadActions${lock}", params: hrefParams + [arm: "night"], title: "Night button actions", page: "armKeypadActionsPage", description: "", required: false, image: "")
            }
            input "externalLockPhrase${lock}${user}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
            input "externalLockMode${lock}${user}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "externalLockTurnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "externalLockTurnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "lockLocks${lock}${user}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
            input "closeGarage${lock}${user}","capability.garageDoorControl", title: "Close garage door(s)", required: false, multiple: true

            input "delayLockActionsTime${lock}${user}", "number", title: "Delay running actions (minutes)", required: false, range: "0..*"

            paragraph title: "Do NOT run the above lock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleLockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeLockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            if (!user) { // Users will use the user notify option
                paragraph "Lock Notification Options"
                input "externalLockNotify${lock}", "bool", title: "Notify on keypad lock", required: false, submitOnChange: true
                if (settings."externalLockNotify${lock}") {
                    input "externalLockNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                }
                input "jamNotify${lock}", "bool", title: "Notify on Lock Jam/Stuck", required: false
            }
        }
    }
}

def lockManualActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for lock $lock"
    } else if (atomicState.params) {
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Manual Lock Action Page, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"lockManualActionsPage", title: "Setup manual lock actions for doors", uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Manual Lock Actions${lock ? " for $lock" : ""}") {
            def priorLockPhrase = settings."externalLockPhraseManual${lock}"
            def priorHomeMode = settings."externalLockModeManual${lock}"

            input "homeArmManual${lock}", "bool", title: "Arm Smart Home Monitor to Stay", required: false
            input "adtArmManual${lock}", "bool", title: "Arm ADT to Stay", required: false, submitOnChange: true
            if (settings."adtArmManual${lock}") { // If we have a seleted an ADT option
                input "adtDevices", "capability.battery", title: "Select ADT panel(s)", multiple: true, required: true // Required if we select ADT
            }
            input "externalLockPhraseManual${lock}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
            input "externalLockModeManual${lock}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "externalLockTurnOnSwitchesManual${lock}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "externalLockTurnOffSwitchesManual${lock}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "lockLocksManual${lock}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
            input "closeGarageManual${lock}","capability.garageDoorControl", title: "Close garage door(s)", required: false, multiple: true

            input "delayLockActionsTimeManual${lock}", "number", title: "Delay running actions (minutes)", required: false, range: "0..*"

            paragraph title: "Do NOT run the above lock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleLockActionsManual${lock}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeLockActionsManual${lock}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            paragraph "Lock Notification Options"
            input "lockNotify${lock}", "bool", title: "Notify on manual/auto lock", required: false, submitOnChange: true
            if (settings."lockNotify${lock}") {
                input "lockNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", required: false, multiple: true
            }
        }
    }
}

def usersPage() {
    dynamicPage(name:"usersPage", title: "User Names, Actions and Notification Setup", uninstall: false, install: false) {

        if (!maxUserNames) {
            section("Invalid number of users") {
                paragraph title: "First configure the number of users on the previous page", required: true, ""
            }
        }

        section() {
            for (int i = 1; i <= maxUserNames; i++) {
                def priorName = settings."userNames${i}"
                def priorNotify = settings."userNotify${i}"
                def priorNotifyModes = settings."userNotifyModes${i}"
                //log.trace "Initial $i Name: $priorName, Notify: $priorNotify, NotifyModes: $priorNotifyModes"

                // Params for user
                def hrefParams = [
                    user: i as String,
                    passed: true 
                ]
                href(name: "userConfig${i}", params: hrefParams, title: "Slot ${i} - ${priorName ?: "< blank >"}", page: "userConfigPage", description: "", required: false, image: ("http://www.rboyapps.com/images/User.png"))
            }
        }
    }
}

def userConfigPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get user from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.user) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user:$user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user:$user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    def name = user ? settings."userNames${user}" : ""
    def i = user as Integer

    log.trace "User Codes Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"userConfigPage", title: "User Slot #${i}", uninstall: false, install: false) {
        section() {
            def priorName = settings."userNames${i}"
            def priorNotify = settings."userNotify${i}"
            def priorNotifyModes = settings."userNotifyModes${i}"
            //log.trace "Initial $i Name: $priorName, Notify: $priorNotify, NotifyModes: $priorNotifyModes"

            // User and code details/types
            input "userNames${i}", "text", description: "Tap to set", title: "Name", multiple: false, required: false, submitOnChange: false, image: "http://www.rboyapps.com/images/User.png"
            input "userNotify${i}", "bool", title: "Notify on use", defaultValue: true, required: false, submitOnChange: true, image: "http://www.rboyapps.com/images/Notifications.png"
            if (priorNotify != false) {
                input "userNotifyUseCount${i}", "number", title: "...limit to only this many times", description: "no limit", required: false, range: "1..*"
                input "userNotifyModes${i}", "mode", title: "...only when in this mode(s)", description: "notify only when in any of these modes", required: false, multiple: true
                input "userXNotifyPresence${i}", "capability.presenceSensor", title: "...and none of these people are present", description: "when all these people are not present", required: false, multiple: true
            }

            // Unlock actions for each user
            def hrefParams = [
                user: i as String, 
                passed: true 
            ]
            href(name: "unlockLockActions", params: hrefParams, title: "Custom actions/notifications", page: "unlockLockActionsPage", description: (settings."userOverrideUnlockActions${user}" || (settings."userOverrideNotifications${user}" && settings."userNotify${user}")) ? "Configured" : "", required: false, image: "http://www.rboyapps.com/images/LockUnlock.png")
        } 
    } 
}

def installed()
{
    log.debug "Install Settings: $settings"
    appTouch()
}

def updated()
{
    log.debug "Update Settings: $settings"
    appTouch()
}

def appTouch() {
    state.clientVersion = clientVersion() // Update our local stored client version to detect code upgrades
 
    unschedule() // clear all pending updates
    unsubscribe()

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
    
    // subscribe to events to kick start timers and presence/mode events to update code states
    subscribe(location, "mode", changeHandler)
    subscribe(app, changeHandler) // Capture user intent to reinitialize timers

    subscribe(locks, "lock", lockHandler) // Subscribe to lock events to take action as defined as user
    subscribe(locks, "tamper", lockHandler) // Subscribe to tamper events
    subscribe(location, "alarmSystemStatus" , shmChangeHandler) // Subscribe to SHM state handler
    if (adtDevices) {
        subscribe(adtDevices, "securitySystemStatus" , adtChangeHandler) // Subscribe to ADT state handler
    }

    locks.each { lock -> // check each lock individually
        if (settings."sensor${lock}") {
            log.trace "Subscribing to sensor ${settings."sensor${lock}"} for ${lock}"
            subscribe(settings."sensor${lock}", "contact", sensorHandler)
        }
        if (lock.hasAttribute('invalidCode')) {
            log.trace "Found attribute 'invalidCode' on lock $lock, enabled support for invalid code detection"
            subscribe(lock, "invalidCode", lockHandler)
        }
    }

    state.codeUseCount = [:] // Number of times codes were used
    atomicState.reLocks = [:] // List of lock to relock after a timed delay
    atomicState.notifyOpenDoors = [:] // List of locks to check for open notifications
    atomicState.immediateLocks = [] // List of lock to lock immediately after a short delay
    atomicState.unLocks = [] // List of lock to unlock after a short delay
    for (lock in locks) {
        state.codeUseCount[lock.id] = [:] // Number of times a code usage was used for this lock
    }
    
    schedule("* */10 * * * ?", heartBeatMonitor) // run the heartbeat every 10 minutes
}

// Handle changes, reinitialize the code check timers after a change, this is to workaround the issue of a buggy ST platform where the timers die randomly for some users
def changeHandler(evt) {
    log.trace "Reinitializing code check timer on event notification, name: ${evt?.name}, value: ${evt?.value}, device: ${evt?.device}"
    
    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion != clientVersion()) {
        def msg = "NOTE: ${app.label} detected a code upgrade. Updating configuration, please open the app and click on Save to re-validate your settings"
        log.warn msg
        startTimer(1, appTouch) // Reinitialize the app offline to avoid a loop as appTouch calls codeCheck
        sendNotifications(msg) // Do this in the end as it may timeout
        return
    }

    if (evt?.name == "mode") { // Mode change notification
        for (lock in locks) { // Check all locks
            def sensor = settings."sensor${lock}" // Find the lock for this sensor, match by ID and not objects
            if (sensor) {
                log.trace "Checking for any pending door sensor activites that need to be done for lock $lock with sensor $sensor in mode ${evt.value}"
                def sensorEvt = [name: sensor.name, displayName: sensor.displayName, value: sensor.latestValue("contact"), device: sensor]
                sensorHandler(sensorEvt)
            }
        }
    }
}

// Handle changes to ADT states
def adtChangeHandler(evt) {
    log.trace "ADT state change notification, name: ${evt.name}, value: ${evt.value}"

    def msg = ""
    def keypads = locks?.findAll{ lock -> lock.hasAttribute("armMode")} // Get all keypads and sync state with ADT
    //def mode = settings."adtDevices"?.currentState("securitySystemStatus")?.value // This should the new ADT state
    def user = "" // We don't check for individual user custom actions for keypads since synchronization needs to happen at the keypad level
    def directControl = (settings."individualDoorActions${user}" ? keypads : [ "" ]).any { lock -> settings."keypadArmDisarm${lock}${user}" }
    def mode = evt.value // Since it from a device lets take the value directly
    if (keypads && directControl) {
        switch (mode) {
            case "armedAway":
                msg = "Detected ADT mode change, setting $keypads to Armed Away"
                keypads*.setArmedAway()
                break	

            case "armedStay":
                msg = "Detected ADT mode change, setting $keypads to Armed Stay"
                keypads*.setArmedStay()
                break

            case "disarmed":
                msg = "Detected ADT mode change, setting $keypads to Disarmed"
                keypads*.setDisarmed()
                break

            default:
                log.error "Unknown ADT mode $mode"
                break
        }
    } else {
        log.trace "No keypads found under direct SHM/ADT control"
    }
    
    if (keypads && msg) {
        log.info msg
    }
}

// Handle changes to SHM states
def shmChangeHandler(evt) {
    log.trace "SHM state change notification, name: ${evt.name}, value: ${evt.value}"

    def msg = ""
    def keypads = locks?.findAll{ lock -> lock.hasAttribute("armMode")} // Get all keypads and sync state with SHM
    def user = "" // We don't check for individual user custom actions for keypads since synchronization needs to happen at the keypad level
    def directControl = (settings."individualDoorActions${user}" ? keypads : [ "" ]).any { lock -> settings."keypadArmDisarm${lock}${user}" }
    //def mode = location.currentState("alarmSystemStatus")?.value // This should the new SHM state
    def mode = evt.value // This is the changed value
    if (keypads && directControl) {
        switch (mode) {
            case "away":
                msg = "Detected SHM mode change, setting $keypads to Armed Away"
                keypads*.setArmedAway()
                break	

            case "stay":
                msg = "Detected SHM mode change, setting $keypads to Armed Stay"
                keypads*.setArmedStay()
                break

            case "off":
                msg = "Detected SHM mode change, setting $keypads to Disarmed"
                keypads*.setDisarmed()
                break

            default:
                log.error "Unknown SHM mode $mode"
                break
        }
    } else {
        log.trace "No keypads found under direct SHM/ADT control"
    }
    
    if (keypads && msg) {
        log.info msg
    }
}

def sensorHandler(evt) {
    log.trace "Event name $evt.name, value $evt.value, device $evt.displayName"

    def sensor = evt.device

    def lock = locks.find { settings."sensor${it}"?.id == sensor.id } // Find the lock for this sensor, match by ID and not objects
    log.trace "Sensor ${sensor} belongs to Lock ${lock}"

    if (evt.value == "closed") { // Door was closed
        if (lock && settings."relockDoor${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
            if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
                log.warn "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features"
            } else {
                if (settings."relockImmediate${lock}") {
                    log.debug "Relocking ${lock} immediately in 3 seconds"
                    def immediatelocks = atomicState.immediateLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    if (!immediatelocks.contains(lock.id)) { // Don't re add the same lock again
                        //log.trace "Adding ${lock.id} to the list of immediate locks"
                        immediatelocks.add(lock.id) // Atomic to ensure we get upto date info here
                        atomicState.immediateLocks = immediatelocks // Set it back, we can't work direct on atomicState
                    }
                    immediateLockDoor() // Lock it right away
                } else if (settings."relockAfter${lock}") {
                    log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
                    def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    //log.trace "Adding ${lock.id} to the list of relocks"
                    reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                    atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
                    reLockDoor() // Call relock door it'll take of delaying the lock as required
                } else {
                    log.error "Invalid configuration, no relock timeout defined"
                }
            }
        }
    } else { // Door was opened
        // Chime bell
        if (settings."openNotifyBeep${lock}") {
            if (!settings."openNotifyModes${lock}" || (settings."openNotifyModes${lock}"?.find{it == location.mode})) {
                log.debug "Door ${sensor} was opened, chiming bell ${settings."openNotifyBeep${lock}"}"
                settings."openNotifyBeep${lock}".beep() // Beep
            } else {
                log.trace "${lock} chiming not set for Mode ${location.mode}"
            }
        }

        // Notify user
        if (settings."openNotify${lock}") {
            if (!settings."openNotifyModes${lock}" || (settings."openNotifyModes${lock}"?.find{it == location.mode})) {
                log.debug "Scheduling ${lock} to notify user of open door in ${settings."openNotifyTimeout${lock}"} minutes"
                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                atomicState.notifyOpenDoors = notifyOpenDoors // Set it back, we can't work direct on atomicState
                notifyOpenDoor() // Notify, it'll take of delaying it if it's too soon
            } else {
                log.trace "${lock} open notification not set for Mode ${location.mode}"
            }
        }
    }
}

// Check for any pending door unlocks
def unLockDoor() {
    def unLocksIDs = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending door unlocks ${unLocksIDs}"

    unLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "UnLocking the door ${lock} immediately"
        lock.unlock() // unlock it
        def unlocks = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending unlocks"
        unlocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.unLocks = unlocks // set it back to atomicState
        //log.trace "Checking for any pending door unlocks in 3 seconds"
        startTimer(3, unLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending immediate door locks
def immediateLockDoor() {
    def immediateLocksIDs = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending immediate door locks ${immediateLocksIDs}"

    immediateLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "Locking the door ${lock} immediately"
        lock.lock() // lock it
        def immediatelocks = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending immediate locks"
        immediatelocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.immediateLocks = immediatelocks // set it back to atomicState
        //log.trace "Checking for any pending immediate door locks in 3 seconds"
        startTimer(3, immediateLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending delayed door relocks
def reLockDoor() {
    def reLocksIDs = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking door sensor state and relocking ${reLocksIDs}"

    Long shortestPendingTime = 0 // in seconds
    
    reLocksIDs?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        Long timeLeft = (((60 * 1000 * settings."relockAfter${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true) { // Check if the mode is still active
                if (!lockSensor) { // If we don't have a sensor then just lock on schedule
                    log.info "No sensor found on ${lock} when closed, locking the door"
                    lock.lock() // lock it
                    //log.trace "Removing ${lockid} from the list of pending relocks"
                    def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    reLocks.remove(lockid) // We are done with this lock, remove it from the list
                    atomicState.reLocks = reLocks // set it back to atomicState
                    //log.trace "Checking for any pending relocks in 3 seconds"
                    startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                    return // We're done here
                } else if (lockSensor.latestValue("contact") == "closed") {
                    log.info "Sensor ${lockSensor} is reporting door ${lock} is closed, locking the door"
                    lock.lock() // lock it
                    //log.trace "Removing ${lockid} from the list of pending relocks"
                    def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    reLocks.remove(lockid) // We are done with this lock, remove it from the list
                    atomicState.reLocks = reLocks // set it back to atomicState
                    //log.trace "Checking for any pending relocks in 3 seconds"
                    startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                    return // We're done here
                } else {
                    log.debug "Sensor ${lockSensor} is reporting door ${lock} is not closed, will check again in 60 seconds"
                    startTimer(60, reLockDoor) // Check back again in some time
                }
            } else {
                log.trace "Relock mode conditions not met, not executing relock"
                def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                reLocks.remove(lockid) // We are done with this lock, remove it from the list
                atomicState.reLocks = reLocks // set it back to atomicState
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."relockAfter${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), reLockDoor) // Check back again after shortest pending timeout
    }
}

// Notify if the doors are left open
def notifyOpenDoor() {
    def notifyOpenDoorsIds = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking Locks ${notifyOpenDoorsIds} door sensor state"

    Long shortestPendingTime = 0 // in seconds
    
    notifyOpenDoorsIds?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        
        if (!settings."openNotify${lock}" || (settings."openNotifyModes${lock}" && !(settings."openNotifyModes${lock}"?.find{it == location.mode}))) { // Check if the settings have changed
            log.trace "No need to monitor open sensor ${lockSensor} for door ${lock} as settings/modes have changed"
            //log.trace "Removing ${lockid} from the list of pending notifications"
            def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
            notifyOpenDoors.remove(lock.id) // We are done with this lock, remove it from the list
            atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState
            return // move on
        }
        
        Long timeLeft = (((60 * 1000 * settings."openNotifyTimeout${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (lockSensor.latestValue("contact") == "closed") {
                log.trace "Sensor ${lockSensor} is reporting door ${lock} is closed, no notification required"
                //log.trace "Removing ${lockid} from the list of pending notifications"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors.remove(lock.id) // We are done with this lock, remove it from the list
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState
            } else {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is open, notifying user and checking again after ${settings."openNotifyTimeout${lock}"} minutes"
                def msg = "$lockSensor has been open for ${settings."openNotifyTimeout${lock}"} minutes"

                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState

                startTimer(60, notifyOpenDoor) // Check back again after short timeout so we don't overwrite a short wait with a long wait
                sendNotifications(msg) // Do it in the end to avoid a timeout
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."openNotifyTimeout${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), notifyOpenDoor) // Check back again after shortest pending timeout
    }
}

// Lock event handler
def lockHandler(evt) {
    def data = null
    def lock = evt.device
    
    log.trace "Lock event name $evt.name, value $evt.value, device $evt.displayName, description $evt.descriptionText, data $evt.data"

    def evtMap = [name:evt.name, value:evt.value, displayName:evt.displayName, descriptionText:evt.descriptionText, data:evt.data, lockId: evt.device.id]

    if (evt.name == "lock") { // LOCK UNLOCK EVENTS
        if (evt.value == "unlocked") { // UNLOCKED
            unschedule(processLockActions) // If there was a pending delayed actions and user operated the lock then cancel it
            processUnlockEvent(evtMap)
        } else if (evt.value == "locked") { // LOCKED MANUALLY OR VIA KEYPAD OR ELECTRONICALLY
            unschedule(processLockActions) // If there was a pending delayed actions and user operated the lock then cancel it
            processLockEvent(evtMap)
        } else if (evt.value == "unknown") { // JAMMED CODE EVENT
            log.debug "Lock $evt.displayName Jammed!"
            if ((!settings."individualDoorActions" && jamNotify) ||
                (settings."individualDoorActions" && settings."jamNotify${lock}")) {
                def msg = "$evt.displayName lock is Jammed!"
                sendNotifications(msg)
            }        	
        }
    } else if (evt.name == "invalidCode") { // INVALID LOCK CODE EVENT
        log.debug "Lock $evt.displayName, invalid user code: ${evt.value}"
        def msg = "Too many invalid user codes detected on lock $evt.displayName"
        sendNotifications(msg)
    } else if (evt.name == "tamper" && evt.value == "detected") { // Tampering of the lock
        log.debug "Lock $evt.displayName tamper detected with description $evt.descriptionText"
        def msg = "Tampering detected on lock $evt.displayName. ${evt.descriptionText ?: ""}"
        sendNotifications(msg)
    }
}

def processUnlockEvent(evt) {
    def data = null
    def lock = locks.find { it.id == evt.lockId }

	log.trace "Processing $lock unlock event: $evt"

    // Check if we have delayed relock is enabled, if so then start the timer now just incase the user never opens the door (reLockDoor will take care of sensor if present, immediate relock should never happen without a sensor)
    if (settings."relockDoor${lock}" && settings."relockAfter${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
        if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
            log.warn "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features"
        } else {
            log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
            def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
            //log.trace "Adding ${lock.id} to the list of relocks"
            reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
            atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
            reLockDoor() // Call relock door it'll take of delaying the lock as required
        }
    } else {
        log.trace "Relock conditions not met, not scheduling relock"
    }

    if (evt.data) { // Was it unlocked using a code
        data = parseJson(evt.data)
    }
    def lockMode = data?.type ?: (data?.method ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically"))
    // Fix for proper grammar
    switch (lockMode) {
        case "manual":
        lockMode = "manually"
        break

        case "rfid":
        lockMode = "via RFID"
        break

        case "bluetooth":
        lockMode = "via bluetooth"
        break

        case "keypad":
        lockMode = "via keypad"
        break

        case "remote":
        case "command":
        lockMode = "remotely"
        break

        case "auto":
        lockMode = "via internal autolock"
        break

        default:
            break
    }

    if ((data?.usedCode == null) && !(["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) })) { // No extended data, must be a manual/auto/keyed unlock, NOTE: some locks don't send keypad user codes
        log.trace "$evt.displayName was unlocked manually. Source type: $lockMode"

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // First disarm SHM since it goes off due to other events
        if (settings."runXPeopleUnlockActionsManual${lockStr}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleUnlockActionsManual${lockStr}"?.find{it.currentPresence == "present"}} is present, not running unlock actions for door $lock"
        } else if (settings."runXModeUnlockActionsManual${lockStr}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running unlock actions for door $lock"
        } else {
            def msg = "$evt.displayName was unlocked $lockMode"

            if (settings."homeDisarmManual${lockStr}") {
                log.info "Disarming Smart Home Monitor"
                sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
            }

            try {
                if (settings."adtDisarmManual${lockStr}" && settings."adtDevices") {
                    log.info "Disarming ADT"
                    settings."adtDevices"?.disarm() // First do this to avoid false alerts from a slow platform
                    msg += detailedNotifications ? ", disarming ADT" : ""
                }
            } catch (e) { // This is still not official so lets be cautious about it
                log.error "Error disarming ADT\n$e"
                msg += ", error disarming ADT"
            }

            if (settings."homeModeManual${lockStr}") {
                log.info "Changing mode to ${settings."homeModeManual${lockStr}"}"
                if (location.modes?.find{it.name == settings."homeModeManual${lockStr}"}) {
                    setLocationMode(settings."homeModeManual${lockStr}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."homeModeManual${lockStr}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."homeModeManual${lockStr}"}" : ""
            }

            if (settings."homePhraseManual${lockStr}") {
                log.info "Running unlock Phrase ${settings."homePhraseManual${lockStr}"}"
                location.helloHome.execute(settings."homePhraseManual${lockStr}") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", running routine ${settings."homePhraseManual${lockStr}"}" : ""
            }

            if (settings."turnOnSwitchesAfterSunsetManual${lockStr}") {
                def cdt = new Date(now())
                def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                    log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunsetManual${lockStr}"} since it's after sunset but before sunrise"
                    settings."turnOnSwitchesAfterSunsetManual${lockStr}"?.on()
                    msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunsetManual${lockStr}"}" : ""
                }
            }

            if (settings."turnOnSwitchesManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitchesManual${lockStr}"}"
                settings."turnOnSwitchesManual${lockStr}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitchesManual${lockStr}"}" : ""
            }

            if (settings."turnOffSwitchesManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitchesManual${lockStr}"}"
                settings."turnOffSwitchesManual${lockStr}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitchesManual${lockStr}"}" : ""
            }

            if (settings."unlockLocksManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, unlocking ${settings."unlockLocksManual${lockStr}"}"
                settings."unlockLocksManual${lockStr}"?.unlock()
                msg += detailedNotifications ? ", unlocking ${settings."unlockLocksManual${lockStr}"}" : ""
            }

            if (settings."openGarageManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, opening ${settings."openGarageManual${lockStr}"}"
                settings."openGarageManual${lockStr}"?.open()
                msg += detailedNotifications ? ", opening ${settings."openGarageManual${lockStr}"}" : ""
            }	    

            if (settings."manualNotify${lockStr}" && (settings."manualNotifyModes${lockStr}" ? settings."manualNotifyModes${lockStr}".find{it == location.mode} : true)) {
                sendNotifications(msg)
            }
        }
    } else { // KEYPAD / RFID UNLOCK
        Integer i = data.usedCode as Integer
        def name = settings."userNames${i}"
        def notify = settings."userNotify${i}"
        def notifyCount = settings."userNotifyUseCount${i}"
        def notifyModes = settings."userNotifyModes${i}"
        def notifyXPresence = settings."userXNotifyPresence${i}"

        log.trace "Lock $evt.displayName unlocked by $name, notify $notify, notify count: $notifyCount, notify modes $notifyModes, notify NOT present $notifyXPresence, Source type: $lockMode"

        def msg = ""

        if (i == 0) {
            name = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
            notify = true // always inform about master users
        }

        if (!name) { // will handle usedCode null errors
            notify = true // always inform about unknown users
            msg = "$evt.displayName was unlocked by Unknown User from slot $i $lockMode"
        } else {
            msg = "$evt.displayName was unlocked by $name $lockMode"
        }

        // Check if we have user override unlock actions defined
        def user = ""
        if (settings."userOverrideUnlockActions${i as String}") {
            log.trace "Found per user unlock actions"
            user = i as String
        }

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions${user}") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // First disarm SHM since it goes off due to other events
        if (settings."runXPeopleUnlockActions${lockStr}${user}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleUnlockActions${lockStr}${user}"?.find{it.currentPresence == "present"}} is present, not running unlock actions for door $lock"
        } else if (settings."runXModeUnlockActions${lockStr}${user}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running unlock actions for door $lock"
        } else {
            // If we have a specific mode passed by the keypad lets use that otherwise use configured options
            if (settings."keypadArmDisarm${lockStr}${user}" && (data instanceof org.codehaus.groovy.grails.web.json.JSONObject ? !data?.isNull("armMode") : (data?.armMode != null))) { // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442
                switch (data.armMode) { // Set Keypad lock state
                    case "disarmed":
                    	log.info "Disarming Smart Home Monitor"
                    	sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                        msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
                        try {
                            if (settings."adtDevices") {
                                log.info "Disarming ADT"
                                settings."adtDevices"?.disarm() // First do this to avoid false alerts from a slow platform
                                msg += detailedNotifications ? ", disarming ADT" : ""
                            }
                        } catch (e) { // This is still not official so lets be cautious about it
                            log.error "Error disarming ADT\n$e"
                            msg += ", error disarming ADT"
                        }
                    	break
                        
                    default:
                        log.warn "Invalid SHM mode detected: ${data.armMode}"
                        msg += ", invalid Smart Home Monitor mode ${data.armMode}"
                        break
                }
            } else {
                if (settings."homeDisarm${lockStr}${user}") {
                    log.info "Disarming Smart Home Monitor"
                    sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                    msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
                }
                
                try {
                    if (settings."adtDisarm${lockStr}${user}" && settings."adtDevices") {
                        log.info "Disarming ADT"
                        settings."adtDevices"?.disarm() // First do this to avoid false alerts from a slow platform
                        msg += detailedNotifications ? ", disarming ADT" : ""
                    }
                } catch (e) { // This is still not official so lets be cautious about it
                    log.error "Error disarming ADT\n$e"
                    msg += ", error disarming ADT"
                }
            }

            if (settings."homeMode${lockStr}${user}") {
                log.info "Changing mode to ${settings."homeMode${lockStr}${user}"}"
                if (location.modes?.find{it.name == settings."homeMode${lockStr}${user}"}) {
                    setLocationMode(settings."homeMode${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."homeMode${lockStr}${user}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."homeMode${lockStr}${user}"}" : ""
            }

            if (settings."homePhrase${lockStr}${user}") {
                log.info "Running unlock Phrase ${settings."homePhrase${lockStr}${user}"}"
                location.helloHome.execute(settings."homePhrase${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", running routine ${settings."homePhrase${lockStr}${user}"}" : ""
            }

            if (settings."turnOnSwitchesAfterSunset${lockStr}${user}") {
                def cdt = new Date(now())
                def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                    log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${lockStr}${user}"} since it's after sunset but before sunrise"
                    settings."turnOnSwitchesAfterSunset${lockStr}${user}"?.on()
                    msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunset${lockStr}${user}"}" : ""
                }
            }

            if (settings."turnOnSwitches${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${lockStr}${user}"}"
                settings."turnOnSwitches${lockStr}${user}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitches${lockStr}${user}"}" : ""
            }

            if (settings."turnOffSwitches${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${lockStr}${user}"}"
                settings."turnOffSwitches${lockStr}${user}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitches${lockStr}${user}"}" : ""
            }
            
            if (settings."unlockLocks${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, unlocking ${settings."unlockLocks${lockStr}${user}"}"
                settings."unlockLocks${lockStr}${user}"?.unlock()
                msg += detailedNotifications ? ", unlocking ${settings."unlockLocks${lockStr}${user}"}" : ""
            }

            if (settings."openGarage${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, opening ${settings."openGarage${lockStr}${user}"}"
                settings."openGarage${lockStr}${user}"?.open()
                msg += detailedNotifications ? ", opening ${settings."openGarage${lockStr}${user}"}" : ""
            }	    
        }

        // Send notifications
        if (i) { // If we have a known user, increment the usage count
            state.codeUseCount[lock.id][i as String] = (state.codeUseCount[lock.id][i as String] ?: 0) + 1
        }
        if (notify && (
            	(notifyModes ? notifyModes?.find{it == location.mode} : true) &&
            	(notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
            ) && (
            	!i || (notifyCount ? (state.codeUseCount[lock.id][i as String] <= notifyCount) : true)
        )) {
            sendNotifications(msg, (settings."userOverrideNotifications${i}" && settings."userNotify${i}") ? i as String : "")
        }
    }
}

def processLockEvent(evt) {
    def data = null
    def lock = locks.find { it.id == evt.lockId }

    log.trace "Processing $lock lock event: $evt"

    def msgs = [] // Message to send
    def lockStr = "" // Individual lock actions
    def user = "" // User slot used
    def i = 0 // Slot used

    if (evt.data) { // Was it locked using a user code
        data = parseJson(evt.data)
    }
    def lockMode = data?.type ?: (data?.method ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically"))
    // Fix for proper grammar and additional lock types mapping
    switch (lockMode) {
        case "manual":
        lockMode = "manually"
        break

        case "rfid":
        lockMode = "via RFID"
        break

        case "bluetooth":
        lockMode = "via bluetooth"
        break

        case "keypad":
        lockMode = "via keypad"
        break

        case "remote":
        case "command":
        lockMode = "remotely"
        break

        case "auto":
        lockMode = "via internal autolock"
        break

        default:
            break
    }

    evt.lockMode = lockMode // Save the lockMode calculated
    evt.data = data // Update the data to be passed
    user = (data?.usedCode as String) ?: "" // get the user if present
    i = (data?.usedCode as Integer) ?: 0 // get the user if present
    log.trace "$lock locked by user $user $lockMode"

    // Check if we have user override unlock actions defined
    if (user && !settings."userOverrideUnlockActions${user}") {
        log.trace "Did not find per user lock actions, falling back to global lock actions"
        user = ""
    }

    // Check if we have individual actions for each lock
    if (settings."individualDoorActions${user}") {
        lockStr = lock as String
    } else {
        lockStr = ""
    }

    if ((["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) }) || (data?.usedCode != null)) { // LOCKED VIA KEYPAD/RFID
        def name = user ? (i == 0 ? "Master Code" : (settings."userNames${i}" ?: "Unknown user")) : "" // Should have a name for the user otherwise it's unknown, 0 is Master Code
        
        // Check if we have a delayed action and process accordingly
        if (settings."delayLockActionsTime${lockStr}${user}") {
            def msg = "$evt.displayName was locked ${name ? "by " + name + " " : ""}$lockMode, running actions in ${settings."delayLockActionsTime${lockStr}${user}"} minutes" // Default message to send
            log.debug msg
            msgs << msg
            evt.sendNotifications = true // Since it's delayed we request notifications be sent
            startTimer(settings."delayLockActionsTime${lockStr}${user}" * 60, processLockActions, evt)
        } else {
            msgs += processLockActions(evt) // Take the message back to send out
        }
    } else { // MANUAL LOCK
        // Check if we have a delayed action and process accordingly
        if (settings."delayLockActionsTimeManual${lockStr}") {
            def msg = "$evt.displayName was locked $lockMode, running actions in ${settings."delayLockActionsTimeManual${lockStr}"} minutes" // Default message to send
            log.debug msg
            msgs << msg
            evt.sendNotifications = true // Since it's delayed we request notifications be sent
            startTimer(settings."delayLockActionsTimeManual${lockStr}" * 60, processLockActions, evt)
        } else {
            msgs += processLockActions(evt) // Take the message back to send out
        }
    }

    // Check if we need to retract a deadbolt lock it was locked while the door was still open
    if (settings."retractDeadbolt${lock}") {
        def sensor = settings."sensor${lock}"
        if (sensor.latestValue("contact") == "open") {
            if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) { // Do not unlock if autolock features on the lock are enabled, avoid infinite loop
                def msg = "Disable AutoLock on $lock lock to avoid an infinite locking/unlocking loop while using the 'Unlock on door open' feature"
                log.warn msg
                msgs << msg
            } else {
                log.debug "$lock was locked while the door was still open, unlocking it in 10 seconds"
                def unlocks = atomicState.unLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                if (!unlocks.contains(lock.id)) { // Don't re add the same lock again
                    //log.trace "Adding ${lock.id} to the list of unlocks"
                    unlocks.add(lock.id) // Atomic to ensure we get upto date info here
                    atomicState.unLocks = unlocks // Set it back, we can't work direct on atomicState
                }
                startTimer(10, unLockDoor) // Schedule the unlock in 10 seconds since the door may have just locked and avoid Z-Wave conflict and some locks like Schlage deadbolt have timing limitations which cause a busy conflict if done too soon
            }
        } else {
            log.trace "$lock was locked while the door was closed, we're good"
        }
    }

    // Last thing to do because it can timeout
    for (msg in msgs) {
        sendNotifications(msg, (settings."userOverrideNotifications${i}" && settings."userNotify${i}") ? i as String : "")
    }
}

def processLockActions(evt) {
    def data = evt.data
    def lock = locks.find { it.id == evt.lockId }
    def msgs = [] // Message to send
    def lockMode = evt.lockMode
    def user = ""
    def arm = "" // Security keypad arm mode (optional)
    def i = 0

    log.trace "Processing $lock lock actions: $evt"

    if ((["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) }) || (data?.usedCode != null)) { // LOCKED VIA KEYPAD/RFID
        def name, notify, notifyCount, notifyModes, notifyXPresence, extLockNotify, extLockNotifyModes, userOverrideActions

        if ((data instanceof org.codehaus.groovy.grails.web.json.JSONObject ? !data?.isNull("usedCode") : (data?.usedCode != null)) && (data?.usedCode >= 0)) { // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442
            i = data.usedCode as Integer

            if (i == 0) {
                name = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
                notify = true // always inform about master users
            } else {
                user = i as String
                name = settings."userNames${i}" ?: "Unknown user" // Should have a name for the user otherwise it's unknown
                notify = settings."userNotify${i}"
                notifyCount = settings."userNotifyUseCount${i}"
                notifyModes = settings."userNotifyModes${i}"
                notifyXPresence = settings."userXNotifyPresence${i}"
                userOverrideActions = settings."userOverrideUnlockActions${i}"

                // Check if we have user override lock actions defined
                if (!userOverrideActions) {
                    log.trace "No user $name specific lock action found, falling back to global actions"
                    user = "" // We don't have a user specific action defined, fall back to global actions
                }
            }
        } else {
            log.trace "No usercode found in extended data for external user lock"
        }

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions${user}") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        extLockNotify = settings."externalLockNotify${lockStr}"
        extLockNotifyModes = settings."externalLockNotifyModes${lockStr}"

        log.trace "Lock $evt.displayName locked by $name, user notify $notify, notify count: $notifyCount, user notify modes $notifyModes, notify NOT present $notifyXPresence, external notify $extLockNotify, external notify modes $extLockNotifyModes, user override action $userOverrideActions, Source type: $lockMode"

        def msg = evt.sendNotifications ? "Completing lock actions for $evt.displayName" : "$evt.displayName was locked ${name ? "by " + name + " " : ""}$lockMode" // Default message to send

        if (settings."runXPeopleLockActions${lockStr}${user}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleLockActions${lockStr}${user}"?.find{it.currentPresence == "present"}} is present, not running lock actions for door $lock"
        } else if (settings."runXModeLockActions${lockStr}${user}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running lock actions for door $lock"
        } else {
            // If we have a specific mode passed by the keypad lets use that otherwise use configured options
                        if (data instanceof org.codehaus.groovy.grails.web.json.JSONObject ? !data?.isNull("armMode") : (data?.armMode != null)) { // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442
                switch (data.armMode) { // Check for custom keypad arm actions
                    case "armedStay":
                    	if (settings."keypadArmActions${lockStr}${user}${"stay"}") {
                            log.debug "Running custom actions for keypad stay/partial button"
                            arm = "stay"
                        }
                        break
                        
                    case "armedNight":
                    	if (settings."keypadArmActions${lockStr}${user}${"night"}") {
                            log.debug "Running custom actions for keypad night button"
                            arm = "night"
                        }
                        break
                        
                    case "armedAway":
                    	if (settings."keypadArmActions${lockStr}${user}${"away"}") {
                            log.debug "Running custom actions for keypad away/on button"
                            arm = "away"
                        }
                        break
                        
                    default:
                        log.warn "Invalid keypad Arm mode detected: ${data.armMode}"
                    	msg += ", invalid keypad Arm mode ${data.armMode}"
                        break                        
                }
            }

            if (settings."keypadArmDisarm${lockStr}${user}" && (data instanceof org.codehaus.groovy.grails.web.json.JSONObject ? !data?.isNull("armMode") : (data?.armMode != null))) { // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442
                switch (data.armMode) { // Set Keypad lock state
                    case "armedStay":
                    case "armedNight":
                    	log.info "Arming Smart Home Monitor to Stay"
                        sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Stay" : ""
                        try {
                            if (settings."adtDevices") {
                                log.info "Arming ADT to Stay"
                                settings."adtDevices"?.armStay('armedStay')
                                msg += detailedNotifications ? ", Arming ADT to Stay" : ""
                            }
                        } catch (e) { // This is still not official so lets be cautious about it
                            log.error "Error arming ADT to Stay\n$e"
                            msg += ", error arming ADT to Stay"
                        }
                    	break
                    
                    case "armedAway":
                    	log.info "Arming Smart Home Monitor to Away"
                        sendLocationEvent(name: "alarmSystemStatus", value: "away")
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Away" : ""
                    	try {
                            if (settings."adtDevices") {
                                log.info "Arming ADT to Away"
                                settings."adtDevices"?.armAway('armedAway')
                                msg += detailedNotifications ? ", Arming ADT to Away" : ""
                            }
                        } catch (e) { // This is still not official so lets be cautious about it
                            log.error "Error arming ADT to Away\n$e"
                            msg += ", error arming ADT to Away"
                        }
                    	break
                        
                    default:
                        log.warn "Invalid SHM mode detected: ${data.armMode}"
                    	msg += ", invalid Smart Home Monitor mode ${data.armMode}"
                        break
                }
            } else {
                if (settings."homeArm${lockStr}${user}") {
                    if (settings."homeArmStay${lockStr}${user}") {
                        log.info "Arming Smart Home Monitor to Stay"
                        sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Stay" : ""
                    } else {
                        log.info "Arming Smart Home Monitor to Away"
                        sendLocationEvent(name: "alarmSystemStatus", value: "away")
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Away" : ""
                    }
                }
                
                try {
                    if (settings."adtArm${lockStr}${user}" && settings."adtDevices") {
                        if (settings."homeArmStay${lockStr}${user}") {
                            log.info "Arming ADT to Stay"
                            settings."adtDevices"?.armStay('armedStay')
                            msg += detailedNotifications ? ", Arming ADT to Stay" : ""
                        } else {
                            log.info "Arming ADT to Away"
                            settings."adtDevices"?.armAway('armedAway')
                            msg += detailedNotifications ? ", Arming ADT to Away" : ""
                        }
                    }
                } catch (e) { // This is still not official so lets be cautious about it
                    log.error "Error arming ADT\n$e"
                    msg += ", error arming ADT"
                }
            }

            if (settings."externalLockMode${lockStr}${user}${arm}") {
                log.info "Changing mode to ${settings."externalLockMode${lockStr}${user}${arm}"}"
                if (location.modes?.find{it.name == settings."externalLockMode${lockStr}${user}${arm}"}) {
                    setLocationMode(settings."externalLockMode${lockStr}${user}${arm}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."externalLockMode${lockStr}${user}${arm}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."externalLockMode${lockStr}${user}${arm}"}" : ""
            }

            if (settings."externalLockPhrase${lockStr}${user}${arm}") {
                log.info "Running $lock specific locked Phrase ${settings."externalLockPhrase${lockStr}${user}${arm}"} for ${name ?: "external lock"}"
                location.helloHome.execute(settings."externalLockPhrase${lockStr}${user}${arm}")
                msg += detailedNotifications ? ", running ${settings."externalLockPhrase${lockStr}${user}${arm}"}" : ""
            } else {
                log.trace "No individual routine configured to run when locked $lockMode for $lock"
            }

            if (settings."externalLockTurnOnSwitches${lockStr}${user}${arm}") {
                log.info "$evt.displayName was locked successfully, turning on switches ${settings."externalLockTurnOnSwitches${lockStr}${user}${arm}"}"
                settings."externalLockTurnOnSwitches${lockStr}${user}${arm}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."externalLockTurnOnSwitches${lockStr}${user}${arm}"}" : ""
            }

            if (settings."externalLockTurnOffSwitches${lockStr}${user}${arm}") {
                log.info "$evt.displayName was locked successfully, turning off switches ${settings."externalLockTurnOffSwitches${lockStr}${user}${arm}"}"
                settings."externalLockTurnOffSwitches${lockStr}${user}${arm}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."externalLockTurnOffSwitches${lockStr}${user}${arm}"}" : ""
            }
            
            if (settings."lockLocks${lockStr}${user}${arm}") {
                log.info "$evt.displayName was locked successfully, locking ${settings."lockLocks${lockStr}${user}${arm}"}"
                settings."lockLocks${lockStr}${user}${arm}"?.lock()
                msg += detailedNotifications ? ", locking ${settings."lockLocks${lockStr}${user}${arm}"}" : ""
            }

            if (settings."closeGarage${lockStr}${user}${arm}") {
                log.info "$evt.displayName was locked successfully, closing garage ${settings."closeGarage${lockStr}${user}${arm}"}"
                settings."closeGarage${lockStr}${user}${arm}"?.close()
                msg += detailedNotifications ? ", closing garage ${settings."closeGarage${lockStr}${user}${arm}"}" : ""
            }
        }

        // Send a notification if required (message would be updated)
        if (i) { // If we have a known user, increment the usage count
            state.codeUseCount[lock.id][i as String] = (state.codeUseCount[lock.id][i as String] ?: 0) + 1
        }
        if ((notify && (
            	(notifyModes ? notifyModes?.find{it == location.mode} : true) &&
            	(notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
            ) && (
            	!i || (notifyCount ? (state.codeUseCount[lock.id][i as String] <= notifyCount) : true)
        )) ||
            (!i && extLockNotify && (extLockNotifyModes ? extLockNotifyModes.find{it == location.mode} : true))) {
            msgs << msg
        }
    } else { // MANUAL LOCK
        log.trace "Lock $evt.displayName locked manually, Source type: $lockMode"

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        def msg = evt.sendNotifications ? "Completing lock actions for $evt.displayName" : "$evt.displayName was locked $lockMode" // Default message to send

        if (settings."runXPeopleLockActionsManual${lockStr}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleLockActionsManual${lockStr}"?.find{it.currentPresence == "present"}} is present, not running lock actions for door $lock"
        } else if (settings."runXModeLockActionsManual${lockStr}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running lock actions for door $lock"
        } else {
            if (settings."homeArmManual${lockStr}") {
                log.info "Arming Smart Home Monitor to Stay"
                sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                msg += detailedNotifications ? ", Arming Smart Home Monitor to Stay" : ""
            }

            try {
                if (settings."adtArmManual${lockStr}" && settings."adtDevices") {
                    log.info "Arming ADT to Stay"
                    settings."adtDevices"?.armStay('armedStay')
                    msg += detailedNotifications ? ", Arming ADT to Stay" : ""
                }
            } catch (e) { // This is still not official so lets be cautious about it
                log.error "Error arming ADT to Stay\n$e"
                msg += ", error arming ADT to Stay"
            }

            if (settings."externalLockModeManual${lockStr}") {
                log.info "Changing mode to ${settings."externalLockModeManual${lockStr}"}"
                if (location.modes?.find{it.name == settings."externalLockModeManual${lockStr}"}) {
                    setLocationMode(settings."externalLockModeManual${lockStr}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."externalLockModeManual${lockStr}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."externalLockModeManual${lockStr}"}" : ""
            }

            if (settings."externalLockPhraseManual${lockStr}") {
                log.info "Running $lock specific locked Phrase ${settings."externalLockPhraseManual${lockStr}"} for ${name ?: "external lock"}"
                location.helloHome.execute(settings."externalLockPhraseManual${lockStr}")
                msg += detailedNotifications ? ", running ${settings."externalLockPhraseManual${lockStr}"}" : ""
            } else {
                log.trace "No individual routine configured to run when locked $lockMode for $lock"
            }

            if (settings."externalLockTurnOnSwitchesManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, turning on switches ${settings."externalLockTurnOnSwitchesManual${lockStr}"}"
                settings."externalLockTurnOnSwitchesManual${lockStr}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."externalLockTurnOnSwitchesManual${lockStr}"}" : ""
            }

            if (settings."externalLockTurnOffSwitchesManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, turning off switches ${settings."externalLockTurnOffSwitchesManual${lockStr}"}"
                settings."externalLockTurnOffSwitchesManual${lockStr}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."externalLockTurnOffSwitchesManual${lockStr}"}" : ""
            }

            if (settings."lockLocksManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, locking ${settings."lockLocksManual${lockStr}"}"
                settings."lockLocksManual${lockStr}"?.lock()
                msg += detailedNotifications ? ", locking ${settings."lockLocksManual${lockStr}"}" : ""
            }

            if (settings."closeGarageManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, closing garage ${settings."closeGarageManual${lockStr}"}"
                settings."closeGarageManual${lockStr}"?.close()
                msg += detailedNotifications ? ", closing garage ${settings."closeGarageManual${lockStr}"}" : ""
            }
        }

        // Send notitications for manual and electronic locking only, keypad is handled above with lock actions
        if (settings."lockNotify${lockStr}" && (!(["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) })) && (settings."lockNotifyModes${lockStr}" ? settings."lockNotifyModes${lockStr}".find{it == location.mode} : true)) {
            msgs << msg
        }
    }
    
    // Check if we are asked to send the notifications or return them back
    if (evt.sendNotifications) {
        // Last thing to do because it can timeout
        for (msg1 in msgs) {
            sendNotifications(msg1, (settings."userOverrideNotifications${i}" && settings."userNotify${i}") ? i as String : "")
        }
    } else {
        return msgs
    }
}

// Heartbeat system to ensure that the MonitorTask doesn't die when it's supposed to be running
def heartBeatMonitor() {
    log.trace "Heartbeat monitor called"

    state.lastHeartBeat = now() // Save the last time we were executed

    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion != clientVersion()) {
        def msg = "NOTE: ${app.label} detected a code upgrade. Updating configuration, please open the app and click on Save to re-validate your settings"
        log.warn msg
        startTimer(1, appTouch) // Reinitialize the app offline to avoid a loop as appTouch calls codeCheck
        sendNotifications(msg) // Do this in the end as it may timeout
        return
    }
}

def startTimer(seconds, function, dataMap = null) {
    log.trace "Scheduled to run $function in $seconds seconds${dataMap ? " with data $dataMap" : ""}"

    //def runTime = new Date(now() + ((Long)seconds * 1000)) // for runOnce
    //runOnce(runTime, function, [overwrite: true]) // runIn isn't reliable, runOnce is more reliable but isn't as accurate
    if (dataMap) {
        runIn(seconds, function, [overwrite: true, data: dataMap]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
    } else {
        runIn(seconds, function, [overwrite: true]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
    }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private void sendNotifications(message, user = "") {
	if (!message) {
		return
    }
    
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, settings."recipients${user}")
    } else {
        if (!settings."disableAllNotify${user}") {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (settings."sms${user}") {
            sendText(settings."sms${user}", message)
        }
    }
    if (settings."audioDevices${user}") {
        settings."audioDevices${user}"*.playTextAndResume(message)
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "User Unlock Lock Door Notifications and Actions"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (updateNotifications != false) { // The default true may not be registered
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def devices = locks?.findAll { it.hasAttribute("codeVersion") }
                for (device in devices) {
                    if (device) {
                        def deviceName = device?.currentValue("dhName")
                        def deviceVersion = ret.data?."$deviceName"
                        if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                            def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                            log.info msg
                            if (updateNotifications != false) { // The default true may not be registered
                                sendPush(msg)
                            }
                        } else {
                            log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}

// THIS IS THE END OF THE FILE