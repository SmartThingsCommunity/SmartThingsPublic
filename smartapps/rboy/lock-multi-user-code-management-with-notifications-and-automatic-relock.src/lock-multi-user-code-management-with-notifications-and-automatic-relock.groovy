/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "4.3.1"
}

/**
 * Add and remove multiple user codes for locks with Scheduling and notification options and local actions
 *
 * Copyright RBoy
 * Redistribution of any changes or code is not allowed without permission
 *
 * Change Log:
 * 2016-4-20 - Added client version on main page
 * 2016-4-8 - Added support for notification modes for unlocking (and improved UI)
 * 2016-4-8 - Bugfix for jammed and manual lock notifications not coming
 * 2016-3-21 - Added a heartbeat system to improve the reliability of the code check scheduler to compensate for the issues folks are seeing with the ST platform broken timers
 * 2016-2-27 - Renamed option to retry to clarify, now it is to stop reverrification and overwriting all codes (default is incremental updates)
 * 2016-2-25 - Added support for tracking deleted codes confirmation from lock and retrying if lock doesn't confirm code deletions
 * 2016-2-20 - Added slot notification for unknown users
 * 2016-2-15 - Added current date/time stamp on hub for debugging timezone mismatches
 * 2016-2-15 - Default coding interval is now 60 seconds as the platform is crapping out in shorter intervals
 * 2016-2-15 - Revamped code initialization to work around crappy ST timers and make programming more reliable. Using dual programming strategy now to make it more redundant
 * 2016-1-23 - Added user specific unlock actions (override actions)
 * 2016-1-19 - Fixed a debug error message about empty slots sharing a null code
 * 2016-1-19 - Added comments
 * 2016-1-17 - You can specify multiple sms phone numbers by putting a + to separate them
 * 2016-1-15 - Validation check, same code cannot be used for more than one user
 * 2016-1-13 - Debug message
 * 2016-1-10 - Added option to disable retrying code programming on failure
 * 2016-1-5 - Revamped code to verify with lock that codes have been successfully added and keep retrying until codes have been added
 * 2015-12-18 - Added subcription to random events to kick start timers to work around buggy platform, use runEveryXMinutes where possible to hopefully improve the situation
 * 2015-12-8 - Comment clarifications
 * 2015-12-2 - Clean up
 * 2015-11-28 - Added a delay to locking multiple doors to avoid mesh collisions
 * 2015-11-28 - Use atomicState for automatic relocking to avoid race conditions
 * 2015-11-28 - Select Door sensor independent of relock
 * 2015-11-27 - Added support to relock doors after they have been closed with an optional delay timer and to retract deadbolts if door is open
 * 2015-11-25 - Refresh the page after selecting the locks to that the individual options show up
 * 2015-11-24 - Added support to show expired codes on configuration page
 * 2015-11-22 - Added support for differentiate between manual lock and electronic lock (keypad/remote) while notifying user
 * 2015-11-22 - Clarified input text for turning on lights after dark
 * 2015-11-21 - Added support for individual door unlock actions
 * 2015-11-21 - Added support to turn on lights 30 minutes before sunset (dark)
 * 2015-11-21 - Added support to send notitications when too many invalid codes are reported by the lock
 * 2015-11-21 - Added option 'Inactive' to the list of code types so one can keep the name/code on the slot but not have it active
 * 2015-11-8 - Added option to switch on lights after dark (sunset to next sunrise)
 * 2015-10-28 - Optimized disarming SHM as the first action on unlocking to help avoid false alarms
 * 2015-10-26 - Added error checking for empty codes
 * 2015-10-26 - Fixed a bug with one time codes
 * 2015-10-26 - Added support for start date/time for expiration codes
 * 2015-10-26 - Improved reliability when controlling multiple locks with a single app instance
 * 2015-9-28 - Added support for lock notifications
 * 2015-9-26 - Added support to turn on/off switches when a user unlocks the door with a code
 * 2015-9-26 - Fixed a bug with mode changes when unlocking
 * 2015-9-18 - Added option to disarm Smart Home Monitor mode when unlocking, added option to select modes when notifying on manual unlock
 * 2015-9-2 - Fixed issue, don't run home phrase or change mode on manual unlock
 * 2015-9-1 - Improve text clarity
 * 2015-8-26 - Added support for running a phrase and changing modes when doors are unlocked successfully
 * 2015-7-25 - Potential fix for preventing the timers from dying
 * 2015-7-23 - Fix for monitoring not working after a mode change
 * 2015-7-22 - Added support for advanced scheduling options for individual users codes including permanent, one time, expiration and scheduled
 * 2015-7-22 - Use the standard "unknown" lock state to check for jammed
 * 2015-7-6 - Fixed issue with code expiry not working
 * 2015-6-18 - Added option to change delay between sending codes for users who have issues with communications
 * 2015-6-18 - Added notification for jammed door locks
 * 2015-6-17 - Fix for dynamic preferences not working after ST platform update
 * 2015-6-9 - Added support to disable push notifications only
 * 2015-5-27 - Added support for expiration dates
 * 2015-2-20 - Fixed issue with SMS not being sent
 * 2015-1-9 - Improve reliability with coding
 * 2015-1-1 - Created
 *
 */

definition(
		name: "Lock multi user code management with notifications and automatic relock",
		namespace: "rboy",
		author: "RBoy",
		description: "Add and Delete Multiple User Codes for Locks with Scheduling and Notifications",
		category: "Safety & Security",
		iconUrl: "https://s3.amazonaws.com/smartapp-icons/Allstate/lock_it_when_i_leave.png",
		iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Allstate/lock_it_when_i_leave@2x.png"
	  )

import groovy.json.JsonSlurper

preferences {
	page(name: "setupApp")
    page(name: "usersPage")
    page(name: "unlockActionsPage")
    page(name: "relockDoorPage")
}

def setupApp() {
	log.trace "$settings"
    
    dynamicPage(name: "setupApp", title: "Lock User Management v${clientVersion()}", install: false, uninstall: true, nextPage: "usersPage") {    
        section("Select Lock(s)") {
            input "locks","capability.lock", title: "Lock", multiple: true, submitOnChange: true
        }

		section("How many Users do you want to manage (common to all selected locks)?") {
        	input name: "maxUserNames", title: "Max users", type: "number", required: true, multiple: false
        }

        section {
            // Unlock actions for all users (global)
            def hrefParams = [
                user: null, 
                passed: true 
            ]
            href(name: "unlockActions", params: hrefParams, title: "Click here to define actions when the user unlocks the door successfully", page: "unlockActionsPage", description: "", required: false)
            href(name: "relockDoor", title: "Click here to automatically lock/unlock the door based on events", page: "relockDoorPage", description: "", required: false)
        }

        section([mobileOnly:true]) {
			label title: "Assign a name for this SmartApp", required: false
		}

		section("Code Programming Options (advanced) (optional)") {
            paragraph "By default, for security purposes, the app rewrites all codes on the lock and re-verfies them each time the app is opened. If your SmartThings setup is working reliably and you update codes often you can enable this option to only update the codes which have changed to save programming time and battery. This option will also disable the re-verification feature."
            input name: "disableRetry", title: "Enable incremental updates only and disable re-verification", type: "bool", required: false
            paragraph "Change this setting if all the user codes aren't being programmed on the lock correctly. This settings determines the time gap between sending each user code to the lock. If the codes are sent too fast, they may fail to be set properly."
            input name: "sendDelay", title: "Delay between codes (seconds):", type: "number", defaultValue: "60", required: false
        }
    }
}

def relockDoorPage() {
    dynamicPage(name:"relockDoorPage", title: "Select door open/close sensor for each door and configure the automatic unlock and relock of the door", uninstall: false, install: false) {
        section {
            for (lock in locks) {
                def priorRelockDoor = settings."relockDoor${lock}"
                def priorRelockImmediate = settings."relockImmediate${lock}"
                def priorRelockAfter = settings."relockAfter${lock}"
                def priorRetractDeadbolt = settings."retractDeadbolt${lock}"

                paragraph "\r\n"
                paragraph "Configure ${lock}"
                if (priorRelockDoor || priorRetractDeadbolt) {
                    input "sensor${lock}", "capability.contactSensor", title: "Door open/close sensor", required: true
                }
                
                input name: "relockDoor${lock}", type: "bool", title: "Relock door automatically after closing", defaultValue: priorRelockDoor, required: true, submitOnChange: true
                if (priorRelockDoor) {
                    input name: "relockImmediate${lock}", type: "bool", title: "Relock immediately", defaultValue: priorRelockImmediate, required: true, submitOnChange: true
                    if (!priorRelockImmediate) {
                        input name: "relockAfter${lock}", type: "number", title: "Relock after (minutes)", defaultValue: priorRelockAfter, required: true                   
                    }
                }
                
                paragraph "Use this if you want to automatically retract the deadbolt (unlock) if it accidentally extends (locks) while the door is still open. This can avoid damage to the door frame."
                input name: "retractDeadbolt${lock}", type: "bool", title: "Unlock door if locked while open", defaultValue: priorRetractDeadbolt, required: true, submitOnChange: true
            }
        }
    }
}

def unlockActionsPage(params) {
	//  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = atomicState.params?.user ?: ""
	def name = user ? settings."userNames${user}" : ""
    
    log.trace "Unlock Action Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockActionsPage", title: "Setup unlock actions for each door" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()*.label
        def showActions = true
        if (phrases) {
            phrases.sort()
            section {
            	if (user) { // User specific override options
                	paragraph "Enabling user specific unlock actions will override over any general unlock actions defined on the first page"
                    input "userOverrideUnlockActions${user}", "bool", title: "Define specific unlock actions for $name", required: true,  submitOnChange: true
                    if (!settings."userOverrideUnlockActions${user}") { // Check if user has enabled specific override actions then show menu
                    	showActions = false
                    }
                }
                if  (showActions && locks?.size() > 1) {
                    input "individualDoorActions${user}", "bool", title: "Separate unlock actions for each door", required: true,  submitOnChange: true
                }
            }
            if (showActions) { // Do we need to show actions?
                if (settings."individualDoorActions${user}") {
                    for (lock in locks) {
                        section ("Door Unlock Actions for $lock (optional)") {
                            def priorHomePhrase = settings."homePhrase${lock}${user}"
                            def priorHomeMode = settings."homeMode${lock}${user}"
                            def priorHomeDisarm = settings."homeDisarm${lock}${user}"

                            paragraph "Run these routines and/or change the mode when a user successfully unlocks the door $lock"
                            input "homePhrase${lock}${user}", "enum", title: "Run Routine", required: false, options: phrases, defaultValue: priorHomePhrase
                            input "homeMode${lock}${user}", "mode", title: "Change Mode To", required: false, multiple: false, defaultValue: priorHomeMode
                            input "homeDisarm${lock}${user}", "bool", title: "Disarm Smart Home Monitor", required: false, defaultValue: priorHomeDisarm

                            paragraph "Turn on these lights after dark when a user successfully unlocks the door $lock"
                            input "turnOnSwitchesAfterSunset${lock}${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true

                            paragraph "Turn on and/or off these switches/lights when a user successfully unlocks the door $lock"
                            input "turnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                            input "turnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
                        }
                    }
                } else {
                    section("Door Unlock Actions (optional)") {
                        paragraph "Run these routines and/or change the mode when a user successfully unlocks the door"
                        input "homePhrase${user}", "enum", title: "Run Routine", required: false, options: phrases
                        input "homeMode${user}", "mode", title: "Change Mode To", required: false, multiple: false
                        input "homeDisarm${user}", "bool", title: "Disarm Smart Home Monitor", required: false

                        paragraph "Turn on these lights after dark when a user successfully unlocks the door"
                        input "turnOnSwitchesAfterSunset${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true

                        paragraph "Turn on and/or off these switches/lights when a user successfully unlocks the door"
                        input "turnOnSwitches${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                        input "turnOffSwitches${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
                    }
                }
            }
        }
    }
}

def usersPage() {
	dynamicPage(name:"usersPage", title: "User Names, Codes and Notification Setup", uninstall: true, install: true) {

	section("Notification Options") {
    	paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '+'. E.g. 5551234567+4447654321"
        input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
        paragraph "Enable the below option if you DON'T want push notifications on your SmartThings phone app. This does not impact the SMS notifications."
        input name: "disableAllNotify", title: "Disable all push notifications", type: "bool", defaultValue: "false", required: true
    }
	
    section("Jammed Lock") {
    	input name: "jamNotify", title: "Notify on Lock Jam/Stuck", type: "bool"
    }

    section("Manual Unlock") {
    	paragraph "Get notifications when the door is unlocked manually (inside or outside)"
    	input name: "manualNotify", title: "Notify on Manual Unlock", type: "bool", submitOnChange: true
        if (manualNotify) {
            input name: "manualNotifyModes", type: "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
        }
    }

    section("Lock") {
    	paragraph "Get notifications when the door is locked (manually or automatically)"
    	input name: "lockNotify", title: "Notify on Lock", type: "bool", submitOnChange: true
        if (lockNotify) {
            input name: "lockNotifyModes", type: "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
        }
    }

	for (int i = 1; i <= settings.maxUserNames; i++) {
            def priorName = settings."userNames${i}"
            def priorCode = settings."userCodes${i}"
            def priorNotify = settings."userNotify${i}"
            def priorNotifyModes = settings."userNotifyModes${i}"
            def priorExpireDate = settings."userExpireDate${i}"
            def priorExpireTime = settings."userExpireTime${i}"
            def priorStartDate = settings."userStartDate${i}"
            def priorStartTime = settings."userStartTime${i}"
            def priorUserType = settings."userType${i}"
            def priorUserDayOfWeek = settings."userDayOfWeekA${i}"
            def priorUserStartTime = settings."userStartTimeA${i}"
            def priorUserEndTime = settings."userEndTimeA${i}"
            log.debug "Initial $i Name: $priorName, Code: $priorCode, Notify: $priorNotify, NotifyModes: $priorNotifyModes, ExpireDate: $priorExpireDate, ExpireTime: $priorExpireTime, StartDate: $priorStartDate, StartTime: $priorStartTime, UserType: $priorUserType, UserDayOfWeek: $priorUserDayOfWeek, UserStartTime: $userStartTime, UserEndTime: $userEndTime"

			// Check for errors and display messages
            section("User Management Slot #${i}") {
            	// Sanity check, codes cannot be reused in the same lock (codes have to be unique to the same slot
                for (int j = 1; j <= settings.maxUserNames; j++) {
                	if (priortCode && (i != j) && (priorCode == settings."userCodes${j}")) {
                        log.warn "CHANGE CODE FOR USER $i - THIS CODE HAS BEEN USED FOR USER $j"
                        paragraph "CHANGE CODE - THIS CODE HAS BEEN USED FOR USER $j"
                    }
                }
            
            	// Sanity check for expiration date formats
                switch (priorUserType) {
                	case 'Expire on':
                    	def invalidDate = true
                        
                        if (priorExpireDate) {
                            log.debug "Found expiry date in setup"
                            try {
                                Date.parse("yyyy-MM-dd", priorExpireDate)
                                invalidDate = false
                            }
                            catch (Exception e) {
                                log.debug "Invalid expiry date in setup"
                                invalidDate = true
                            }
                        }
                        if (priorStartDate) {
                            log.debug "Found start date in setup"
                            try {
                                Date.parse("yyyy-MM-dd", priorStartDate)
                                invalidDate = false
                            }
                            catch (Exception e) {
                                log.debug "Invalid start date in setup"
                                invalidDate = true
                            }
                        }
                        
                        if (invalidDate == true) {
                            paragraph "INVALID DATE - PLEASE CHECK YOUR DATE FORMAT"
                        } else {
                            if (priorExpireDate) {
                            	if (priorExpireTime) {
                                    def midnightToday = timeToday("2000-01-01T00:00:00.000-0000", location.timeZone)
                                    String dst = location.timeZone.getDisplayName(location.timeZone.inDaylightTime(new Date(now())), TimeZone.SHORT) // Keep current timezone
                                    def expT = (timeToday(priorExpireTime, location.timeZone).time - midnightToday.time)
                                    def expD = Date.parse("yyyy-MM-dd Z", priorExpireDate + " " + dst).toCalendar()
                                    def exp = expD.getTimeInMillis() + expT
                                    def expStr = (new Date(exp)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
                                    if (exp < now()) {
                                        paragraph "Code EXPIRED!"
                                    } else {
		                                paragraph "Code will expire on ${expStr}"
                                    }
                                } else {
	                                paragraph "PLEASE ENTER EXPIRE TIME"
                                }
                                if (priorStartDate) {
                                    def sd = Date.parse("yyyy-MM-dd", priorStartDate)
                                    paragraph "Code will be active on ${sd.format("EEE MMM dd yyyy")}"
                                    if (!priorStartTime) {
                                        paragraph "PLEASE ENTER START TIME"
                                    }
                                }
                            } else {
                                paragraph "PLEASE ENTER EXPIRE DATE"
                            }
                        }
                        break
                        
                	case 'One time':
                        if (state.trackUsedOneTimeCodes?.contains(i as String)) {
                            paragraph "One time code USED!"
                        }
                        break
                        
                    default:
                    	break
                }

                // User and code details/types
				if (priorCode) {
                    input name: "userNames${i}", description: "${priorName}", title: "Name", defaultValue: priorName, type: "text", multiple: false, required: false
                    input name: "userCodes${i}", description: "${priorCode}", title: "Code", defaultValue: priorCode, type: "text", multiple: false, required: false, submitOnChange: true
                    input name: "userNotify${i}", title: "Notify on unlock", defaultValue: priorNotify, type: "bool", submitOnChange: true
                    if (settings."userNotify${i}") {
                        input name: "userNotifyModes${i}", type: "mode", title: "Only when in this mode(s) (optional)", defaultValue: priorNotifyModes, required: false, multiple: true
                    }
                    input name: "userType${i}",
                        type: "enum",
                        title: "Select User Type",
                        required: true,
                        multiple: false,
                        options: codeOptions(),
                        defaultValue: priorUserType,
                        submitOnChange: true
                } else {
                    input name: "userNames${i}", description: "Tap to set", title: "Name", type: "text", multiple: false, required: false
                    input name: "userCodes${i}", description: "Tap to set", title: "Code", type: "text", multiple: false, required: false
                    input name: "userNotify${i}", title: "Notify on unlock", type: "bool", submitOnChange: true
                    if (settings."userNotify${i}") {
                        input name: "userNotifyModes${i}", type: "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                    }
                    input name: "userType${i}",
                        type: "enum",
                        title: "Select User Type",
                        required: true,
                        multiple: false,
                        options: codeOptions(),
                        defaultValue: 'Permanent',
                        submitOnChange: true
                }
                
                // Expiration/Scheduling options
                switch (priorUserType) {
                	case 'Expire on':
                        if (priorStartDate) { // Start Date/Time is optional
                            input name: "userStartDate${i}", title: "Code start date (YYYY-MM-DD) (optional)", description: "Date on which the code should be enabled",  defaultValue: priorStartDate, type: "date", required: false,  submitOnChange: true
                        } else {
                            input name: "userStartDate${i}", title: "Code start date (YYYY-MM-DD) (optional)", description: "Date on which the code should be enabled", type: "date", required: false,  submitOnChange: true
                        }

                        if (priorStartTime) {
                            input name: "userStartTime${i}", title: "Code start time (optional)", description: "(Touch here to set time) The code would be enabled within 5 minutes of this time", defaultValue: priorStartTime, type: "time", required: false,  submitOnChange: true
                        } else {
                            input name: "userStartTime${i}", title: "Code start time (optional)", description: "(Touch here to set time) The code would be enabled within 5 minutes of this time", type: "time", required: false,  submitOnChange: true
                        }

                    	if (priorExpireDate) {
                            input name: "userExpireDate${i}", title: "Code expiration date (YYYY-MM-DD)", description: "Date on which the code should be deleted",  defaultValue: priorExpireDate, type: "date", required: true,  submitOnChange: true
                        } else {
                            input name: "userExpireDate${i}", title: "Code expiration date (YYYY-MM-DD)", description: "Date on which the code should be deleted", type: "date", required: true,  submitOnChange: true
                        }

                        if (priorExpireTime) {
                            input name: "userExpireTime${i}", title: "Code expiration time", description: "(Touch here to set time) The code would be deleted within 5 minutes of this time", defaultValue: priorExpireTime, type: "time", required: true,  submitOnChange: true
                        } else {
                            input name: "userExpireTime${i}", title: "Code expiration time", description: "(Touch here to set time) The code would be deleted within 5 minutes of this time", type: "time", required: true,  submitOnChange: true
                        }
                        break
                        
                    case 'Scheduled':
                        input "userStartTimeA${i}", "time", title: "Start Time", required: false
                        input "userEndTimeA${i}", "time", title: "End Time", required: false
                        input name: "userDayOfWeekA${i}",
                            type: "enum",
                            title: "Which day of the week?",
                            required: true,
                            multiple: true,
                            options: [
                                'All Week',
                                'Monday to Friday',
                                'Saturday & Sunday',
                                'Monday',
                                'Tuesday',
                                'Wednesday',
                                'Thursday',
                                'Friday',
                                'Saturday',
                                'Sunday'
                            ],
                            defaultValue: priorUserDayOfWeek
                    	break
                    
                    default:
	                    break
                }
                
                // Unlock actions for each user
                def hrefParams = [
                    user: i as String, 
                    passed: true 
                ]
                href(name: "unlockActions", params: hrefParams, title: "Click here to define unlock actions for ${settings."userNames${i}"}", page: "unlockActionsPage", description: "", required: false)
            }
        } 
	} 
}

def codeOptions() {
    def ret = [
        "Permanent",
        "One time",
        "Expire on",
        "Scheduled",
        "Inactive"
    ]

    return ret
}

def installed()
{
	log.debug "Install Settings: $settings"
	appTouch()
}

def updated()
{
	log.debug "Update Settings: $settings"
	appTouch()
}

def appTouch() {
	unschedule() // clear all pending updates
    unsubscribe()
    
    // Sanity check for codes
    for (int i = 1; i <= settings.maxUserNames; i++) {
        def name1 = settings."userNames${i}"
        def code1 = settings."userCodes${i}"
        for (int j = 1; j <= settings.maxUserNames; j++) {
            def name2 = settings."userNames${j}"
            def code2 = settings."userCodes${j}"
            if (code1 && (i != j) && (code1 == code2)) { // Don't print error on null codes
                log.error "CODE CONFLICT LOCK PROGRAMMING MAY FAIL - USER $name1 IN SLOT $i and USER $name2 IN SLOT $j SHARE THE SAME CODE $code1.\r\nMULTIPLE USERS CANNOT HAVE THE SAME CODE!!"
                sendPush("CODE CONFLICT LOCK PROGRAMMING MAY FAIL - USER $name1 IN SLOT $i and USER $name2 IN SLOT $j SHARE THE SAME CODE $code1.\r\nMULTIPLE USERS CANNOT HAVE THE SAME CODE!!")
                if (sms) {
                    sendText(sms, "CODE CONFLICT LOCK PROGRAMMING MAY FAIL - USER $name1 IN SLOT $i and USER $name2 IN SLOT $j SHARE THE SAME CODE $code.\r\nMULTIPLE USERS CANNOT HAVE THE SAME CODE!!")
                }
            }
        }
    }

    // subscribe to random events to kick start timers again due to buggy platform killing the timers after a while
    subscribe(location, "mode", changeHandler)
    subscribe(location, "position", changeHandler)
    subscribe(location, "sunset", changeHandler)
    subscribe(location, "sunrise", changeHandler)
    subscribe(location, "routineExecuted", changeHandler)

    subscribe(locks, "lock", lockHandler) // Subscribe to lock events to take action as defined as user
    subscribe(locks, "codeReport", codeResponse, [filterEvents:false]) // Subscribe to code report events to see if the code update was successful
    subscribe(locks, "codeChanged", codeResponse, [filterEvents:false]) // Subscribe to code report events to see if the code update was successful

    // Reset the code update trackers and heartbeat system
    state.lastCheck = 0
    state.lastHeartBeat = 0
    
    locks.each { lock -> // check each lock individually
        if (settings."sensor${lock}") {
        	log.trace "Subscribing to sensor ${settings."sensor${lock}"} for ${lock}"
        	subscribe(settings."sensor${lock}", "contact.closed", sensorHandler)
        }
        if (lock.hasAttribute('invalidCode')) {
            log.trace "Found attribute 'invalidCode' on lock $lock, enabled support for invalid code detection"
            subscribe(lock, "invalidCode", lockHandler)
        }
    }
    
    state.usedOneTimeCodes = [:]
    state.trackUsedOneTimeCodes = [] // Track for reporting purposes
    state.programmedCodes = [:] // List of active codes confirmed by locks
    state.updateLockList = []
    state.expiredLockList = []
    atomicState.reLocks = [] // List of lock to relock after a timed delay
    atomicState.immediateLocks = [] // List of lock to lock immediately after a short delay
    atomicState.unLocks = [] // List of lock to unlock after a short delay
    for (lock in locks) {
        state.usedOneTimeCodes[lock.id] = [] // List of used one time codes for this lock
        state.programmedCodes[lock.id] = [] // List of verified/confirmed programmed codes for this lock
        state.updateLockList.add(lock.id) // reset the state for each lock to be processed with update
        state.expiredLockList.add(lock.id) // reset the state for each lock to be processed with expired
        log.trace "Added $lock id ${lock.id} to unprocessed locks update list ${state.updateLockList} and expire list ${state.expiredLockList}"
    }
    state.updateNextCode = 1 // set next code to be set for the update loop
    state.expiredNextCode = 1 // set next code to be set for the expired loop
    
    log.debug "Initialization complete, starting code updates starting with code $state.updateNextCode"
    
    initializeCodes() // Initialize codes
}

// Handle changes, reinitialize the code check timers after a change, this is to workaround the issue of a buggy ST platform where the timers die randomly for some users
def changeHandler(evt) {
	log.trace "Reinitializing code check timer on event notification, name: ${evt.name}, value: ${evt.value}"
    codeCheck()
}

def sensorHandler(evt)
{
	def data = []
    def sensor = evt.device

	log.trace "Event name $evt.name, value $evt.value, device $evt.displayName"
    
    if (evt.value == "closed") { // Door was closed
        def lock = locks.find { settings."sensor${it}"?.id == sensor.id } // Find the lock for this sensor, match by ID and not objects
        log.debug "Sensor ${sensor} belongs to Lock ${lock}"
        
        if (lock && settings."relockDoor${lock}") { // Are we asked to reLock this door
        	if (settings."relockImmediate${lock}") {
            	log.debug "Relocking ${lock} immediately in 3 seconds"
                def immediatelocks = atomicState.immediateLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                if (!immediatelocks.contains(lock.id)) { // Don't re add the same lock again
                	log.trace "Adding ${lock.id} to the list of immediate locks"
                	immediatelocks.add(lock.id) // Atomic to ensure we get upto date info here
                    atomicState.immediateLocks = immediatelocks // Set it back, we can't work direct on atomicState
                }
                startTimer(3, immediateLockDoor) // Schedule the immediate lock in 3 seconds
            } else if (settings."relockAfter${lock}") {
            	log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
                def relocks = atomicState.reLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                if (!relocks.contains(lock.id)) { // Don't re add the same lock again
                	log.trace "Adding ${lock.id} to the list of relocks"
                	relocks.add(lock.id) // Atomic to ensure we get upto date info here
                    atomicState.reLocks = relocks // Set it back, we can't work direct on atomicState
                }
                startTimer(60 * settings."relockAfter${lock}", reLockDoor) // Schedule the relock in minutes
            } else {
            	log.error "Invalid configuration, no relock timeout defined"
            }
        }
    }
}

// Check for any pending door unlocks
def unLockDoor() {
    def unLocksIDs = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
	log.trace "Pending immediate door locks ${unLocksIDs}"
    
    unLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "UnLocking the door ${lock} immediately"
        lock.unlock() // unlock it
        def unlocks = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        log.trace "Removing ${lockid} from the list of pending unlocks"
        unlocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.unLocks = unlocks // set it back to atomicState
        log.trace "Checking for any pending door unlocks in 3 seconds"
        startTimer(3, unLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending immediate door locks
def immediateLockDoor() {
    def immediateLocksIDs = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
	log.trace "Pending immediate door locks ${immediateLocksIDs}"
    
    immediateLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "Locking the door ${lock} immediately"
        lock.lock() // lock it
        def immediatelocks = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        log.trace "Removing ${lockid} from the list of pending immediate locks"
        immediatelocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.immediateLocks = immediatelocks // set it back to atomicState
        log.trace "Checking for any pending immediate door locks in 3 seconds"
        startTimer(3, immediateLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending delayed door relocks
def reLockDoor() {
    def reLocksIDs = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
	log.trace "Checking door sensor state and relocking ${reLocksIDs}"
    
    reLocksIDs?.each { lockid ->
    	def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
    	if (lockSensor.latestValue("contact") == "closed") {
        	log.info "Sensor ${lockSensor} is reporting door ${lock} is closed, locking the door"
            lock.lock() // lock it
            def relocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
            log.trace "Removing ${lockid} from the list of pending relocks"
            relocks.remove(lockid) // We are done with this lock, remove it from the list
            atomicState.reLocks = relocks // set it back to atomicState
            log.trace "Checking for any pending relocks in 3 seconds"
            startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
            return // We're done here
        } else {
        	log.debug "Sensor ${lockSensor} is reporting door ${lock} is not closed, will check again in 1 minute"
            startTimer(60, reLockDoor) // Check back again in a minute
        }
    }
}

def codeResponse(evt) {
    def lock = evt.device
	def user = evt.value as Integer
    def code = evt.data ? new JsonSlurper().parseText(evt.data)?.code : "" // Not all locks return a code due to a bug in the base Z-Wave lock device code
    def desc = evt.descriptionText // Description can have "is set" or "was added" or "changed" when code was added successfully
    def name = settings."userNames${user}"
	log.trace "Code report $evt.name returned Name:${name ?: ""}, User:${user}, Code:${code}, Desc:${desc}"

    if ((!state.programmedCodes[lock.id].contains(user as String)) && (["is set", "added", "changed"].any { desc.contains(it) })) { // We can get the notifications multiple times
        state.programmedCodes[lock.id].add(user as String)
        log.info "Confirmed $lock added $name to user $user"
        sendNotificationEvent("Confirmed $lock added $name to user $user")
    }
    
    if ((state.programmedCodes[lock.id].contains(user as String)) && (["is not set", "deleted"].any { desc.contains(it) })) { // We can get the notifications multiple times (don't track "was reset" as that's an intermediary notification while setting a code)
        state.programmedCodes[lock.id].remove(user as String)
        log.info "Confirmed ${name ?: ""} user $user was deleted from $lock"
        sendNotificationEvent("Confirmed ${name ?: ""} user $user was deleted from $lock")
        
        // Update tracking lists for used one time codes
        if (state.usedOneTimeCodes[lock.id].contains(user as String)) {
            state.usedOneTimeCodes[lock.id].remove(user as String)
            log.trace "Deleted code was a used one time code, removing it from list of used one time codes"
        }
    }
}

def lockHandler(evt) {
	def data = []
    def lock = evt.device

	log.debug "Event name $evt.name, value $evt.value, device $evt.displayName, data $evt.data"
    
	if (evt.name == "lock") {
    	if (evt.value == "unlocked") {
            def isManual = false
	    	if ((evt.data == "") || (evt.data == null)) { // No extended data, must be a manual/keyed unlock
            	isManual = true
            } else { // We have extended data, should be a coded unlock           	
	    		data = new JsonSlurper().parseText(evt.data) 
            	if ((data.usedCode == "") || (data.usedCode == null)) {	// If no usedCode data, treat as manual unlock
                	log.debug "Unknown extended data (${data}), treating as manual unlock"
                	isManual = true
           		 }
            }
            
            if (isManual) {
            	log.debug "$evt.displayName was unlocked manually"

                if (manualNotify && (manualNotifyModes ? manualNotifyModes.find{it == location.currentMode} : true)) {
                    if (!disableAllNotify) {
                        sendPush "$evt.displayName was unlocked manually"
                    } else {
                        sendNotificationEvent("$evt.displayName was unlocked manually")
                    }
                    if (sms) {
                        sendText(sms, "$evt.displayName was unlocked manually")
                    }
                }
            } else {
            	Integer i = data.usedCode as Integer
                def userName = settings."userNames${i}"
                def notify = settings."userNotify${i}"
                def notifyModes = settings."userNotifyModes${i}"
                
                log.debug "Lock $evt.displayName unlocked by $userName, notify $notify, notify modes $notifyModes"
                
                // Check if we have user override unlock actions defined
                def user = ""
                if (settings."userOverrideUnlockActions${i as String}") {
                	log.debug "Found per user unlock actions"
                    user = i as String
                }
                
                // First disarm SHM since it goes off due to other events
                if (settings."individualDoorActions${user}") {
                    if (settings."homeDisarm${lock}${user}") {
                        log.info "Disarming Smart Home Monitor"
                        sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                        sendNotificationEvent("$evt.displayName was unlocked successfully,  disarming Smart Home Monitor")
                    }

                    if (settings."homeMode${lock}${user}") {
                        log.info "Changing mode to ${settings."homeMode${lock}${user}"}"
                        if (location.modes?.find{it.name == settings."homeMode${lock}${user}"}) {
                            setLocationMode(settings."homeMode${lock}${user}") // First do this to avoid false alerts from a slow platform
                        }  else {
                            log.warn "Tried to change to undefined mode '${settings."homeMode${lock}${user}"}'"
                        }
                        sendNotificationEvent("$evt.displayName was unlocked successfully, changing mode to ${settings."homeMode${lock}${user}"}")
                    }

                    if (settings."homePhrase${lock}${user}") {
                        log.info "Running unlock Phrase ${settings."homePhrase${lock}${user}"}"
                        location.helloHome.execute(settings."homePhrase${lock}${user}") // First do this to avoid false alerts from a slow platform
                        sendNotificationEvent("$evt.displayName was unlocked successfully, running ${settings."homePhrase${lock}${user}"}")
                    }

                    if (settings."turnOnSwitchesAfterSunset${lock}${user}") {
                        def cdt = new Date(now())
                        def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                        log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                        if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                            log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${lock}${user}"} since it's after sunset but before sunrise"
                            settings."turnOnSwitchesAfterSunset${lock}${user}"?.on()
                        }
                    }

                    if (settings."turnOnSwitches${lock}${user}") {
                        log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${lock}${user}"}"
                        settings."turnOnSwitches${lock}${user}"?.on()
                    }

                    if (settings."turnOffSwitches${lock}${user}") {
                        log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${lock}${user}"}"
                        settings."turnOffSwitches${lock}${user}"?.off()
                    }
                } else {
                    if (settings."homeDisarm${user}") {
                        log.info "Disarming Smart Home Monitor"
                        sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                        sendNotificationEvent("$evt.displayName was unlocked successfully,  disarming Smart Home Monitor")
                    }

                    if (settings."homeMode${user}") {
                        log.info "Changing mode to ${settings."homeMode${user}"}"
                        if (location.modes?.find{it.name == settings."homeMode${user}"}) {
                            setLocationMode(settings."homeMode${user}") // First do this to avoid false alerts from a slow platform
                        }  else {
                            log.warn "Tried to change to undefined mode '${settings."homeMode${user}"}'"
                        }
                        sendNotificationEvent("$evt.displayName was unlocked successfully, changing mode to ${settings."homeMode${user}"}")
                    }

                    if (settings."homePhrase${user}") {
                        log.info "Running unlock Phrase ${settings."homePhrase${user}"}"
                        location.helloHome.execute(settings."homePhrase${user}") // First do this to avoid false alerts from a slow platform
                        sendNotificationEvent("$evt.displayName was unlocked successfully, running ${settings."homePhrase${user}"}")
                    }

                    if (settings."turnOnSwitchesAfterSunset${user}") {
                        def cdt = new Date(now())
                        def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                        log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                        if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                            log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${user}"} since it's after sunset but before sunrise"
                            settings."turnOnSwitchesAfterSunset${user}"?.on()
                        }
                    }

                    if (settings."turnOnSwitches${user}") {
                        log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${user}"}"
                        settings."turnOnSwitches${user}"?.on()
                    }

                    if (settings."turnOffSwitches${user}") {
                        log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${user}"}"
                        settings."turnOffSwitches${user}"?.off()
                    }
                }
                                
				// Check for one time codes and disable them if required
                state.usedOneTimeCodes[lock.id].add(i as String) // mark the user slot used
                codeCheck() // Check the expired code and remove from lock

	            if (notify && (notifyModes ? notifyModes.find{it == location.currentMode} : true)) {
                    if (userName == null) {
                    	if (!disableAllNotify) {
                        	sendPush "$evt.displayName was unlocked by Unknown User from slot $i"
                        } else {
                            sendNotificationEvent("$evt.displayName was unlocked by Unknown User from slot $i")
                        }
                        if (sms) {
                        	sendText(sms, "$evt.displayName was unlocked by Unknown User from slot $i")
                        }
                    }
                    else {
                    	if (!disableAllNotify) {
                        	sendPush "$evt.displayName was unlocked by $userName"
                        } else {
                            sendNotificationEvent("$evt.displayName was unlocked by $userName")
                        }
                        if (sms) {
                        	sendText(sms, "$evt.displayName was unlocked by $userName")
                        }
                    }
                }
            }
        } else if (evt.value == "locked") {
            log.debug "$evt.displayName was locked with description: $evt.descriptionText"
            
            def lockMode = evt.descriptionText?.contains("manually") ? "manually" : "electronically"
            
            // Check if we need to retract a deadbolt lock it was locked while the door was still open
            if (settings."retractDeadbolt${lock}") {
            	def sensor = settings."sensor${lock}"
                if (sensor.latestValue("contact") == "open") {
                	log.debug "$lock was locked while the door was still open, unlocking it in 3 seconds"
                    def unlocks = atomicState.unLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    if (!unlocks.contains(lock.id)) { // Don't re add the same lock again
                        log.trace "Adding ${lock.id} to the list of unlocks"
                        unlocks.add(lock.id) // Atomic to ensure we get upto date info here
                        atomicState.unLocks = unlocks // Set it back, we can't work direct on atomicState
                    }
                    startTimer(3, unLockDoor) // Schedule the unlock in 3 seconds
                } else {
                	log.trace "$lock was locked while the door was closed, we're good"
                }
            }

            if (lockNotify && (lockNotifyModes ? lockNotifyModes.find{it == location.currentMode} : true)) {
                if (!disableAllNotify) {
                    sendPush "$evt.displayName was locked $lockMode"
                } else {
                    sendNotificationEvent("$evt.displayName was locked $lockMode")
                }
                if (sms) {
                    sendText(sms, "$evt.displayName was locked $lockMode")
                }
            }
        } else if (evt.value == "unknown") {
            log.debug "Lock $evt.displayName Jammed!"
            if (jamNotify) {
                if (!disableAllNotify) {
                    sendPush "$evt.displayName lock is Jammed!"
                } else {
                    sendNotificationEvent("$evt.displayName lock is Jammed!")
                }
                if (sms) {
                    sendText(sms, "$evt.displayName lock is Jammed!")
                }
            }        	
        }
    } else if (evt.name == "invalidCode") {
        log.debug "Lock $evt.displayName, invalid user code: $evt.value"
        if (!disableAllNotify) {
            sendPush "Too many invalid user codes detected on lock $evt.displayName"
        } else {
            sendNotificationEvent("Too many invalid user codes detected on lock $evt.displayName")
        }
        if (sms) {
            sendText(sms, "Too many invalid user codes detected on lock $evt.displayName")
        }
    }
}
                
def initializeCodes() {
    log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"
    
    for (lock in locks) {
		if (state.updateLockList.contains(lock.id)) { // this lock codes hasn't been completely initiated
            def userCodes = [] // Build the list and program them together at once using updateCodes to work around the crappy platform timers issue
        	log.trace "Initializing pending codes for $lock"
	        while (state.updateNextCode <= settings.maxUserNames) {
            	log.trace "Updating code $state.updateNextCode on $lock"
                def i = state.updateNextCode // Next code we are checking
                def name = settings."userNames${i}" // Get the name for the slot
                def code = settings."userCodes${i}" // Get the code for the slot
                def notify = settings."userNotify${i}" // Notification setting
                def userType = settings."userType${i}" // User type
                def expDate = settings."userExpireDate${i}" // Get the expiration date
                def expTime = settings."userExpireTime${i}" // Get the expiration time
                def startDate = settings."userStartDate${i}" // Get the start date
                def startTime = settings."userStartTime${i}" // Get the start time
                def userDayOfWeekA = settings."userDayOfWeekA${i}" // Scheduling Days of week A
                def userStartTimeA = settings."userStartTimeA${i}" ? (new Date(timeToday(settings."userStartTimeA${i}", location.timeZone).time)).format("HH:mm z", location.timeZone) : "" // Scheduling start time A
                def userEndTimeA = settings."userEndTimeA${i}" ? (new Date(timeToday(settings."userEndTimeA${i}", location.timeZone).time)).format("HH:mm z", location.timeZone) : "" // Scheduling end time A
                def user = i as Integer // which user slot are we using 
				def doAdd = false // by default we dont' add codes
                
                // Check the code expiration
                switch (userType) {
                    case 'Expire on':
                    	if (code != null) {
                            if (expDate && expTime) {
                                def midnightToday = timeToday("2000-01-01T00:00:00.000-0000", location.timeZone)
                                String dst = location.timeZone.getDisplayName(location.timeZone.inDaylightTime(new Date(now())), TimeZone.SHORT) // Keep current timezone
                                def expT = (timeToday(expTime, location.timeZone).time - midnightToday.time)
                                def expD = Date.parse("yyyy-MM-dd Z", expDate + " " + dst).toCalendar()
                                def exp = expD.getTimeInMillis() + expT
                                def expStr = (new Date(exp)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
                                if (exp > now()) {
                                    if (startDate && startTime) {
                                        def startT = (timeToday(startTime, location.timeZone).time - midnightToday.time)
                                        def startD = Date.parse("yyyy-MM-dd Z", startDate + " " + dst).toCalendar()
                                        def start = startD.getTimeInMillis() + startT
                                        def startStr = (new Date(start.value)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
                                        if (start <= now()) {
                                            if (!state.programmedCodes[lock.id].contains(user as String)) {
                                                sendNotificationEvent("$lock user $user $name's code is set to start on $startStr")
                                                log.debug "$lock user $user $name's code is set to start on $startStr"
                                                doAdd = true // we need to add the code
                                            } else {
                                                log.error "$lock User $user $name is already tracked as start added"
                                            }
                                        } else {
                                            if (!state.programmedCodes[lock.id].contains(user as String)) {
                                                sendNotificationEvent("$lock user $user $name's code is set to start in future on $startStr")
                                                log.debug "$lock user $user $name's code is set to start in future on $startStr"
                                            } else {
                                                log.error "$lock user $user $name is already tracked as start added"
                                            }
                                        }
                                    } else {
                                        sendNotificationEvent("$lock user $user $name's code is set to expire on $expStr")
                                        log.debug "$lock user $user $name's code is set to expire on $expStr"
                                        doAdd = true // we need to add the code
                                    }
                                } else {
                                    sendNotificationEvent("$lock user $user $name's code expired on $expStr")
                                    log.debug "$lock user $user $name expired on $expStr"
                                }
                            } else {
                                log.error "$lock User $user $name set to Expire but does not have a Expiration Date: $expDate or Time: $expTime"
                            }
                        }
                        break

                    case 'One time':
                    	if (code != null) {
                            log.debug "$lock user $user $name is a one time code"
                            sendNotificationEvent("$lock user $user $name is a one time code")
                            doAdd = true // the code
                        }
                    	break
                        
                    case 'Scheduled':
                    	if (code != null) {
                            if (checkSchedule(user, "A")) { // Within operating schedule
                                if (state.programmedCodes[lock.id].contains(user as String)) {
                                    log.error "$lock scheduled user $user $name is already tracked. It is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA"
                                } else {
                                    log.debug "$lock user $user $name is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA"
                                }
                                doAdd = true // Add the user
                                sendNotificationEvent("$lock user $user $name is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA")
                            } else {
                                log.debug "$lock user $user $name is outside operating schedule between $userDayOfWeekA: $userStartTimeA-$userEndTimeA"
                                sendNotificationEvent("$lock user $user $name is outside operating schedule between $userDayOfWeekA: $userStartTimeA to $userEndTimeA")
                            }
                        }
                        break
                        
                    case 'Permanent':
                    	if (code != null) {
                    		doAdd = true // add the code
                        }
                        break
                        
                    case 'Inactive':
                    	doAdd = false // delete the code
                        break
                        
                    default:
                    	log.error "Invalid user type $userType, user $user $name"
                    	sendNotificationEvent("Invalid user type $userType, user $user $name")
                        break
                }

                if ((code != null) && doAdd) { // We have a code and it is not expired/within schedule, update or set the code in the slot
                    userCodes << ["code${user}", code]
                    log.debug "Requesting $lock to add $name to user $user, code: $code"
                    sendNotificationEvent("Requesting $lock to add $name to user $user")
                    if (disableRetry && !state.programmedCodes[lock.id].contains(user as String)) {
                        log.info "Retry programming disabled, assuming user was added successfully to the lock"
                        state.programmedCodes[lock.id].add(user as String)
                    }
                } else { // Delete the slot
                    userCodes << ["code${user}", ""]
                    log.debug "Requesting $lock to delete user $user ${name ?: ""}"
                    sendNotificationEvent("Requesting $lock to delete user $user ${name ?: ""}")

                    if (state.programmedCodes[lock.id].contains(user as String)) { // At this stage there should be no codes in the programmed list
                        log.error "Initialization ERROR: ${name ?: ""} user $user exists in $lock list of confirmed programmed codes"
                    } else {
                        log.trace "Tracking ${name ?: ""} user $user to the list of programmed codes temporarily for $lock to confirm that code gets deleted"
                        state.programmedCodes[lock.id].add(user as String) // Add it to the list so that we can get confirmation from the lock that the code was deleted
                    }
                }
                
				state.updateNextCode = state.updateNextCode + 1 // move onto the next code
            }
            
            state.updateLockList.remove(lock.id) // we are done with this lock
            state.updateNextCode = 1 // reset back to 1 for the next lock
            log.trace "$lock id $lock.id code updates complete, unprocessed locks ${state.updateLockList}, reset next code update to $state.updateNextCode"
            
            // Now that we have built the list of codes to be added and removed, program them all together by offloading to device to avoid the crappy platform timer dying issues
            log.debug "Sending codes $userCodes to the $lock for programming"
            lock.updateCodes(userCodes)

            log.trace "Scheduled next lock code initialization in ${settings.maxUserNames > 0 ? settings.maxUserNames * 15 : 15} seconds"
            startTimer((settings.maxUserNames > 0 ? settings.maxUserNames * 15 : 15), initializeCodes) // It takes the lock about 15 seconds to program each code and get a response (give lock time to finish up programming actions)
            return
        }
    }
    
    log.trace "Scheduled code programming verfication in ${settings.maxUserNames > 0 ? settings.maxUserNames * 15 : 15} seconds"
    startTimer((settings.maxUserNames > 0 ? settings.maxUserNames * 15 : 15), codeCheck) // It takes the lock about 15 seconds to program each code and get a response (give lock time to finish up programming actions)
}

def codeCheck() {
    log.trace "CodeCheck called"
    
    log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"

    // Hack for broken ST timers - Schedule the Heartbeat
    if (((state.lastHeartBeat ?: 0) + ((10+5)*60*1000) < now()) && canSchedule()) { // Since we are scheduling the heartbeat every 10 minutes, give it a 5 minute grace
        log.warn "Heartbeat not called in last 15 minutes, rescheduling heartbeat"
        schedule("* */10 * * * ?", heartBeatMonitor) // run the heartbeat every 10 minutes
        state.lastHeartBeat = now() // give it 10 minutes before you schedule it again
    }

    // Update the last time we can code check
    state.lastCheck = now()
    
    for (lock in locks) {
        if (state.expiredLockList.contains(lock.id)) { // this lock codes hasn't been completely initiated
            log.trace "Verifying internal status for codes on $lock"
            while (state.expiredNextCode <= settings.maxUserNames) { // cycle through all the codes
                log.trace "Verifying internal status for code $state.expiredNextCode on $lock"
                def i = state.expiredNextCode
                def name = settings."userNames${i}" // Get the name for the slot
                def code = settings."userCodes${i}" // Get the code for the slot
                def notify = settings."userNotify${i}" // Notification setting
                def userType = settings."userType${i}" // User type
                def expDate = settings."userExpireDate${i}" // Get the expiration date
                def expTime = settings."userExpireTime${i}" // Get the expiration time
                def startDate = settings."userStartDate${i}" // Get the start date
                def startTime = settings."userStartTime${i}" // Get the start time
                def userDayOfWeekA = settings."userDayOfWeekA${i}" // Scheduling Days of week A
                def userStartTimeA = settings."userStartTimeA${i}" ? (new Date(timeToday(settings."userStartTimeA${i}", location.timeZone).time)).format("HH:mm z", location.timeZone) : "" // Scheduling start time A
                def userEndTimeA = settings."userEndTimeA${i}" ? (new Date(timeToday(settings."userEndTimeA${i}", location.timeZone).time)).format("HH:mm z", location.timeZone) : "" // Scheduling end time A
                def user = i as Integer // which user slot are we using, convert to integer to be sure

                switch (userType) {
                    case 'Expire on':
                    	if (code != null) {
                            if (startDate && startTime) {
                                def midnightToday = timeToday("2000-01-01T00:00:00.000-0000", location.timeZone)
                                String dst = location.timeZone.getDisplayName(location.timeZone.inDaylightTime(new Date(now())), TimeZone.SHORT) // Keep current timezone
                                def startT = (timeToday(startTime, location.timeZone).time - midnightToday.time)
                                def startD = Date.parse("yyyy-MM-dd Z", startDate + " " + dst).toCalendar()
                                def start = startD.getTimeInMillis() + startT
                                def startStr = (new Date(start.value)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
                                def expT = (timeToday(expTime, location.timeZone).time - midnightToday.time)
                                def expD = Date.parse("yyyy-MM-dd Z", expDate + " " + dst).toCalendar()
                                def exp = expD.getTimeInMillis() + expT
                                def expStr = (new Date(exp.value)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
                                if ((start <= now()) && (exp > now())) {
                                    if (!state.programmedCodes[lock.id].contains(user as String)) {
                                        lock.setCode(user, code)
                                        log.debug "Requesting $lock to add $name to user $user, code: $code, because it is scheduled to start at $startStr"
                                        sendNotificationEvent("Requesting $lock to add $name to user $user, because it is scheduled to start at $startStr")
                                        if (disableRetry) {
                                            log.info "Retry programming disabled, assuming user was added successfully to the lock"
                                            state.programmedCodes[lock.id].add(user as String)
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                                        startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                                        return // We are done here, exit out as we've scheduled the next update
                                    } else {
                                        log.debug "$lock User $user $name is already tracked as start added"
                                    }
                                }
                            } else if ((startDate && !startTime) || (!startDate && startTime)) {
                                log.error "User $user $name set to Start but does not have a valid Start Date/Time: $startDate or Time: $startTime"
                            }

                            if (expDate && expTime) {
                                def midnightToday = timeToday("2000-01-01T00:00:00.000-0000", location.timeZone)
                                String dst = location.timeZone.getDisplayName(location.timeZone.inDaylightTime(new Date(now())), TimeZone.SHORT) // Keep current timezone
                                def expT = (timeToday(expTime, location.timeZone).time - midnightToday.time)
                                def expD = Date.parse("yyyy-MM-dd Z", expDate + " " + dst).toCalendar()
                                def exp = expD.getTimeInMillis() + expT
                                def expStr = (new Date(exp.value)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)
                                if (exp < now()) {
                                    if (state.programmedCodes[lock.id].contains(user as String)) {
                                        lock.deleteCode(user)
                                        log.debug "Requesting $lock to delete expired user $user $name"
                                        sendNotificationEvent("Requesting $lock to delete expired user $user $name")
                                        
                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                                        startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                                        return // We are done here, exit out as we've scheduled the next update
                                    } else {
                                        log.debug "$lock User $user $name is already tracked as expired"
                                    }
                                }
                            } else {
                                log.error "User $user $name set to Expire but does not have a valid Expiration Date/Time: $expDate or Time: $expTime"
                            }
                        } else if (state.programmedCodes[lock.id].contains(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                            lock.deleteCode(user)
                            log.debug "Requesting $lock to delete user $user $name"
                            sendNotificationEvent("Requesting $lock to delete user $user $name")

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                            startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already deleted"
                        }
                        break

                    case 'One time':
                    	if (code != null) {
                            if (state.usedOneTimeCodes[lock.id].contains(user as String)) {
                                if (!state.trackUsedOneTimeCodes.contains(user as String)) {
                                    state.trackUsedOneTimeCodes.add(user as String) // track it for reporting purposes
                                }
                                lock.deleteCode(user)
                                log.debug "Requesting $lock to delete one time user $user $name"
                                sendNotificationEvent("Requesting $lock to delete one time user $user $name")

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                                startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                if (!state.programmedCodes[lock.id].contains(user as String)) {
                                    lock.setCode(user, code)
                                    log.debug "Requesting $lock to add one time code $name to user $user, code: $code"
                                    sendNotificationEvent("Requesting $lock to add one time code $name to user $user")
                                    if (disableRetry) {
                                        log.info "Retry programming disabled, assuming user was added successfully to the lock"
                                        state.programmedCodes[lock.id].add(user as String)
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                                    startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                                    return // We are done here, exit out as we've scheduled the next update
                                } else {
                                    log.debug "$lock User $user $name is a one time code but it has not been used yet"
                                }
                            }
                        } else if (state.programmedCodes[lock.id].contains(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                            lock.deleteCode(user)
                            log.debug "Requesting $lock to delete user $user $name"
                            sendNotificationEvent("Requesting $lock to delete user $user $name")

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                            startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already deleted"
                        }
                        break

                    case 'Scheduled':
                    	if (code != null) {
                            if (checkSchedule(i, "A")) { // Within operating schedule
                                if (state.programmedCodes[lock.id].contains(user as String)) {
                                    log.debug "$lock Scheduled user $user $name is already active, not adding again"
                                } else {
                                    lock.setCode(user, code)
                                    log.debug "Requesting $lock to add $name to user $user, code: $code, because it is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA"
                                    sendNotificationEvent("Requesting $lock to add $name to user $user because it is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA")
                                    if (disableRetry) {
                                    	log.info "Retry programming disabled, assuming user was added successfully to the lock"
                                        state.programmedCodes[lock.id].add(user as String)
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                                    startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                                    return // We are done here, exit out as we've scheduled the next update
                                }
                            } else { // Outside operating schedule
                                if (!state.programmedCodes[lock.id].contains(user as String)) {
                                    log.debug "$lock Scheduled user $user $name is already inactive, not removing again"
                                } else {
                                    lock.deleteCode(user)
                                    log.debug "Requesting $lock to delete expired user $user $name because it is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA"
                                    sendNotificationEvent("Requesting $lock to delete expired user $user $name because it is scheduled to work between $userDayOfWeekA: $userStartTimeA to $userEndTimeA")

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                                    startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                                    return // We are done here, exit out as we've scheduled the next update
                                }
                            }
                        } else if (state.programmedCodes[lock.id].contains(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                            lock.deleteCode(user)
                            log.debug "Requesting $lock to delete user $user $name"
                            sendNotificationEvent("Requesting $lock to delete user $user $name")

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                            startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already deleted"
                        }
                        break

                    case 'Permanent':
                        if (code != null) {
                            if (!state.programmedCodes[lock.id].contains(user as String)) {
                                lock.setCode(user, code)
                                log.debug "Requesting $lock to add permanent code $name to user $user, code: $code"
                                sendNotificationEvent("Requesting $lock to add permanent code $name to user $user")
                                if (disableRetry) {
                                    log.info "Retry programming disabled, assuming user was added successfully to the lock"
                                    state.programmedCodes[lock.id].add(user as String)
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                                startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                log.debug "$lock User $user $name is a permanent code and is already active"
                            }
                        } else if (state.programmedCodes[lock.id].contains(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                            lock.deleteCode(user)
                            log.debug "Requesting $lock to delete user $user $name"
                            sendNotificationEvent("Requesting $lock to delete user $user $name")

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                            startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already deleted"
                        }
                        break

                    case 'Inactive':
                        if (state.programmedCodes[lock.id].contains(user as String)) {
                            lock.deleteCode(user)
                            log.debug "Requesting $lock to delete inactive user $user $name"
                            sendNotificationEvent("Requesting $lock to delete inactive user $user $name")

                            state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                            //log.trace "Scheduled next code check in ${sendDelay > 0 ? sendDelay : 15} seconds"
                            startTimer((sendDelay > 0 ? sendDelay : 15), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                            return // We are done here, exit out as we've scheduled the next update
                        } else {
                            log.debug "$lock ${name ?: ""} user $user already inactive"
                        }
                    	break


                    default:
                        log.error "Invalid user type $userType, user $user ${name ?: ""}"
                        sendNotificationEvent("Invalid user type $userType, user $user ${name ?: ""}")
                        break
                }

                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
            }

            state.expiredLockList.remove(lock.id) // we are done with this lock
            state.expiredNextCode = 1 // reset back to 1 for the next lock
            log.trace "$lock id $lock.id code check complete, unprocessed locks ${state.expiredLockList}, reset next code update to $state.expiredNextCode"
        }
    }

    // All done now reset the lock list and add the locks back for next check cycle
    state.expiredNextCode = 1 // reset back to 1 for the next lock
    for (lock in locks) {
        state.expiredLockList.add(lock.id) // reset the state for each lock to be processed
        log.trace "Added $lock id ${lock.id} back to unprocessed locks list ${state.expiredLockList}"
    }

    runEvery5Minutes(codeCheck) // schedule the next code check in 5 minutes, hopefully runEveryXMinute is more reliable than runIn and runOnce in the long run with v2 hubs
}

// Heartbeat system to ensure that the MonitorTask doesn't die when it's supposed to be running
def heartBeatMonitor() {
    log.trace "Heartbeat monitor called"
    
    state.lastHeartBeat = now() // Save the last time we were executed

    log.trace "Last code check was done " + ((now() - (state.lastCheck ?: 0))/1000) + " seconds ago"
    if ((((state.lastCheck ?: 0) + (5*60*1000) + (60*1000)) < now()) && canSchedule()) { // Kick start the motion detection monitor if didn't update for more than 60 seconds beyond the polling period (5 minutes)
        log.warn "Code check hasn't been run a long time, calling it to kick start it"
        codeCheck()
    }
}

def startTimer(seconds, function) {
	def runTime = new Date(now() + (seconds * 1000)) // for runOnce
    log.trace "Scheduled to run $function in $seconds seconds"
	//runOnce(runTime, function, [overwrite: true]) // runIn isn't reliable, runOnce is more reliable but isn't as accurate
    runIn(seconds, function, [overwrite: true]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
}

// Checks if we are within the current operating scheduled
// Inputs to the function are user (i) and schedule (x) (there can be multiple schedules)
// Preferences required in user input settings are:
// settings."userStartTime${x}${i}"
// settings."userEndTime${x}${i}"
// settings."userDayOfWeek${x}${i}"
private checkSchedule(def i, def x) {
	log.debug("Checking operating schedule $x for user $i")
    
    def doChange = false
    Calendar localCalendar = Calendar.getInstance(location.timeZone);
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK);
    def currentTime = now()

    // some debugging in order to make sure things are working correclty
    log.debug "Current time: ${(new Date(currentTime)).format("EEE MMM dd yyyy HH:mm z", location.timeZone)}"

	// Check if we are within operating times
    if (settings."userStartTime${x}${i}" != null && settings."userEndTime${x}${i}" != null) {
        def scheduledStart = timeToday(settings."userStartTime${x}${i}", location.timeZone).time
        def scheduledEnd = timeToday(settings."userEndTime${x}${i}", location.timeZone).time

    	log.debug("Operating ${settings."userStartTime${x}${i}"} ${(new Date(scheduledStart)).format("HH:mm z", location.timeZone)}, ${settings."userEndTime${x}${i}"} ${(new Date(scheduledEnd)).format("HH:mm z", location.timeZone)}")

		if (currentTime < scheduledStart || currentTime > scheduledEnd) {
            log.info("Outside operating time schedule")
            return false
        }
    }

	// Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.debug("Operating DOW(s): ${settings."userDayOfWeek${x}${i}"}")

    if(settings."userDayOfWeek${x}${i}" == null) {
    	log.warn "Day of week not specified for operating schedule $x for user $i, assuming no schedule set, so we are within schedule"
        return true
    } else if(settings."userDayOfWeek${x}${i}".contains('All Week')) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Monday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Tuesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Wednesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Thursday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Friday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Saturday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
            doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Sunday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
            doChange = true
    }


    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
    	log.info("Within operating schedule")
        return true
    }
    else {
        log.info("Outside operating schedule")
        return false
    }
}

private sendText(number, message) {
	if (sms) {
    	def phones = sms.split("\\+")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}