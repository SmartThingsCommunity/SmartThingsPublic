/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "03.05.00"
}

/*
 * Copyright RBoy Apps, redistribution or reuse of code or any changes is not allowed without permission
 * Works with all Z-Wave Locks including Schlage, Yale, Kiwkset, Monoprice, DanaLock and IDLock
 *
 * Change Log
 * 2017-10-19 - (v03.05.00) Added support for Danalock V3, added support for one touch locking/lock and leave tile
 * 2017-10-18 - (v03.04.03) Update tile layout with ST mobile app release 2.8.0
 * 2017-10-9 - (v03.04.02) August lock pro MSR patch, only supports secure commands
 * 2017-10-5 - (v03.04.01) August lock pro patch for faulty firmware reporting unknown status
 * 2017-10-4 - (v03.04.00) Yale assure lock keypad lock detection
 * 2017-9-25 - (v03.03.06) Added more Yale Assure locks
 * 2017-9-12 - (v03.03.06) Updated base DTH to sync with ST changes
 * 2017-8-15 - (v03.03.06) Added support for August Z-Wave locks
 * 2017-6-15 - (v03.03.06) When locks are updated(), refresh the MSR incase the lock has been replaced through ST, correctly report Yale and Danalock RF lock/unlock
 * 2017-5-29 - (v03.03.05) Added support for more locks (Yale Assa Abloy) and Yale Bluetooth, updated code to latest Yale specifications
 * 2017-5-24 - (v03.03.04) Fixed issue with Schlage keypad lock/unlock being reported as Master Code
 * 2017-5-23 - (v03.03.03) Added support for reporting Yale RFID tags/user slots
 * 2017-5-23 - (v03.03.02) Added support for FE599 series invalid code detection
 * 2017-5-4 - (v03.03.01) Updated color scheme to match ST UX recommendations
 * 2017-4-19 - (v.03.02.03) Added more Yale fingerprints for Yale Assure Lock and patch for Yale Master Code reporting (code 0 and code 251)
 * 2017-3-13 - (v.3.2.2) Don't show unknown and reset states in the recently logs of device
 * 2017-2-25 - (v3.2.2) Added fingerprints and identification for Yale Conexis L1
 * 2017-2-3 - (v3.2.1) Fix for IDE some users were facing while installing the device handler
 * 2017-1-21 - (v3.2.0) Added support for Yale commercial locks (e.g. nexTouch) and tiles for DPS sensor, tampering and fire/smoke alarm
 * 2017-1-2 - (v3.1.3) Added ability to report door state for IDLock and Yale DPS, Motion Sensor (Schlage) and Smoke Detector (IDLock) capabilties also need to be uncommented if required
 * 2016-11-2 - Added capability tamper alert and improved tamper detection
 * 2016-10-23 - Added ability to check for new code versions, check for Yale duplicate codes and read Schlage pin code lengths and save it in `pinLength`
 * 2016-10-21 - Added support for Danalock including RF and Keypad
 * 2016-10-6 - Added support for FE469
 * 2016-9-6 - Do not report advanced feature status in device stream to avoid confusing users
 * 2016-8-27 - Added support for enabling/disabling beeper on Schlage FE5xx/BE3xx locks
 * 2016-8-23 - Updated battery icon
 * 2016-8-19 - Now unsupported features will show up as blank tiles on the screen
 * 2016-8-8 - Fix for working with IDLock locks configuration
 * 2016-7-27 - Added support for Yale Keyless Connected YD-01 UK lock, more Kwikset and Schlage models, with generic models for future proof support
 * 2016-7-25 - Removed warning for Kiwkset, it does not support remote programming, only reading
 * 2016-7-24 - Added support for non secure classes (battery, configuration for some locks like IDLock)
 * 2016-7-23 - Added support for IDLock RFID lock and fire sensor
 * 2016-7-19 - Harmonized events type reporting using data.type, `outsideLockEvent` is no longer used
 * 2016-7-14 - Bugfix for Yale lock using code
 * 2016-7-13 - Added support for Yale one touch keypad lock and outsideLockEvent notification
 * 2016-7-13 - Added support for Yale alarm notifications, Yale lock codes and Yale specific configuration
 * 2016-7-13 - Fixed reporting invalidCode instead of tamper for invalid code entries
 * 2016-7-11 - Added more support for external button locking with code and for Yale locks
 * 2016-7-10 - Added support for external keypad button locked attribute `outsideLockEvent` and tested with BE469
 * 2016-5-11 - Kwikset 916/914/910 share same MSR and fingerprint
 * 2016-4-20 - Added DH version in setup page
 * 2016-4-8 - Fix for invalidCode not always being reported
 * 2016-3-31 - Added fingerprint ID's for BE469, FE599, BE369, Kwiket 914, Yale Keyfree
 * 2016-3-22 - Added support for 6th generation of Yale locks
 * 2016-3-22 - Changed the icon for the sensivitity
 * 2016-3-22 - Standardized coding standard
 * 2016-3-21 - Added support for Enabling/Disabling Audio/Beeper for Schlage and Yale locks including commands enableAudio and disableAudio
 * 2016-3-15 - Fixed updated function
 * 2016-3-14 - Added support for Kiwkset 916 and reporting beeper/buzzer via attribute 'beeper'
 * 2016-2-15 - Added identification of generic lock types from Schlage
 * 2016-2-14 - Improvement to initial setup to associate lock and get MSR
 * 2016-2-10 - Added support for additional Yale lock devices
 * 2016-2-7 - Fix Support for Yale lock Vacation Mode (Key Code enable/disable)
 * 2016-2-6 - Fixed Yale MSR code check
 * 2016-2-6 - Added support for Yale locks AutoLock and Keypad disable
 * 2016-2-6 - Fixed refresh on configuration
 * 2016-2-3 - Fixed an issue with keypad code enable/disable not working for the BE369
 * 2016-2-3 - Support future version of Schlage locks and fix issue with unsupported Schlage locks (now prompts user to report the new locks to developer but still tries to configure it)
 * 2016-2-2 - Set alarm and sensitive attributes to empty if not supported
 * 2016-2-2 - Fixed alarm status not updating on the tile always, indicate when features are not supported by lock
 * 2016-1-27 - Fix for battery UI broken after upgrade to ST iOS 2.0.8 app
 * 2016-1-27 - Fixed issue with motion sensor for BE469 showing up as 0 in SHM on fresh installation
 * 2016-1-23 - Fixed a bug in getting the MSR for a new lock setup
 * 2016-1-19 - Fixed a bug in base code, codeReport notifications were not always sent to the SmartApp
 * 2015-12-19 - Updated base code and cleaned up
 * 2015-12-9 - Added Dummy commented code for enabling switch capabilities for the lock, uncomment code to enable switch capabilities as requested by users
 * 2015-12-3 - Fix for delay/error in initialization not populating the features sometimes
 * 2015-11-29 - Tweaked the timeout for the relock notification for non motorized deadbolts to 3 seconds
 * 2015-11-29 - Added fix for non motorized deadbolt locks like FE599 not reporting locked after user unlocks the door using a code and it relocks automatically
 * 2015-11-21 - Readded support for attribute "invalidCode" when a user enters an invalid code too many times
 * 2015-11-20 - Corrected text from Auto unlock to Auto lock
 * 2015-11-2 - Added support to set Alarm and Sensivity levels directly from a SmartApp using setAlarm ("off", "alert", "tamper", "forced")and setSensitivity ("highest", "high", "medium", "low", "lowest") commands
 * 2015-9-29 - Added support for Schlage BE369
 * 2015-9-26 - Updated layout and colors
 * 2015-9-23 - Updated colors and layout
 * 2015-9-19 - Added support for MultiAttribute Tiles
 * 2015-7-22 - Updated base code to sync with SmartThings (removed status "invalidCode" and use "tamper" instead)
 * 2015-7-15 - Added support for BE468
 * 2015-7-15 - Improved Jammed status support
 * 2015-6-5 - Added support to get battery level on manual refresh
 * 2015-6-5 - Added support for BE469 and FE599 Schlage locks
 * 2015-2-13 - Added support for auto lock and vacation mode
 * 2015-1-20 - Added support for configuring alarm mode and alarm sensitivity
 * 2015-1-20 - Added support for motion sensor capability for alarm event
 * 2015-1-20 - Added support for door jammed status using capability "invalidCode"
 *
 */
  
metadata {
	// Automatically generated. Make future change here.
	definition (name: "Universal Z-Wave Lock With Alarms", namespace: "rboy", author: "RBoy Apps") {
		capability "Actuator"
		capability "Lock"
		capability "Polling"
		capability "Refresh"
		capability "Sensor"
		capability "Lock Codes"
		capability "Battery"
        capability "Tamper Alert"
        capability "Smoke Detector" //  Fire/Smoke Sensor alerts for IDLock
        capability "Contact Sensor" // Door Open/Close state capability for IDlock and Yale DPS
        //capability "Motion Sensor" // replaced with Tamper Alert (Uncomment this to report as Motion Sensor for tamper alarm alerts for Schlage)
        //capability "Switch" // Uncomment this to enable Switch capability interfaces on lock
        
        attribute "alarm", "string"
        attribute "sensitive", "string"
        attribute "codeunlock", "string"
        attribute "autolock", "string"
        attribute "lockStatus", "string"
        attribute "invalidCode", "string"
        attribute "beeper", "string"
        attribute "pinLength", "number"
        attribute "codeVersion", "string"
        attribute "dhName", "string"
        attribute "contactX", "string"
        attribute "onetouchlock", "string"
       

		command "unlockwtimeout"
        command "alarmToggle"
        command "setAlarm", ["string"]
        command "sensitiveToggle"
        command "setSensitivity", ["string"]
        command "disableKeypad"
        command "enableKeypad"
        command "enableAutolock"
        command "disableAutolock"
        command "disableAudio"
        command "enableAudio"
        command "disableOneTouchLock"
        command "enableOneTouchLock"

		fingerprint deviceId: "0x4004", inClusters: "0x98"
		fingerprint deviceId: "0x4003", inClusters: "0x98"
        fingerprint deviceId: "0x4003", inClusters: "0x85,0x73,0x72,0x98" // Schalge BE369, Schlage FE599
        fingerprint deviceId: "0x4003", inClusters: "0x22,0x72,0x7A,0x98,0x86" // Schlage BE469
        fingerprint deviceId: "0x4003", inClusters: "0x72,0x86,0x98" // Kwikset 910/916/914, Yale KeyFree UK

        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"4004", cc:"98" // Generic Z-Wave lock
        fingerprint type:"4003", cc:"98" // Generic Z-Wave lock
        fingerprint type:"4003", cc:"72,86,98", deviceJoinName:"Kwikset/Yale Z-Wave Lock" // Generic Kwikset/Yale
        fingerprint type:"4003", cc:"85,73,72,98", deviceJoinName:"Schlage BE3xx/FE5xx Z-Wave Lock" // Generic Schalge BE369, Schlage FE599
        fingerprint type:"4003", cc:"22,72,7A,98,86", deviceJoinName:"Schlage BE4xx Z-Wave Lock" // Schlage Generic BE4xx
        fingerprint type:"4003", cc:"85,73,72,98", mfr:"003B", prod:"634B", model:"5044", deviceJoinName:"Schlage FE369 Z-Wave Lock"
        fingerprint type:"4003", cc:"85,73,72,98", mfr:"003B", prod:"634B", model:"504C", deviceJoinName:"Schlage FE599 Z-Wave Lock"
        fingerprint type:"4003", cc:"85,73,72,98,86", mfr:"003B", prod:"6349", deviceJoinName:"Schlage Touchscreen Deadbolt BE468 Z-Wave Lock"
        fingerprint type:"4003", cc:"85,73,72,98,86", mfr:"003B", prod:"6349", model:"5044", deviceJoinName:"Schlage Touchscreen Deadbolt BE468NX CAM 619 Z-Wave Lock"
        fingerprint type:"4003", cc:"85,73,72,98,86", mfr:"003B", prod:"6341", deviceJoinName:"Schlage Touchscreen Deadbolt BE469 Z-Wave Lock" // Generic Schlage BE469
        fingerprint type:"4003", cc:"22,72,7A,98,86", mfr:"003B", prod:"6341", model:"5044", deviceJoinName:"Schlage Touchscreen Deadbolt FE469NX Z-Wave Lock" // Generic Schlage FE469
        fingerprint type:"4003", cc:"85,73,72,98,86", mfr:"003B", prod:"6341", model:"5044", deviceJoinName:"Schlage Touchscreen Deadbolt BE469NX CAM 716 Z-Wave Lock"
        fingerprint type:"4003", cc:"85,73,72,98,86", mfr:"003B", prod:"6341", model:"7750", deviceJoinName:"Schlage Touchscreen Deadbolt BE469NX CEN 716 Z-Wave Lock"
        fingerprint type:"4003", cc:"85,73,72,98,86", mfr:"003B", prod:"6341", model:"4044", deviceJoinName:"Schlage Touchscreen Deadbolt BE469IR Z-Wave Lock"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0090", prod:"0001", model:"0642", deviceJoinName:"Kwikset 916 Z-Wave Lock"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0090", prod:"0001", model:"0436", deviceJoinName:"Kwikset 914 Z-Wave Lock"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0090", prod:"0001", model:"0336", deviceJoinName:"Kwikset 912 Z-Wave Lock"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0090", prod:"0001", model:"0236", deviceJoinName:"Kwikset 910 Z-Wave Lock"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0090", prod:"0001", model:"0001", deviceJoinName:"Kwikset 91x Z-Wave lock" // Kwikset 91x Series Generic Z-Wave
        fingerprint type:"4003", cc:"72,86,98", mfr:"0090", prod:"0001", deviceJoinName:"Kwikset Z-Wave lock" // Kwikset Generic Z-Wave
        fingerprint type:"4003", cc:"72,86,98", mfr:"0109", prod:"0002", model:"0000", deviceJoinName:"Yale Real Living Touchscreen Deadbolt"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0002", model:"0000", deviceJoinName:"Yale Real Living Touchscreen Deadbolt"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0109", prod:"0002", model:"FFFF", deviceJoinName:"Yale Real Living Touchscreen Lever Lock"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0002", model:"FFFF", deviceJoinName:"Yale Real Living Touchscreen Lever Lock"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0109", prod:"0001", model:"0000", deviceJoinName:"Yale Real Living Push Button Lever Lock"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0001", model:"0000", deviceJoinName:"Yale Real Living Push Button Lever Lock"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0109", prod:"0004", model:"0000", deviceJoinName:"Yale Real Living Push Button Deadbolt"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0004", model:"0000", deviceJoinName:"Yale Real Living Push Button Deadbolt" // YRD 210
        fingerprint type:"4003", cc:"72,86,98", mfr:"0109", prod:"0004", model:"0800", deviceJoinName:"Yale YRD110"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0004", model:"0800", deviceJoinName:"Yale YRD110"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0109", prod:"0002", model:"0800", deviceJoinName:"Yale YRD120"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0002", model:"0800", deviceJoinName:"Yale YRD120"
        fingerprint type:"4003", cc:"5E,72,98,5A,73,86", mfr:"0129", prod:"8002", model:"1600", deviceJoinName:"Yale Assure with Bluetooth (YRD446-NR-605)"
        fingerprint type:"4003", cc:"5E,72,98,5A,73,86", mfr:"0129", prod:"8002", model:"1000", deviceJoinName:"Yale Assure with Bluetooth (YRD446-ZW-2619)"
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0006", model:"0000", deviceJoinName:"Yale Keyfree Connected/Conexis L1" // UK
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0066", model:"0000", deviceJoinName:"Yale Conexis L1 SD-L1000-CH" // Safe.co.uk
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0007", model:"0000", deviceJoinName:"Yale Keyless Connected YD-01" // UK - YD-01-CON-ZW-CH
        fingerprint type:"4003", cc:"72,86,98", mfr:"0129", prod:"0040", model:"0000", deviceJoinName:"Yale YDM3168" // Italy
        fingerprint type:"4003", cc:"5E,72,98,5A,73,86", sec:"80,62,85,59,71,70,63,8A,8B,4C,4E,7A", mfr:"0129", prod:"8001", model:"0B00", deviceJoinName:"Yale nexTouch Wireless Touchscreen" // Yale Commercial
        fingerprint type:"4003", cc:"5E,72,98,5A,73,86", mfr:"0129", prod:"0600", model:"8004", deviceJoinName:"Yale Assure Push Button Lock" // Yale Assa Abloy series
        fingerprint type:"4003", cc:"5E,72,98,5A,73,86", mfr:"0129", prod:"0600", model:"8002", deviceJoinName:"Yale Assure Touch Screen Lock" // Yale Assa Abloy series
        fingerprint type:"4003", cc:"5E,72,98,5A,80,73,70", sec:"86,62,63,85,59,71,7A", mfr:"0230", prod:"0003", model:"0001", deviceJoinName:"IDLock 101 Z-Wave/RFID Lock"
        fingerprint type:"4003", cc:"5E,72,98,5A,80,73,70", sec:"86,62,63,85,59,71,7A", mfr:"0230", prod:"0003", deviceJoinName:"IDLock Z-Wave/RFID Lock"
        fingerprint type:"4003", mfr:"010E", prod:"0008", model:"0002", cc:"5E,72,98,5A,80,73,22", deviceJoinName:"DanaLock V2 BLE, Z-Wave EU" // Circle
        fingerprint type:"4003", mfr:"010E", prod:"0008", model:"0001", cc:"5E,72,98,5A,80,73,22", deviceJoinName:"DanaLock V2 BLE, Z-Wave EU" // Square
        fingerprint type:"4003", mfr:"010E", prod:"0009", model:"0001", cc:"5E,98,9F,55", sec:"62,86,71,85,59,6C,72,73,5A,80,7A,70", deviceJoinName:"DanaLock Vv BLE, Z-Wave EU" // V3 Square
        fingerprint type:"4003", mfr:"010E", prod:"0009", model:"0002", cc:"5E,98,9F,55", sec:"62,86,71,85,59,6C,72,73,5A,80,7A,70", deviceJoinName:"DanaLock Vv BLE, Z-Wave EU" // V3 Circle
        fingerprint type:"4003", mfr:"033F", prod:"0001", model:"0001", cc:"5E,55,98,9F", sec:"86,72,5A,73,80,62,85,8E,59,6C,7A", deviceJoinName:"August Lock" // August
	}

	simulator {
		status "locked": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
		status "unlocked": "command: 9881, payload: 00 62 03 00 00 00 FE FE"

		reply "9881006201FF,delay 4200,9881006202": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
		reply "988100620100,delay 4200,9881006202": "command: 9881, payload: 00 62 03 00 00 00 FE FE"
	}

    preferences {
        input title: "", description: "Universal Z-Wave Lock Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input title: "", description: "YALE LOCK CONFIGURATION OPTIONS", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "Number of invalid code entries before the lock sends a tamper alarm", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleWrongCodeLimit", "number", title:"Wrong code entry limit", description: "Wrong code entry limit", defaultValue: "5", range: "1..7", required: false, displayDuringSetup: false)
        input title: "", description: "Number of seconds after which the lock will automatically relock when AutoLock is enabled", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleRelockTime", "number", title:"AutoLock time", description: "Seconds after which the lock will relock", defaultValue: "30", range: "5..255", required: false, displayDuringSetup: false)
        input title: "", description: "Enable this if your lock is equipped with a door positioning sensor to sense open/closed doors", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleDPS", "bool", title:"DPS", description: "Door Positioning Sensor", defaultValue: "false", required: false, displayDuringSetup: false)
        input title: "", description: "", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input title: "", description: "DANALOCK CONFIGURATION OPTIONS", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "Turning speed (torque) of motor", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaTurnSpeed", "enum", title:"Motor speed", description: "Speed of locking and unlocking", defaultValue: "3", options: turnOptions(), required: false, displayDuringSetup: false)
        input title: "", description: "Brake and go back: (If your lock supports this feature) For doors without levers this feature keeps the latch open for a few seconds after unlocking before turning it back. (0 to disable)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaBrakeGoBack", "number", title:"Brake & Go Back time", description: "Number of seconds to keep the latch open after unlocking", defaultValue: "0", range: "0..2147483647", required: false, displayDuringSetup: false)
        input title: "", description: "Number of seconds after which the lock will automatically relock when AutoLock is enabled", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaRelockTime", "number", title:"AutoLock time", description: "Seconds after which the lock will relock", defaultValue: "30", range: "1..2147483647", required: false, displayDuringSetup: false)
        input title: "", description: "Turn and Go: (If your lock supports this feature) If the lock has the optional rotational sensor installed it will automatically turn if manual rotation is detected", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaTurnGo", "bool", title:"Turn & Go", description: "Enable Turn & Go", defaultValue: "false", required: false, displayDuringSetup: false)
    }

    tiles(scale: 2) {
		multiAttributeTile(name:"toggle", type: "generic", width: 6, height: 4){
			tileAttribute ("device.lock", key: "PRIMARY_CONTROL") {
                attributeState "locked", label:'locked', action:"lock.unlock", icon:"st.locks.lock.locked", backgroundColor:"#00a0dc", nextState:"unlocking"
                attributeState "unlocked", label:'unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff", nextState:"locking"
                attributeState "unknown", label:"jammed", action:"lock.lock", icon:"st.locks.lock.unknown", backgroundColor:"#e86d13", nextState:"locking"
                attributeState "locking", label:'locking', icon:"st.locks.lock.locked", backgroundColor:"#00a0dc"
                attributeState "unlocking", label:'unlocking', icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff"
			}
			tileAttribute ("device.lockStatus", key: "SECONDARY_CONTROL") {
				attributeState "lockStatus", label:'${currentValue}'
            }
		}
        standardTile("lock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:'Lock', action:"lock.lock", icon:"st.locks.lock.locked"
		}
		standardTile("unlock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:'Unlock', action:"lock.unlock", icon:"st.locks.lock.unlocked"
		}
		standardTile("alarm", "device.alarm", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:'', icon:"", nextState:"workingoff", backgroundColor:"#ffffff", defaultState: true
			state "off", label:'Alarm Off', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOff.png", nextState:"workingoff"
			state "alert", label:'Alert Mode', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", nextState:"workingon"
			state "tamper", label:'Tamper Mode', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", nextState:"workingon"
			state "forced", label:'Forced Mode', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", nextState:"workingon"
			state "workingoff", label:'...', icon:"http://smartthings.rboyapps.com/images/SecurityOff.png", backgroundColor:"#ffffff"
			state "workingon", label:'...', icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", backgroundColor:"#ffffff"
		}
		standardTile("sensitive", "device.sensitive", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:'', icon:"", nextState:"working", backgroundColor:"#ffffff", defaultState: true
			state "highest", label:'Highest Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
			state "high", label:'High Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
			state "medium", label:'Medium Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
			state "low", label:'Low Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
			state "lowest", label:'Lowest Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
			state "working", label:'...', icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", backgroundColor:"#ffffff"
		}
        standardTile("onetouchlock", "device.onetouchlock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
			state "enabled", label:'Touch Lock', action:"disableOneTouchLock", icon:"http://smartthings.rboyapps.com/images/ManualControlOn.png", nextState:"working"
			state "disabled", label:'Touch Lock', action:"enableOneTouchLock", icon:"http://smartthings.rboyapps.com/images/ManualControlOff.png", nextState:"working"
			state "working", label:'...', icon:"http://smartthings.rboyapps.com/images/ManualControlWorking.png", backgroundColor:"#cccccc"
		}
		standardTile("codeunlock", "device.codeunlock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
			state "enabled", label:'Code Entry On', action:"disableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#ffffff", nextState:"working"
			state "disabled", label:'Code Off', action:"enableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#00a0dc", nextState:"working"
			state "working", label:'...', icon:"st.unknown.zwave.remote-controller", backgroundColor:"#cccccc"
		}
		standardTile("autolock", "device.autolock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
			state "enabled", label:'AutoLock', action:"disableAutolock", icon:"st.contact.contact.closed", backgroundColor:"#00a0dc", nextState:"working"
			state "disabled", label:'AutoLock Off', action:"enableAutolock", icon:"st.contact.contact.closed", nextState:"working"
			state "working", label:'...', icon:"st.contact.contact.closed", backgroundColor:"#cccccc"
		}
		standardTile("beeper", "device.beeper", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"workingoff", defaultState: true
			state "enabled", label:'Audio On', action:"disableAudio", icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff", nextState:"workingon"
			state "disabled", label:'Audio Off', action:"enableAudio", icon:"st.quirky.spotter.quirky-spotter-sound-off", nextState:"workingoff"
			state "workingoff", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-off", backgroundColor:"#ffffff"
			state "workingon", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff"
		}
		valueTile("battery", "device.battery", inactiveLabel: false, width: 2, height: 2) {
			state "battery", label:'${currentValue}%', icon: "http://smartthings.rboyapps.com/images/battery.png", unit:"", backgroundColors:[
                [value: 20, color: "#ff0000"],
                [value: 35, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
		}
		standardTile("refresh", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:'', action:"refresh.refresh", icon:"st.secondary.refresh"
		}
		standardTile("tamper", "device.tamper", decoration: "flat", width: 2, height: 2) {
			state "unknown", label:'', icon:"", backgroundColor:"#ffffff", defaultState: true
			state "detected", label:'TAMPER', backgroundColor:"#e86d13"
			state "clear", label:'', backgroundColor:"#ffffff"
		}
		standardTile("smoke", "device.smoke", decoration: "flat", width: 2, height: 2) {
			state "unknown", label:'', icon:"", backgroundColor:"#ffffff", defaultState: true
			state "clear", label:'', icon:"", backgroundColor:"#ffffff", action:"smoke"
			state "detected", label:'SMOKE', icon:"st.alarm.smoke.smoke", backgroundColor:"#e86d13", action:"clear"
		}
		standardTile("contact", "device.contactX", decoration: "flat", width: 2, height: 2) {
			state "unknown", label:'', icon:"", backgroundColor:"#ffffff", defaultState: true
			state "open", label: 'OPEN', icon: "st.contact.contact.open", backgroundColor: "#e86d13"
			state "closed", label: 'CLOSED', icon: "st.contact.contact.closed", backgroundColor: "#00a0dc"
		}
        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        
		main "toggle"
		details(["toggle", "lock", "unlock", "codeunlock", "autolock", "beeper", "onetouchlock", "alarm", "sensitive", "battery", "contact", "tamper", "smoke", "blank2x", "blank2x", "refresh"])
	}
}

import physicalgraph.zwave.commands.doorlockv1.*
import physicalgraph.zwave.commands.usercodev1.*

private turnOptions() {
    return [1:"Slowest", 2:"Slow", 3:"Normal", 4:"Fast", 5:"Fastest"]
}
private identifyLockModel() {
    log.trace "Identifying specific lock model from database of known models"
    
    switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044": // Schlage FE/BE469NX CAM 716
        	log.debug "Found Schlage FE/BE469NX CAM 716"
            break
            
        case "003B-6341-7750": // Schlage FE/BE469NX CEN 716
        	log.debug "Found Schlage FE/BE469NX CEN 716"
            break
            
        case "003B-6341-4044": // Schlage FE/BE469IR V CAM 619
        	log.debug "Found Schlage FE/BE469IR V CAM 619"
            break
            
        case ~/003B-6341-.*/: // Schlage FE/BE469 Series
        	log.debug "Found Schlage FE/BE469 Series"
            break
            
    	case "003B-6349-5044": // Schlage BE468
        	log.debug "Found Schlage BE468"
            break
            
        case ~/003B-6349-.*/: // Schlage BE468 Series
        	log.debug "Found Schlage BE468 Series"
            break
            
    	case "003B-634B-504C": // Schlage FE599NX CAM 505 ACC 505
        	log.debug "Found Schlage FE599NX CAM 505 ACC 505"
            break
            
        case "003B-634B-5044": // Schlage BE369NX CAM 619
            log.debug "Found Schlage BE369NX CAM 619"
            break
            
        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series
        	log.debug "Found Schlage FE5xx/BE3xx Series"
            break
            
        case ~/0109-0001-.*/: // Yale Touch Lever
        case ~/0129-0001-.*/: // Yale Touch Lever
        	log.debug "Found Yale Touch Lever"
            break
                        
        case ~/0109-0002-.*/: // Yale Touch Deadbolt
        case ~/0129-0002-.*/: // Yale Touch Deadbolt
        	log.debug "Found Yale Touch Deadbolt"
            break
                        
        case ~/0109-0003-.*/: // Yale Push Button Lever
        case ~/0129-0003-.*/: // Yale Push Button Lever
        	log.debug "Found Yale Push Button Lever"
            break
                        
        case ~/0109-0004-.*/: // Yale Push Button Deadbolt
        case ~/0129-0004-.*/: // Yale Push Button Deadbolt
        	log.debug "Found Yale Push Button Deadbolt"
            break
            
        case ~/0129-0006-.*/: // Yale Keyfree/Conexis L1 Lock
        	log.debug "Found Yale Keyfree/Conexis L1 Lock"
            break
            
        case ~/0129-0066-.*/: // Yale Yale Conexis L1 SD-L1000-CH Safe.co.uk
        	log.debug "Found Yale Conexis L1 Lock"
            break

        case ~/0129-0007-.*/: // Yale Keyless Connected YD-01
        	log.debug "Found Yale Keyless Connected YD-01"
            break
            
        case ~/0129-8001-.*/: // Yale nextTouch Wireless Touchscreen
            log.debug "Found Yale nexTouch"
            break
            
        case ~/0129-8002-.*/: // Yale Assure Lock
            log.debug "Found Yale Assure"
            break
                        
        case ~/0129-0600-.*/: // Yale Assure Assa Abloy
        	log.debug "Found Yale Assure Assa Abloy Lock"
            break

        case "0090-0001-0642": // Kwikset 916
        	log.debug "Found Kwikset 916 Lock"
            break
            
        case "0090-0001-0436": // Kwikset 914
        	log.debug "Found Kwikset 914 Lock"
            break
            
        case "0090-0001-0336": // Kwikset 912
        	log.debug "Found Kwikset 912 Lock"
            break
            
        case "0090-0001-0236": // Kwikset 910
        	log.debug "Found Kwikset 910 Lock"
            break
            
        case "0090-0001-0001": // Kwikset 91x Series
        	log.debug "Found Kwikset 91x Lock"
            break
            
        case ~/0090-0001-.*/: // Kwikset 916/914/910
        	log.debug "Found Kwikset Lock"
            break
            
        case "0230-0003-0001": // IDLock 101
        	log.debug "Found IDLock 101 Lock"
            break
                        
        case ~/0230-0003-.*/: // IDLock 1xx
        	log.debug "Found IDLock 1xx Lock"
            break
            
        case ~/010E-0009-.*/: // Danalock V3
        	log.debug "Found Danalock v3"
            break
            
        case ~/010E-0008-.*/: // Danalock V2
        	log.debug "Found Danalock v2"
            break
            
        case ~/033F-0001-.*/: // August
        	log.debug "Found August Lock"
            break
                        
        default:
        	log.warn "Unrecognized device. Contact developer with MSR $state.MSR"
            break
    }
}	

def updated() {
	log.trace "Update called settings: $settings"
	try {
		if (!state.init) {
			state.init = true
		}
        state.configured = false
        // Reset things which cannot be polled / updated manually
        resetMotion()
        resetSmoke()
        resetState()
        response(refresh()) // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def updateTiles() {
    def lockStatusS = (device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown") ? "Alarm ${device.currentState('alarm')?.value}" + (device.currentState('sensitive')?.value && (device.currentState('sensitive')?.value != "unknown") ? "/${device.currentState('sensitive')?.value} | ": " | ") : "") + "Battery ${device.currentState('battery')?.value}%"
    sendEvent(name: "lockStatus", value: lockStatusS, displayed: false, isStateChange: true)
    //log.trace lockStatusS
}

def parse(String description) {
	def result = null
	if (description.startsWith("Err 106")) {
		if (state.sec) {
			result = createEvent(descriptionText:description, displayed:false)
		} else {
			result = createEvent(
				descriptionText: "This lock failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.",
				eventType: "ALERT",
				name: "secureInclusion",
				value: "failed",
				displayed: true,
			)
		}
	} else if (description == "updated") {
		return null
	} else {
		def cmd = zwave.parse(description, [ 0x98: 1, 0x72: 2, 0x85: 2, 0x86: 1 ])
		if (cmd) {
			result = zwaveEvent(cmd)
		}
	}

    updateTiles() // Update the alarm status on the tiles
    
	log.debug "Parsed to ${result.inspect()}"
	result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	def encapsulatedCommand = cmd.encapsulatedCommand([0x62: 1, 0x71: 2, 0x80: 1, 0x85: 2, 0x63: 1, 0x98: 1, 0x86: 1])
	// log.debug "encapsulated: $encapsulatedCommand"
	if (encapsulatedCommand) {
		zwaveEvent(encapsulatedCommand)
	}
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.NetworkKeyVerify cmd) {
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Secure inclusion was successful")
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityCommandsSupportedReport cmd) {
	state.sec = cmd.commandClassSupport.collect { String.format("%02X ", it) }.join()
	if (cmd.commandClassControl) {
		state.secCon = cmd.commandClassControl.collect { String.format("%02X ", it) }.join()
	}
	log.debug "Security command classes: $state.sec"
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Lock is securely included")
}

def zwaveEvent(DoorLockOperationReport cmd) {
    log.debug "DoorLockOperationReport $cmd"
	def result = []
	def map = [ name: "lock" ]
    
    if (state.MSR?.startsWith("033F-")) { // August lock pro has a firmware bug and reports a doorLockMode of 254, ignore it (zw:Fs type:4003 mfr:033F prod:0001 model:0001 ver:0.38 zwv:4.61 lib:03 cc:5E,55,98,9F sec:86,72,5A,73,80,62,85,8E,59,6C,7A role:07 ff:8300 ui:8300)
        if (cmd.doorLockMode == 0xFE) {
            log.trace "August lock firmware bug, ignoring 0xFE door lock report"
            return
        }
    }

	if (cmd.doorLockMode == 0xFF) {
		map.value = "locked"
	} else if (cmd.doorLockMode >= 0x40) {
		map.value = "unknown"
	} else if (cmd.doorLockMode & 1) {
		map.value = "unlocked with timeout"
	} else {
		map.value = "unlocked"
		if (state.assoc != zwaveHubNodeId) {
			log.debug "setting association"
			result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
			result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
			result << response(secure(zwave.associationV1.associationGet(groupingIdentifier:1)))
		}
	}
    
    // IDLock and August supports reporting door state, see Z-Wave specs check bit 0 for door state
    if (state.MSR?.startsWith("0230-") || state.MSR?.startsWith("033F-")) { // IDLock and August
        if ((cmd.doorCondition & 1) == 0) { // Door open
            setState("open", "$device.displayName is open")
        } else if ((cmd.doorCondition & 1) == 1) { // Door closed
            setState("closed", "$device.displayName is closed")
        }
    }
    
	result ? [createEvent(map), *result] : createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport cmd) {
	log.debug "AlarmReport $cmd"
	def result = []
	def map = null
	if (cmd.zwaveAlarmType == 6) {
		if (1 <= cmd.zwaveAlarmEvent && cmd.zwaveAlarmEvent < 10) {
			map = [ name: "lock", value: (cmd.zwaveAlarmEvent & 1) ? "locked" : "unlocked" ]
		}
		switch(cmd.zwaveAlarmEvent) {
			case 1: // Manual lock (Z-Wave specs)
				map.descriptionText = "$device.displayName was manually locked"
                if (cmd.alarmLevel == 2) { // Yale Assure Deadbolt has alarmLevel as 2 for external keypad lock and 1 for internal knob lock
                    map.data = [ type: "keypad" ]
                } else {
                    map.data = [ type: "manual" ]
                }
				break
			case 2: // Manual unlock (Z-Wave specs)
				map.descriptionText = "$device.displayName was manually unlocked"
                map.data = [ type: "manual" ]
				break
            case 3: // Danalock/Yale RF Lock
                map.descriptionText = "$device.displayName was locked"
                map.data = [ type: "remote" ]
            	break
            case 4: // RF Unlock
                if (cmd.eventParameter) { // IDLock RFID
                    map.descriptionText = "$device.displayName was unlocked with code ${(cmd.eventParameter[0] - (state.MSR?.startsWith("0230-") ? 9 : 0))}"
                    map.data = [ usedCode: (cmd.eventParameter[0] - (state.MSR?.startsWith("0230-") ? 9 : 0)), type: "rfid" ] // IDLock report starts from 10 for the 1st registered card
                } else { // Yale and Danalock RF
                    map.descriptionText = "$device.displayName was unlocked"
                    map.data = [ type: "remote" ]
                }
            	break
			case 5: // Locked via Keypad
                if (cmd.alarmType == 18) { // Locked with keypad code (Yale), it doesn't follow Z-Wave specs and eventParameter contains unknown e.g.: [99, 3, 1, 1], locked from outside via keypad (Schlage BE469, alarmLevel=0 for no code lock and leave, alarmLevel=1 for with code)
                    if (cmd.alarmLevel >= 0) {
                        map.descriptionText = "$device.displayName was locked with code $cmd.alarmLevel"
                        map.data = [ usedCode: (state.MSR?.startsWith("0129-") ? (cmd.alarmLevel > 249 ? 0 : cmd.alarmLevel) : cmd.alarmLevel ?: null), type: "keypad" ] // Yale locks master code returns 251 and 0 and specs allow code upto 0xF9, Schlage/other locks report 0 for outside button/one touch lock
                    } else {
                        map.descriptionText = "$device.displayName was locked"
                        map.data = [ type: "keypad" ]
                    }
                } else if (cmd.eventParameter) {
					map.descriptionText = "$device.displayName was locked with code ${cmd.eventParameter.first()}"
					map.data = [ usedCode: cmd.eventParameter[0], type: "keypad" ]
				} else {
                    map.descriptionText = "$device.displayName was locked"
                    map.data = [ type: "keypad" ]
                }
				break
			case 6: // Unlocked via Keypad
                if (cmd.alarmType == 19) { // Unlocked with keypad code (Yale), it doesn't follow Z-Wave specs and eventParameter contains unknown e.g.: [99, 3, 1, 1]
                    if (cmd.alarmLevel >= 0) {
                        map.descriptionText = "$device.displayName was unlocked with code $cmd.alarmLevel"
                        map.data = [ usedCode: (state.MSR?.startsWith("0129-") ? (cmd.alarmLevel > 249 ? 0 : cmd.alarmLevel) : cmd.alarmLevel ?: null), type: "keypad" ] // Yale locks master code returns 251 and 0 and specs allow code upto 0xF9, Schlage/other locks report 0 for outside button/one touch lock
                    } else {
                        map.descriptionText = "$device.displayName was unlocked"
                        map.data = [ type: "keypad" ]
                    }
                } else if (cmd.eventParameter) {
                    if (cmd.eventParameter[0] == 0) { // IDLock code 0 is remotely unlocked (electronically)
                        map.data = [ type: "remote" ]
                    } else { // non 0 codes are user code based unlock for all locks
                        map.descriptionText = "$device.displayName was unlocked with code ${cmd.eventParameter.first()}"
                        map.data = [ usedCode: cmd.eventParameter[0], type: "keypad" ]
                    }
				} else {
                    map.descriptionText = "$device.displayName was unlocked"
                    map.data = [ type: "keypad" ]
                }
                break
			case 9:
				map.descriptionText = "$device.displayName was autolocked"
        	    map.data = [ type: "auto" ]
				break
			case 7:
			case 8:
			case 0xA:
				map = [ name: "lock", value: "unknown", descriptionText: "$device.displayName was not locked fully" ]
				break
			case 0xB:
				map = [ name: "lock", value: "unknown", descriptionText: "$device.displayName is jammed" ]
				break
			case 0xC:
				map = [ name: "codeChanged", value: "all", descriptionText: "$device.displayName: all user codes deleted", isStateChange: true ]
				allCodesDeleted()
				break
			case 0xD:
				if (cmd.eventParameter) {
					map = [ name: "codeReport", value: cmd.eventParameter[0], data: [ code: "" ], isStateChange: true ]
					map.descriptionText = "$device.displayName code ${map.value} was deleted"
					map.isStateChange = (state["code$map.value"] != "")
					state["code$map.value"] = ""
				} else {
					map = [ name: "codeChanged", descriptionText: "$device.displayName: user code deleted", isStateChange: true ]
				}
				break
			case 0xE:
				map = [ name: "codeChanged", value: cmd.alarmLevel,  descriptionText: "$device.displayName: user code added", isStateChange: true ]
				if (cmd.eventParameter) {
					map.value = cmd.eventParameter[0]
					result << response(requestCode(cmd.eventParameter[0]))
				}
				break
			case 0xF:
				map = [ name: "codeChanged", descriptionText: "$device.displayName: user code not added, duplicate", isStateChange: true ]
				break
			case 0x10:
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName: code entry attempt limit exceeded, keypad temporarily disabled", isStateChange: true, displayed: true ]
				break
			case 0x11:
				map = [ descriptionText: "$device.displayName: keypad is busy" ]
				break
			case 0x12:
				map = [ name: "codeChanged", descriptionText: "$device.displayName: program code changed", isStateChange: true ]
				break
			case 0x13:
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName: code entry attempt limit exceeded", displayed: true ]
				break
			case 0x14: // IDLock invalid RFID code (5 bytes long) and Danalock invalid RF code
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName: invalid code ${cmd.eventParameter.join("")}", isStateChange: true, displayed: true ]
				break
            case 0x16: // DPS Open
                setState("open", "$device.displayName is open")
                map = [ descriptionText: "$device.displayName: DPS Open", displayed: false ]
                break
            case 0x17: // DPS Closed
                setState("closed", "$device.displayName is closed")
                map = [ descriptionText: "$device.displayName: DPS Closed", displayed: false ]
                break
            case 0xFE: // Misc
                switch(cmd.alarmType) {
                    case 0x2B: // Yale DPS
                        if (cmd.alarmLevel == 2) {
                            setState("open", "$device.displayName is open")
                            map = [ descriptionText: "$device.displayName: DPS Open", displayed: false ]
                        }
                        break
                    case 0x26: // Yale Non Access User (programmed but does not operate lock), alarmLevel represents user slot no
                    	map = [ descriptionText: "$device.displayName: Non Access User $cmd.alarmLevel", displayed: true ]
                        break
                    case 0xA1: // Yale tamper alarm
                        if (cmd.alarmLevel == 2) {
                            map = [ name: "tamper", value: "detected", descriptionText: "$device.displayName front escutcheon removed", isStateChange: true, displayed: true ]
                            activateMotion("$device.displayName: Door tampering activity detected")
                            runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
                        }
                        break
                    case 0xB0: // Yale Mobile Access, unlocked via Bluetooth
                    	map = [ name: "lock", value: "unlocked" ]
                        map.descriptionText = "$device.displayName was unlocked"
                        map.data = [ type: "bluetooth" ]
                        break
                    case 0xB2: // Yale configuration params updated via Mobile
                    	map = [ descriptionText: "$device.displayName: Configuration params update via Mobile", displayed: false ]
                        break
                    case 0x83: // Yale Disabled User Pin was entered
                    	map = [ descriptionText: "$device.displayName: Disabled User $cmd.alarmLevel", displayed: true ]
                        break
                    case 0x84: // Yale Out of schedule user (valid)
                    	map = [ descriptionText: "$device.displayName: Out of Schedule User $cmd.alarmLevel", displayed: true ]
                        break
                    default:
                        map = map ?: [ descriptionText: "$device.displayName: Misc event, alarm type $cmd.alarmType", displayed: false ]
	                    break
                }
                break
			default:
				map = map ?: [ descriptionText: "$device.displayName: alarm event $cmd.zwaveAlarmEvent", displayed: false ]
				break
		}
	} else if (cmd.zwaveAlarmType == 7) {
		// Door tamper alarm has been set off ZWAVE_ALARM_TYPE_BURGLAR
		map = [ name: "tamper", value: "detected", displayed: true ]
		switch (cmd.zwaveAlarmEvent) {
			case 0:
				map.value = "clear"
				map.descriptionText = "$device.displayName: tamper alert cleared"
				break
			case 1:
			case 2: // Forced mode Schlage (no reset sent)
                activateMotion("$device.displayName: Door tampering activity detected")
            	runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
				map.descriptionText = "$device.displayName: intrusion attempt detected"
				break
			case 3:
                activateMotion("$device.displayName: Door tampering activity detected")
            	runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
				map.descriptionText = "$device.displayName: covering removed"
				break
			case 4:
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName: invalid code", isStateChange: true, displayed: true ]
				break
			default:
                activateMotion("$device.displayName: Door tampering activity detected")
            	runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
				map.descriptionText = "$device.displayName: tamper alarm $cmd.zwaveAlarmEvent"
				break
		}
	} else switch(cmd.alarmType) {
        case 10: // IDLock fire sensor
        	if (cmd.zwaveAlarmEvent == 2) {
                activateSmoke("$device.displayName detected Fire")
                runIn(60, deactivateSmoke)
            }
        	break
		case 18: // Locked with keypad code (Yale)
			map = [ name: "lock", value: "locked" ]
			if (cmd.alarmLevel >= 0) { // Yale Master Code is 0
				map.descriptionText = "$device.displayName was locked with code $cmd.alarmLevel"
                map.data = [ usedCode: (state.MSR?.startsWith("0129-") ? (cmd.alarmLevel > 249 ? 0 : cmd.alarmLevel) : cmd.alarmLevel ?: null), type: "keypad" ] // Yale locks master code returns 251 and 0 and specs allow code upto 0xF9, Schlage/other locks report 0 for outside button/one touch lock
			} else {
                map.descriptionText = "$device.displayName was locked"
                map.data = [ type: "keypad" ]
            }
            break
		case 21: // One touch locked via keypad (Yale) alarmLevel 2, using key/knob alarmLevel 1
			map = [ name: "lock", value: "locked" ]
			if (cmd.alarmLevel == 2) {
                map.descriptionText = "$device.displayName was locked"
        	    map.data = [ type: "keypad" ]
            } else {
                map.descriptionText = "$device.displayName was manually locked"
                map.data = [ type: "manual" ]
            }
			break
		case 24: // Locked by command (Kwikset 914/Yale)
			map = [ name: "lock", value: "locked" ]
            map.descriptionText = "$device.displayName was locked"
        	map.data = [ type: "remote" ]
			break
		case 27: // Autolocked
			map = [ name: "lock", value: "locked" ]
            map.descriptionText = "$device.displayName was locked"
        	map.data = [ type: "auto" ]
			break
		case 16: // Note: for levers this means it's unlocked, for non-motorized deadbolt, it's just unsecured and might not get unlocked
        	// Note: Schlage FE599 non motorized deadbolt sends 16 and motorized deadbolts like BE469 send 19. However with non motorized deadbolts it only unsecures the handles and not unlocks, so we need to send a lock event after a few seconds
        	log.trace "Non motorized bolt, resetting unlocked to locked notification in 3 seconds"
            runIn(3, reLocked) // The bolt resecures after 3 seconds, send the locked event notification
		case 19: // Yale unlocked using keypad
			map = [ name: "lock", value: "unlocked" ]
			if (cmd.alarmLevel >= 0) { // Yale Master code is 0
				map.descriptionText = "$device.displayName was unlocked with code $cmd.alarmLevel"
                map.data = [ usedCode: (state.MSR?.startsWith("0129-") ? (cmd.alarmLevel > 249 ? 0 : cmd.alarmLevel) : cmd.alarmLevel ?: null), type: "keypad" ] // Yale locks master code returns 251 and 0 and specs allow code upto 0xF9, Schlage/other locks report 0 for outside button/one touch lock
			} else {
                map.descriptionText = "$device.displayName was unlocked"
                map.data = [ type: "keypad" ]
            }
			break
		case 144: // Yale unlocked using RFID tag
			map = [ name: "lock", value: "unlocked" ]
			if (cmd.alarmLevel > 0) {
				map.descriptionText = "$device.displayName was unlocked with code $cmd.alarmLevel"
				map.data = [ usedCode: cmd.alarmLevel, type: "rfid" ]
			} else {
                map.descriptionText = "$device.displayName was unlocked"
                map.data = [ type: "rfid" ]
            }
			break
		case 22: // Unlocked manually via knob (Yale)
			map = [ name: "lock", value: "unlocked" ]
            map.descriptionText = "$device.displayName was manually unlocked"
        	map.data = [ type: "manual" ]
			break
		case 25: // Kwikset 914/Yale unlocked by command
			map = [ name: "lock", value: "unlocked" ]
            map.descriptionText = "$device.displayName was unlocked"
        	map.data = [ type: "remote" ]
			break
		case 9: // Yale
		case 17:
		case 23:
		case 26:
			map = [ name: "lock", value: "unknown", descriptionText: "$device.displayName bolt is jammed" ]
			break
		case 13:
			map = [ name: "codeChanged", value: cmd.alarmLevel, descriptionText: "$device.displayName code $cmd.alarmLevel was added", isStateChange: true ]
			result << response(requestCode(cmd.alarmLevel))
			break
		case 32:
			map = [ name: "codeChanged", value: "all", descriptionText: "$device.displayName: all user codes deleted", isStateChange: true ]
			allCodesDeleted()
            break
		case 33:
			map = [ name: "codeReport", value: cmd.alarmLevel, data: [ code: "" ], isStateChange: true ]
			map.descriptionText = "$device.displayName code $cmd.alarmLevel was deleted"
			map.isStateChange = (state["code$cmd.alarmLevel"] != "")
			state["code$cmd.alarmLevel"] = ""
			break
		case 112:
			map = [ name: "codeChanged", value: cmd.alarmLevel, descriptionText: "$device.displayName code $cmd.alarmLevel changed", isStateChange: true ]
			result << response(requestCode(cmd.alarmLevel))
			break
		case 130:  // Yale YRD batteries replaced
			map = [ descriptionText: "$device.displayName batteries replaced", isStateChange: true ]
			break
        case 113: // Yale Duplicate (did ST typo case 113 as 131?)
		case 131:
			map = [ /*name: "codeChanged", value: cmd.alarmLevel,*/ descriptionText: "$device.displayName code $cmd.alarmLevel is duplicate", isStateChange: false ]
			break
        case 96: // Schlage FE599 (alarmType 96, alarmLevel 255)
		case 161:
			if (cmd.alarmLevel == 2) {
				map = [ name: "tamper", value: "detected", descriptionText: "$device.displayName front escutcheon removed", isStateChange: true, displayed: true ]
		        activateMotion("$device.displayName: Door tampering activity detected")
                runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			} else if (cmd.alarmLevel == 1) {
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName Keypad attempts exceed code entry limit", isStateChange: true, displayed: true ] // Yale v9 Z-wave CC
			} else if (cmd.alarmLevel == 3) {
				map = [ name: "tamper", value: "detected", descriptionText: "$device.displayName handle open detected", isStateChange: true, displayed: true ] // Yale 6th gen Keyfree lock Handle Alarm
                activateMotion("$device.displayName: Door tampering activity detected")
                runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			} else {
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName detected failed user code attempt", isStateChange: true, displayed: true ]
			}
			break
		case 167:
			if (!state.lastbatt || now() - state.lastbatt > 12*60*60*1000) {
				map = [ descriptionText: "$device.displayName: battery low", isStateChange: true ]
				result << response(getBatteryState())
			} else {
				map = [ name: "battery", value: cmd.alarmLevel ?: device.currentValue("battery"), descriptionText: "$device.displayName: battery low", displayed: true ] // Yale reports battery level
			}
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
			break
		case 168:
			map = [ name: "battery", value: 1, descriptionText: "$device.displayName: battery level critical", displayed: true ]
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
			break
		case 169:
			map = [ name: "battery", value: 0, descriptionText: "$device.displayName: battery too low to operate lock", isStateChange: true ]
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
			break
		default:
			map = [ displayed: false, descriptionText: "$device.displayName: alarm event $cmd.alarmType level $cmd.alarmLevel" ]
			break
	}
	result ? [createEvent(map), *result] : createEvent(map)
}

def zwaveEvent(UserCodeReport cmd) {
	def result = []
	def name = "code$cmd.userIdentifier"
	def code = cmd.code
	def map = [:]
	if (cmd.userIdStatus == UserCodeReport.USER_ID_STATUS_OCCUPIED ||
		(cmd.userIdStatus == UserCodeReport.USER_ID_STATUS_STATUS_NOT_AVAILABLE && cmd.user && code != "**********"))
	{
		if (code == "**********") {  // Schlage locks send us this instead of the real code
			state.blankcodes = true
			code = state["set$name"] ?: decrypt(state[name]) ?: code
			state.remove("set$name".toString())
		}
		if (!code && cmd.userIdStatus == 1) {  // Schlage touchscreen sends blank code to notify of a changed code
			map = [ name: "codeChanged", value: cmd.userIdentifier, displayed: true, isStateChange: true ]
			map.descriptionText = "$device.displayName code $cmd.userIdentifier " + (state[name] ? "changed" : "was added")
			code = state["set$name"] ?: decrypt(state[name]) ?: "****"
			state.remove("set$name".toString())
		} else {
			map = [ name: "codeReport", value: cmd.userIdentifier, data: [ code: code ] ]
			map.descriptionText = "$device.displayName code $cmd.userIdentifier is set"
			map.displayed = (cmd.userIdentifier != state.requestCode && cmd.userIdentifier != state.pollCode)
			map.isStateChange = true
		}
		result << createEvent(map)
	} else {
		map = [ name: "codeReport", value: cmd.userIdentifier, data: [ code: "" ] ]
		if (state.blankcodes && state["reset$name"]) {  // we deleted this code so we can tell that our new code gets set
			map.descriptionText = "$device.displayName code $cmd.userIdentifier was reset"
			map.displayed = map.isStateChange = true
			result << createEvent(map)
			state["set$name"] = state["reset$name"]
			result << response(setCode(cmd.userIdentifier, state["reset$name"]))
			state.remove("reset$name".toString())
		} else {
			if (state[name]) {
				map.descriptionText = "$device.displayName code $cmd.userIdentifier was deleted"
			} else {
				map.descriptionText = "$device.displayName code $cmd.userIdentifier is not set"
			}
			map.displayed = (cmd.userIdentifier != state.requestCode && cmd.userIdentifier != state.pollCode)
			map.isStateChange = true
			result << createEvent(map)
		}
		code = ""
	}
	state[name] = code ? encrypt(code) : code

	if (cmd.userIdentifier == state.requestCode) {  // reloadCodes() was called, keep requesting the codes in order
		if (state.requestCode + 1 > state.codes || state.requestCode >= 30) {
			state.remove("requestCode")  // done
		} else {
			state.requestCode = state.requestCode + 1  // get next
			result << response(requestCode(state.requestCode))
		}
	}
	if (cmd.userIdentifier == state.pollCode) {
		if (state.pollCode + 1 > state.codes || state.pollCode >= 30) {
			state.remove("pollCode")  // done
		} else {
			state.pollCode = state.pollCode + 1
		}
	}
	log.debug "code report parsed to ${result.inspect()}"
	result
}

def zwaveEvent(UsersNumberReport cmd) {
	def result = []
	state.codes = cmd.supportedUsers
	if (state.requestCode && state.requestCode <= cmd.supportedUsers) {
		result << response(requestCode(state.requestCode))
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
	def result = []
	if (cmd.nodeId.any { it == zwaveHubNodeId }) {
		state.remove("associationQuery")
		log.debug "$device.displayName is associated to $zwaveHubNodeId"
		result << createEvent(descriptionText: "$device.displayName is associated")
		state.assoc = zwaveHubNodeId
		if (cmd.groupingIdentifier == 2) {
			result << response(zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		}
	} else if (cmd.groupingIdentifier == 1) {
		result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
	} else if (cmd.groupingIdentifier == 2) {
		result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.timev1.TimeGet cmd) {
    log.debug "$device.displayName requested time update"
	def result = []
	def now = new Date().toCalendar()
	if(location.timeZone) now.timeZone = location.timeZone
	result << createEvent(descriptionText: "$device.displayName requested time update", displayed: false)
	result << response(secure(zwave.timeV1.timeReport(
		hourLocalTime: now.get(Calendar.HOUR_OF_DAY),
		minuteLocalTime: now.get(Calendar.MINUTE),
		secondLocalTime: now.get(Calendar.SECOND)))
	)
	result
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet cmd) {
	// The old Schlage locks use group 1 for basic control - we don't want that, so unsubscribe from group 1
	def result = [ createEvent(name: "lock", value: cmd.value ? "unlocked" : "locked") ]
    def cmds = [
        zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId).format(),
        "delay 1200",
        zwave.associationV1.associationGet(groupingIdentifier:2).format()
    ]
    [result, response(cmds)]
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	def result = []
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "$device.displayName has a low battery"
	} else {
		map.value = cmd.batteryLevel
	}
    log.info "Battery level $map.value%"
	state.lastbatt = now()
	result = createEvent(map)
    runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
    result
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	log.debug "ManufacturerSpecificReport $cmd"
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)

	result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)
	result
}

def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd) {
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	if (state.MSR == "003B-6341-5044") {
		updateDataValue("ver", "${cmd.applicationVersion >> 4}.${cmd.applicationVersion & 0xF}")
	}
	def text = "$device.displayName: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	createEvent(descriptionText: text, isStateChange: false)
}

def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationBusy cmd) {
	def msg = cmd.status == 0 ? "try again later" :
	          cmd.status == 1 ? "try again in $cmd.waitTime seconds" :
	          cmd.status == 2 ? "request queued" : "sorry"
    log.warn "$device.displayName is busy, $msg"
	createEvent(displayed: true, descriptionText: "$device.displayName is busy, $msg")
}

def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationRejectedRequest cmd) {
	log.error "$device.displayName rejected the last request"
    createEvent(displayed: true, descriptionText: "$device.displayName rejected the last request")
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
    log.warn "$device.displayName: $cmd"
	createEvent(displayed: false, descriptionText: "$device.displayName: $cmd")
}

def lockAndCheck(doorLockMode) {
	secureSequence([
		zwave.doorLockV1.doorLockOperationSet(doorLockMode: doorLockMode),
		zwave.doorLockV1.doorLockOperationGet()
	], 4200)
}

def lock() {
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_SECURED)
}

def unlock() {
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED)
}

def unlockwtimeout() {
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED_WITH_TIMEOUT)
}

def refresh() {
    log.debug "Refresh called, Device MSR is $state.MSR"
    identifyLockModel()

    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Universal Z-Wave Lock Device Handler"]) // Save DH Name for parent app

    if (!device.currentValue("motion")?.trim() || !device.currentValue("tamper")?.trim()) { // If the tamper/motion sensor state isn't defined then lets define it to report it correctly in SHM
        resetMotion()
    }
    if (!device.currentValue("smoke")?.trim()) { // If the smoke/fire sensor state isn't defined then lets define it to report it correctly in SHM
        resetSmoke()
    }
    if (!device.currentValue("contact")?.trim()) { // If the door closed sensor state isn't defined then lets define it to report it correctly in SHM
        resetState()
    }

	def cmds = []

	if (state.assoc == zwaveHubNodeId) {
		log.debug "$device.displayName is associated to ${state.assoc}"
	} else if (!state.associationQuery) {
		log.debug "checking association"
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()  // old Schlage locks use group 2 and don't secure the Association CC
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
	    cmds << "delay 5000"
		state.associationQuery = now()
	} else if (secondsPast(state.associationQuery, 9)) {
		log.debug "setting association"
		cmds << zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId).format()
		cmds << secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
	    cmds << "delay 5000"
		state.associationQuery = now()
	}
    
	if (!state.MSR || !state.configured) { // If we don't have a MSR or we refreshed the settings, first get it (and wait for it to complete)
		log.debug "Getting Device MSR"
    	cmds << response(zwave.manufacturerSpecificV2.manufacturerSpecificGet().format()) // Some locks only support non secure responses (Schlage)
	    cmds << "delay 5000"
    	cmds << response(secure(zwave.manufacturerSpecificV2.manufacturerSpecificGet())) // Some locks only support secure responses (August Pro)
	    cmds << "delay 5000"
    } else {
        cmds << getAlarmLevel() // Alarm Level
        cmds << "delay 5000"
        cmds << getKeypadState() // Keypad
        cmds << "delay 5000"
        cmds << getSensitiveLevel() // Alarm Sensitivity Level (give alarm 10 seconds to update before getting sensitive)
        cmds << "delay 5000"
        cmds << getAutolockState() // Auto Lock
        cmds << "delay 5000"
        cmds << getOneTouchLockState() // One touch lock
        cmds << "delay 5000"
        cmds << getAudioState() // Audio/Beeper
        cmds << "delay 5000"
        log.trace "Current user pin code length ${device.currentValue("pinLength")}"
        cmds << getPinLength() // Pin code length
        cmds << "delay 5000"
    }
    
  	cmds << secure(zwave.doorLockV1.doorLockOperationGet())
    cmds << "delay 5000"
    cmds << getBatteryState() // Battery
    cmds << "delay 5000"
    
    if (!state.configured) {
        cmds << configureLock() // Configure lock settings
        state.configured = true // We're done here
    }

	//log.trace "refresh sending ${cmds.inspect()}"
	cmds
}

def poll() {
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Universal Z-Wave Lock Device Handler"]) // Save DH Name for parent app

    if (!device.currentValue("motion")?.trim() || !device.currentValue("tamper")?.trim()) { // If the tamper/motion sensor state isn't defined then lets define it to report it correctly in SHM
        resetMotion()
    }
    if (!device.currentValue("smoke")?.trim()) { // If the smoke/fire sensor state isn't defined then lets define it to report it correctly in SHM
        resetSmoke()
    }
    if (!device.currentValue("contact")?.trim()) { // If the door closed sensor state isn't defined then lets define it to report it correctly in SHM
        resetState()
    }

	def cmds = []

    log.debug "Poll called, Device MSR is $state.MSR"
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
    	cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format() // Some locks only support non secure responses (Schlage)
	    cmds << "delay 5000"
    	cmds << secure(zwave.manufacturerSpecificV2.manufacturerSpecificGet()) // Some locks only support secure responses (August Pro)
	    cmds << "delay 5000"
    }

    // Only check lock state if it changed recently or we haven't had an update in an hour
	def latest = device.currentState("lock")?.date?.time
	if (!latest || !state.lastPoll || !secondsPast(latest, 6 * 60) || secondsPast(state.lastPoll, 55 * 60)) {
		cmds << secure(zwave.doorLockV1.doorLockOperationGet())
        cmds << "delay 5000"
        cmds << getAlarmLevel() // Alarm Level
        cmds << "delay 5000"
        cmds << getKeypadState() // Keypad
        cmds << "delay 5000"
        cmds << getSensitiveLevel() // Alarm Sensitivity Level (give alarm 10 seconds to update before getting sensitive)
        cmds << "delay 5000"
        cmds << getAutolockState() // Auto Lock
        cmds << "delay 5000"
        cmds << getOneTouchLockState() // One touch lock
        cmds << "delay 5000"
        cmds << getAudioState() // Audio/Beeper
        cmds << "delay 5000"
        log.trace "Current user pin code length ${device.currentValue("pinLength")}"
        if (device.currentValue("pinLength") != 0) { // If we haven't checked for it (null) or if it was returned by the lock, check for changes
            cmds << getPinLength() // Pin code length
            cmds << "delay 5000"
        }
		state.lastPoll = now()
	}
    if (!state.lastbatt || secondsPast(state.lastbatt, 53*60*60)) {
		cmds << getBatteryState()
        cmds << "delay 5000"
		state.lastbatt = now()  //inside-214
	}
	if (cmds) {
		log.debug "poll is sending ${cmds.inspect()}"
		cmds
	} else {
		// workaround to keep polling from stopping due to lack of activity
        log.trace "Poll called again to soon, skipping poll to save battery"
		sendEvent(descriptionText: "skipping poll", isStateChange: true, displayed: false)
        device.activity()  // workaround to keep polling from being shut off
		null
	}
}

def requestCode(codeNumber) {
	secure(zwave.userCodeV1.userCodeGet(userIdentifier: codeNumber))
}

def reloadAllCodes() {
	def cmds = []
	if (!state.codes) {
		state.requestCode = 1
		cmds << secure(zwave.userCodeV1.usersNumberGet())
	} else {
		if(!state.requestCode) state.requestCode = 1
		cmds << requestCode(codeNumber)
	}
	cmds
}

def setCode(codeNumber, code) {
	def strcode = code
	log.debug "setting code $codeNumber to $code"
	if (code instanceof String) {
		code = code.toList().findResults { if(it > ' ' && it != ',' && it != '-') it.toCharacter() as Short }
	} else {
		strcode = code.collect{ it as Character }.join()
	}
	if (state.blankcodes) {
		// Can't just set, we won't be able to tell if it was successful
		if (state["code$codeNumber"] != "") {
			if (state["setcode$codeNumber"] != strcode) {
				state["resetcode$codeNumber"] = strcode
				return deleteCode(codeNumber)
			}
		} else {
			state["setcode$codeNumber"] = strcode
		}
	}
	secureSequence([
		zwave.userCodeV1.userCodeSet(userIdentifier:codeNumber, userIdStatus:1, user:code),
		zwave.userCodeV1.userCodeGet(userIdentifier:codeNumber)
	], 7000)
}

def deleteCode(codeNumber) {
	log.debug "deleting code $codeNumber"
	secureSequence([
		zwave.userCodeV1.userCodeSet(userIdentifier:codeNumber, userIdStatus:0),
		zwave.userCodeV1.userCodeGet(userIdentifier:codeNumber)
	], 7000)
}

def updateCodes(codeSettings) {
	if(codeSettings instanceof String) codeSettings = util.parseJson(codeSettings)
	def set_cmds = []
	def get_cmds = []
	codeSettings.each { name, updated ->
		def current = decrypt(state[name])
		if (name.startsWith("code")) {
			def n = name[4..-1].toInteger()
			log.debug "$name was $current, set to $updated"
			if (updated?.size() >= 4 && updated != current) {
				def cmds = setCode(n, updated)
				set_cmds << cmds.first()
				get_cmds << cmds.last()
			} else if ((current && updated == "") || updated == "0") {
				def cmds = deleteCode(n)
				set_cmds << cmds.first()
				get_cmds << cmds.last()
			} else if (updated && updated.size() < 4) {
				// Entered code was too short
				codeSettings["code$n"] = current
			}
		} else log.warn("unexpected entry $name: $updated")
	}
	if (set_cmds) {
		return response(delayBetween(set_cmds, 2200) + ["delay 2200"] + delayBetween(get_cmds, 4200))
	}
}

def getCode(codeNumber) {
	decrypt(state["code$codeNumber"])
}

def getAllCodes() {
	state.findAll { it.key.startsWith 'code' }.collectEntries {
		[it.key, (it.value instanceof String && it.value.startsWith("~")) ? decrypt(it.value) : it.value]
	}
}

private secure(physicalgraph.zwave.Command cmd) {
	zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
}

private secureSequence(commands, delay=4200) {
	delayBetween(commands.collect{ secure(it) }, delay)
}

private Boolean secondsPast(timestamp, seconds) {
	if (!(timestamp instanceof Number)) {
		if (timestamp instanceof Date) {
			timestamp = timestamp.time
		} else if ((timestamp instanceof String) && timestamp.isNumber()) {
			timestamp = timestamp.toLong()
		} else {
			return true
		}
	}
	return (now() - timestamp) > (seconds * 1000)
}

private allCodesDeleted() {
	if (state.codes instanceof Integer) {
		(1..state.codes).each { n ->
			if (state["code$n"]) {
				result << createEvent(name: "codeReport", value: n, data: [ code: "" ], descriptionText: "code $n was deleted",
					displayed: false, isStateChange: true)
			}
			state["code$n"] = ""
		}
	}
}

// CUSTOM STUFF
def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd) { // Even though you're using V1 to read, ST seems to report it using V2 format, so process as V2
	log.trace "ConfigurationReport $cmd"
	def result = []
    def map = null
    
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        map = schlageConfigurationReport(cmd)
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        map = yaleConfigurationReport(cmd)
    } else if (state.MSR?.startsWith("0090-")) { // Kwikset lock
        map = kwiksetConfigurationReport(cmd)
    } else if (state.MSR?.startsWith("0230-")) { // IDLock
        map = idLockConfigurationReport(cmd)
    } else if (state.MSR?.startsWith("010E-0008")) { // Danalock V2
        map = danaLockConfigurationReportV2(cmd)
    } else if (state.MSR?.startsWith("010E-0009")) { // Danalock V3
        map = danaLockConfigurationReportV3(cmd)
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
    }
    
    log.info map

	result = createEvent(map)
    runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
    result
}

// Parse DanaLock parameters
private danaLockConfigurationReportV3(cmd) {
	log.trace "Processing Danalock Configuration Report V3"
    def map = null

    switch (cmd.parameterNumber) {
        case danalockV3ParamMap.TurnAndGo.Param:
        	map = [descriptionText: "Twist Assist/Turn And Go: ${cmd.configurationValue[0]}"]
            break
            
        case danalockV3ParamMap.BrakeAndGo.Param:
        	map = [descriptionText: "Hold and Release/Brake And Go: ${getDanalockV3ParamMap(cmd.configurationValue).BrakeAndGo.Value} seconds"]
            break
        	
        case danalockV3ParamMap.Async.Param:
        	map = [descriptionText: "Async/Blocked 2 Blocked: ${cmd.configurationValue[0]}"]
            break
        	
        case danalockV3ParamMap.BleTempAllowTimer.Param:
        	map = [descriptionText: "Bluetooth Temporary Allow Timer: ${getDanalockV3ParamMap(cmd.configurationValue).BleTempAllowTimer.Value} seconds"]
            break
        	
        case danalockV3ParamMap.BleAlwaysAllowed.Param:
        	map = [descriptionText: "Bluetooth Always Allowed: ${cmd.configurationValue[0]}"]
            break
        	
        case danalockV3ParamMap.AutoLock.Param:
        	log.warn danalockV3ParamMap.AutoLock.Min
            log.warn getDanalockV3ParamMap(cmd.configurationValue).AutoLock.Value
        	map = [name: "autolock"]
        	switch(getDanalockV3ParamMap(cmd.configurationValue).AutoLock.Value) {
                case danalockV3ParamMap.AutoLock.Min:
                	map.value = "disabled"
                    break
                    
                default:
                    map.value = "enabled"
                    map.descriptionText = "Auto Lock ${getDanalockV3ParamMap(cmd.configurationValue).AutoLock.Value} seconds"
                	break
            }
        	break
        	
		default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
			break
    }
    
    return map
}

private danaLockConfigurationReportV2(cmd) {
	log.trace "Processing Danalock Configuration Report V2"
    def map = null

    switch (cmd.parameterNumber) {
        case 1:
        	map = [descriptionText: "Direction: ${cmd.configurationValue[0]}"]
            break
            
        case 2:
        	map = [descriptionText: "Speed: ${cmd.configurationValue[0]}"]
            break
        	
        case 3:
        	map = [descriptionText: "Mode: ${cmd.configurationValue[0]}"]
            break
        	
        case 4:
        	map = [descriptionText: "Turn degrees: ${cmd.configurationValue[0]}"]
            break
        	
        case 5:
            // Auto Lock
        	map = [name: "autolock"]
            if (cmd.configurationValue[0] > 0) { // Auto lock
                map.value = "enabled"
                map.descriptionText = "Auto Lock ${cmd.configurationValue[0]} seconds"
            } else {
                map.value = "disabled"
            }
            break
        	
        case 6:
        	map = [name: "beeper", descriptionText: "Audio Mode"]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "disabled"
                    break
                    
                case 1:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break
        	
        case 7:
        	map = [descriptionText: "Battery type: ${cmd.configurationValue[0]}"]
            break
        	
        case 8:
        	map = [descriptionText: "Battery alarm level: ${cmd.configurationValue[0]}"]
            break
        	
        case 9:
        	map = [descriptionText: "Turn&Go: ${cmd.configurationValue[0]}"]
            break
        	
        case 10:
        	map = [descriptionText: "Brake&GoBack: ${cmd.configurationValue[0]} seconds"]
            break
        	
        case 11:
        	map = [descriptionText: "Async: ${cmd.configurationValue[0]}"]
            break
        	
        case 12:
        	map = [descriptionText: "Door Lock Operation Report type: ${cmd.configurationValue[0]}"]
            break
        	
		default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
			break
    }
    
    return map
}

// Parse the IDLock parameters
private idLockConfigurationReport(cmd) {
	log.trace "Processing IDLock Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
    	// Configuration parameter 1 is one byte code
        // Bit 0 Auto Lock Status (1: enable)
        // Bit 1 Away Mode Status (1: enable)
    	case 1:
        	// Away Mode
        	map = [name: "codeunlock", descriptionText: "Keypad"]
            if (cmd.configurationValue[0] & 0x2) { // Away Mode enabled = Keypad disable
                map.value = "disabled"
            } else {
                map.value = "enabled"
            }
        	sendEvent(map)
            
            // Auto Lock
        	map = [name: "autolock", descriptionText: "Auto lock"]
            if (cmd.configurationValue[0] & 0x1) { // Auto lock
                map.value = "enabled"
            } else {
                map.value = "disabled"
            }
        	break

		default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
			break
    }
    
    return map
}

// Parse the Kwikset parameters
private kwiksetConfigurationReport(cmd) {
	log.trace "Processing Kwikset Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
    	// Configuration parameter 31 is one byte read only bit mask field that returns the state of the user accessible Dipswitches on the door lock
        // Bit 0 Lock LED Status (1: enable)
        // Bit 1 Auto lock (1: enable)
        // Bit 2 Auto Buzzer (1: enable)
        // Bit 3 Secure Screen (1: enable) *Only for MB 916
    	case 31:
        	// Beeper
            map = [name: "beeper", descriptionText: "Auto Buzzer"]
            if (cmd.configurationValue[0] & 0x4) { // Beeper
                map.value = "enabled"
            } else {
                map.value = "disabled"
            }
        	sendEvent(map)
            
            // Auto Lock
        	map = [name: "autolock", descriptionText: "Auto lock"]
            if (cmd.configurationValue[0] & 0x2) { // Auto lock
                map.value = "enabled"
            } else {
                map.value = "disabled"
            }
        	break

		default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
			break
    }
    
    return map
}

// Parse the Yale parameters
private yaleConfigurationReport(cmd) {
	log.trace "Processing Yale Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
    	case 1: // Beeper
        	map = [name: "beeper", descriptionText: "Audio Mode"]
            switch (cmd.configurationValue[0]) {
            	case 1:
            		map.value = "disabled"
                    break
                    
                case 2:
                case 3:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break
            
    	case 2: // Auto lock
        	map = [name: "autolock", descriptionText: "Auto lock"]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "disabled"
                    break
                    
                case 0xFF:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break
            
    	case 3: // Auto relock time
        	map = [descriptionText: "Auto relock time ${cmd.configurationValue[0]} seconds"]
            break

    	case 4: // Wrong code entry limit
        	map = [descriptionText: "Wrong code entry tamper alert limit ${cmd.configurationValue[0]}"]
            break

    	case 5: // Language
            switch (cmd.configurationValue[0]) {
            	case 0:
                    map = [descriptionText: "Language English"]
                    break

            	case 1:
                    map = [descriptionText: "Language Spanish"]
                    break

            	case 2:
                    map = [descriptionText: "Language French"]
                    break

            	default:
                    map = [descriptionText: "Language Unknown: ${cmd.configurationValue[0]}"]
                    break
            }
        	break

    	case 7: // Shutdown time after wrong entries
        	map = [descriptionText: "Shutdown time ${cmd.configurationValue[0]} seconds"]
            break

    	case 8: // Vacation mode enabled -> Keypad disabled and vice versa
        	map = [name: "codeunlock", descriptionText: "Keypad"]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "enabled"
                    break
                    
                case 1:
                case 2:
                    map.value = "disabled"
                    break
                    
                default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break
            
    	case 11: // One touch locking
        	map = [name: "onetouchlock", descriptionText: "One Touch Locking"]
            switch (cmd.configurationValue[0]) {
            	case 0x0:
            		map.value = "disabled"
                    break

            	case 0xFF:
            		map.value = "enabled"
                    break

            	default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

    	case 12: // Privacy button
            switch (cmd.configurationValue[0]) {
            	case 0x0:
                    map = [descriptionText: "Privacy button off"]
                    break

            	case 0xFF:
                    map = [descriptionText: "Privacy button on"]
                    break

            	default:
                    map = [descriptionText: "Privacy button unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

    	case 13: // Lock status LED
            switch (cmd.configurationValue[0]) {
            	case 0x0:
                    map = [descriptionText: "Lock status LED off"]
                    break

            	case 0xFF:
                    map = [descriptionText: "Lock status LED on"]
                    break

            	default:
                    map = [descriptionText: "Lock status LED unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

    	case 18: // Door propped timer
        	map = [descriptionText: "Door propped ${cmd.configurationValue[0]*10} seconds"]
            break

    	case 19: // DPS Alarm
            switch (cmd.configurationValue[0]) {
            	case 0x0:
                    map = [descriptionText: "Door position sensor state off"]
                    break

            	case 0xFF:
                    map = [descriptionText: "Door position sensor state on"]
                    break

            	default:
                    map = [descriptionText: "Door position sensor state unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
			break
    }
    
    return map
}

// Parse the Schlage parameters
private schlageConfigurationReport(cmd) {
	log.trace "Processing Schlage Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
    	case 0x03: // Beeper
        	map = [name: "beeper", descriptionText: "Beeper"]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "disabled"
                    break
                    
                case 0x1:
                	switch (state.MSR) {
                        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
                			map.value = "enabled"
                        	break
                            
                        default:
	                		map.value = "unknown"
                            map.displayed = false
                            break
                    }
                    break
                    
                case 0xff:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break
            
        case 0x04: // Vacation mode enabled -> Keypad disabled and vice versa
        	map = [name: "codeunlock", descriptionText: "Keypad"]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "enabled"
                    break
                    
                case 0x1:
                	switch (state.MSR) {
                        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
                			map.value = "disabled"
                        	break
                            
                        default:
	                		map.value = "unknown"
                            map.displayed = false
                            break
                    }
                    break
                    
                case 0xff:
                	switch (state.MSR) {
                        case ~/003B-6341-.*/: // Schlage FE/BE469 Generic
                        case ~/003B-6349-.*/: // Schlage BE468 Generic
                        	map.value = "disabled"
                            break
                            
                        default:
                            map.value = "unknown"
                            map.displayed = false
                        	break
                    }
                    break
                    
                default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break
            
    	case 0x05: // Lock and Leave
        	map = [name: "onetouchlock", descriptionText: "Lock and Leave"]
            switch (cmd.configurationValue[0]) {
            	case 0x0:
            		map.value = "disabled"
                    break

            	case 0xFF:
            		map.value = "enabled"
                    break

            	default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break

    	case 0x07: // Lock specific alarm mode
        	map = [name: "alarm", descriptionText: "Alarm Mode"]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "off"
                    break
                    
                case 0x1:
                	map.value = "alert"
                    break
                    
                case 0x2:
                	map.value = "tamper"
                    break
                    
                case 0x3:
                	map.value = "forced"
                    break
                    
                default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break
            
            case 0x08:
            case 0x09:
        	case 0x0A: // Lock specific alarm sensitivity level
        	map = [name: "sensitive", descriptionText: "Alarm Sensitivity Level"]
            switch (cmd.configurationValue[0]) {
            	case 0x1:
            		map.value = "highest"
                    break
                    
                case 0x2:
                	map.value = "high"
                    break
                    
                case 0x3:
                	map.value = "medium"
                    break
                    
                case 0x4:
                	map.value = "low"
                    break
                    
                case 0x5:
                	map.value = "lowest"
                    break
                    
                default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break
            
    	case 0x0F: // Auto lock
        	map = [name: "autolock", descriptionText: "Auto lock"]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "disabled"
                    break
                    
                case 0xff:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    map.displayed = false
                    break
            }
            break
            
    	case 0x10: // Pin code length
        	map = [name: "pinLength", descriptionText: "Pin code length"]
            map.value =  cmd.configurationValue[0]
            break
            
		default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
			break
    }
    
    return map
}

def getPinLength() {
    log.debug "Getting configured user pin code length"
    
    def parameter
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 16
    } else {
        log.warn "Unsupported device with MSR $state.MSR, cannot query pin length"
        sendEvent(name: "pinLength", value: 0) // Not supported
        return null
    }

    switch (state.MSR) { // check if we have a supported device
        // First do specific cases before moving to generic cases with regex matching
        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx
        	log.info "Found Schlage FE5xx/BE3xx, fixed pin length 4 digits"
        	sendEvent(name: "pinLength", value: 4, descriptionText: "Pin code length") // Fixed length 4 digits for these locks
        	return // we're done here no command to send, it's fixed length for these locks
            break
        
        case ~/003B-.*/: // Schlage
        	log.trace "Found Schlage"
            break
            
        default:
        	log.warn "Unrecognized device with MSR $state.MSR, Pin Code Length feature not be available"
        	sendEvent(name: "pinLength", value: 0) // Not supported
            break
    }

	security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}

def getKeypadState() {
    log.debug "Getting keypad state"
    
    def parameter
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 4
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        log.trace "Found Yale"
        parameter = 8
    } else if (state.MSR?.startsWith("0230-")) { // IDLock
        log.trace "Found IDLock"
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
    } else {
        log.warn "Unknown device with MSR $state.MSR, keypad state not available"
        sendEvent(name: "codeunlock", value: "", displayed: false) // Not supported
        return
    }

	security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableKeypad() {
    log.debug "Enabling keypad"
    
    if (!(device.currentState('codeunlock')?.value && (device.currentState('codeunlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Keypad enable feature not available"
        sendEvent(name: "contactDeveloper", value: "Feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 4
        value = [0]
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 8
        value = [0]
    } else if (state.MSR?.startsWith("0230-")) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
        if (device.currentValue("autolock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x0 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("autolock") == "disabled") {
            value = [0x0 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine AutoLock state, not enabling Keypad"
            sendEvent(name: "unknownState", value: "Cannot determine Keypad state, not enabling Keypad", isStateChange: true, displayed: true)
            return
        }
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableKeypad() {
    log.debug "Disabling keypad"
    
    if (!(device.currentState('codeunlock')?.value && (device.currentState('codeunlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Keypad disable feature not available"
        sendEvent(name: "contactDeveloper", value: "Feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 4
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 8
    } else if (state.MSR?.startsWith("0230-")) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def value = []
	switch (state.MSR) { // check if we have a supported device
        // First do specific cases before moving to generic cases with regex matching
        case ~/003B-6341-.*/: // Schlage FE/BE469 Generic
        case ~/003B-6349-.*/: // Schlage BE468 Generic
            value = [255]
            break
            
        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
            value = [1]
            break
                        
        case ~/0109-.*/: // Yale locks
        case ~/0129-.*/: // Yale locks
        	value = [1] // Vacation mode (don't use privacy mode for consistency)
            break
                        
        case ~/0230-0003-.*/: // IDLock
            if (device.currentValue("autolock") == "enabled") { // Away mode enabled = keypad disabled
                value = [0x2 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
            } else if (device.currentValue("autolock") == "disabled") {
                value = [0x2 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
            } else {
                log.error "IDLock device with MSR $state.MSR, cannot determine AutoLock state, not disabling Keypad"
                sendEvent(name: "unknownState", value: "Cannot determine AutoLock state, not disabling Keypad", isStateChange: true, displayed: true)
                return
            }
            break
            
        default:
            value = [255] // Default most Schlage locks use this try it out
        	log.warn "Unknown Schlage device with MSR $state.MSR, contact developer, Keypad disable feature may not work"
        	sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
            break
    }
    
    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def getAudioState() {
    log.debug "Getting audio/beeper state"
    
    def parameter
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 3
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        log.trace "Found Yale"
        parameter = 1
    } else if (state.MSR?.startsWith("0090-") ) { // kwikset lock
        log.trace "Found Kwikset Lock"
        parameter = 31
    } else if (state.MSR?.startsWith("010E-0008")) { // Danalock V2
        log.trace "Found Danalock V2"
        parameter = 6
    } else {
        log.warn "Unknown device with MSR $state.MSR, Audio/Beeper feature not available"
        sendEvent(name: "beeper", value: "", displayed: false) // Not supported
        return
    }

	secure(zwave.configurationV1.configurationGet(parameterNumber: parameter))
}	

def enableAudio() {
    log.debug "Enabling audio/beeper" 

    if (!(device.currentState('beeper')?.value && (device.currentState('beeper')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Audio/Beeper feature not available"
        sendEvent(name: "contactDeveloper", value: "Audio/Beeper feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def value = []
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 3
        switch (state.MSR) {
            case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
            	value = [1]
            	break

            default:
                value = [255]
            	break
        }
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 1
        value = [3]
    } else if (state.MSR?.startsWith("0090-0001")) { // Kwikset does not support setting remotely only reading
        log.trace "Kwikset lock does not support remotely enabling Audio, change settings on the lock"
        sendEvent(name: "invalidCommand", value: "Kwikset lock does not support remotely enabling Audio, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (state.MSR?.startsWith("010E-0008")) { // Danalock V2
        parameter = 6
        value = [1]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

	secureSequence([
		zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
		zwave.configurationV1.configurationGet(parameterNumber: parameter)
	], 5000)
}	

def disableAudio() {
    log.debug "Disabling audio/beeper" 

    if (!(device.currentState('beeper')?.value && (device.currentState('beeper')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Audio/Beeper feature not available"
        sendEvent(name: "contactDeveloper", value: "Audio/Beeper feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def value = []
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 3
        value = [0]
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 1
        value = [1]
    } else if (state.MSR?.startsWith("0090-0001")) { // Kwikset does not support setting remotely only reading
        log.trace "Kwikset lock does not support remotely disabling Audio, change settings on the lock"
        sendEvent(name: "invalidCommand", value: "Kwikset lock does not support remotely disabling Audio, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (state.MSR?.startsWith("010E-0008")) { // Danalock V2
        parameter = 6
        value = [0]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

	secureSequence([
		zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
		zwave.configurationV1.configurationGet(parameterNumber: parameter)
	], 5000)
}	

def getOneTouchLockState() {
    log.debug "Getting OneTouch Lock state"
    
    def parameter
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 5
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        log.trace "Found Yale"
        parameter = 11
    } else {
        log.warn "Unsupported device with MSR $state.MSR, OneTouch Lock feature not supported"
        sendEvent(name: "onetouchlock", value: "", displayed: false) // Not supported
        return
    }
    
	security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableOneTouchLock() {
    log.debug "Enabling OneTouch Lock" 

    if (!(device.currentState('onetouchlock')?.value && (device.currentState('onetouchlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, OneTouch Lock feature not available"
        sendEvent(name: "contactDeveloper", value: "OneTouch Lock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 5
        value = [255]
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 11
        value = [255]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableOneTouchLock() {
    log.debug "Disabling OneTouch Lock"

    if (!(device.currentState('onetouchlock')?.value && (device.currentState('onetouchlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, OneTouch Lock feature not available"
        sendEvent(name: "contactDeveloper", value: "OneTouch Lock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 5
        value = [0]
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 11
        value = [0]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def getAutolockState() {
    log.debug "Getting AutoLock state"
    
    def parameter
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 15
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        log.trace "Found Yale"
        parameter = 2
    } else if (state.MSR?.startsWith("0090-")) { // kwikset lock
        log.trace "Found Kwikset"
        parameter = 31
    } else if (state.MSR?.startsWith("0230-")) { // IDLock
        log.trace "Found IDLock"
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
    } else if (state.MSR?.startsWith("010E-0008")) { // Danalock V2
        log.trace "Found Danalock V2"
        parameter = 5
    } else if (state.MSR?.startsWith("010E-0009")) { // Danalock V3
        log.trace "Found Danalock V3"
        parameter = danalockV3ParamMap.AutoLock.Param
    } else {
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not supported"
        sendEvent(name: "autolock", value: "", displayed: false) // Not supported
        return
    }
    
	security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableAutolock() {
    log.debug "Enabling AutoLock" 

    if (!(device.currentState('autolock')?.value && (device.currentState('autolock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not available"
        sendEvent(name: "contactDeveloper", value: "AutoLock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 15
        value = [255]
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 2
        value = [255]
    } else if (state.MSR?.startsWith("0230-")) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
        if (device.currentValue("codeunlock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x0 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("codeunlock") == "disabled") {
            value = [0x2 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine Away mode state, not enabling AutoLock"
            sendEvent(name: "unknownState", value: "Cannot determine Away mode state, not enabling AutoLock", isStateChange: true, displayed: true)
            return
        }
    } else if (state.MSR?.startsWith("0090-0001")) { // Kwikset does not support setting remotely only reading
        log.trace "Kwikset lock does not support remotely enabling AutoLock, change settings on the lock"
        sendEvent(name: "invalidCommand", value: "Kwikset lock does not support remotely enabling AutoLock, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (state.MSR?.startsWith("010E-0008")) { // Danalock V2
        parameter = 5
        value = [danaRelockTime ? (danaRelockTime <= 60 ? danaRelockTime : 60) : 30] // Default is 30 if not specified in settings, maximum value is 60 for V2 locks
    } else if (state.MSR?.startsWith("010E-0009")) { // Danalock V3
        parameter = danalockV3ParamMap.AutoLock.Param
        value = getDanalockV3ParamMap(danaRelockTime ?: 30).AutoLock.ParamValue // Default is 30 if not specified in settings
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableAutolock() {
    log.debug "Disabling AutoLock"

    if (!(device.currentState('autolock')?.value && (device.currentState('autolock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not available"
        sendEvent(name: "contactDeveloper", value: "AutoLock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 15
        value = [0]
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 2
        value = [0]
    } else if (state.MSR?.startsWith("0230-")) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = 1
        if (device.currentValue("codeunlock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x0 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("codeunlock") == "disabled") {
            value = [0x2 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine Away mode state, not disabling AutoLock"
            sendEvent(name: "unknownState", value: "Cannot determine Away mode state, not disabling AutoLock", isStateChange: true, displayed: true)
            return
        }
    } else if (state.MSR?.startsWith("0090-0001")) { // Kwikset does not support setting remotely only reading
        log.trace "Kwikset lock does not support remotely disabling AutoLock, change settings on the lock"
        sendEvent(name: "invalidCommand", value: "Kwikset lock does not support remotely disabling AutoLock, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (state.MSR?.startsWith("010E-0008")) { // Danalock V2
        parameter = 5
        value = [0]
    } else if (state.MSR?.startsWith("010E-0009")) { // Danalock V3
        parameter = danalockV3ParamMap.AutoLock.Param
        value = getDanalockV3ParamMap(0).AutoLock.ParamValue
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def modes() {
	["off", "alert", "tamper", "forced"]
}

def getModeMap() {
	[
        "off": 0,
        "alert": 1,
        "tamper": 2,
        "forced": 3
	]
}

def getAlarmLevel() {
    log.debug "Getting Alarm Level"
    
    def parameter
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 7
    } else {
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not supported"
        sendEvent(name: "alarm", value: "", displayed: false) // Not supported
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }
    
	security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}

def setAlarm(String newMode) {
    log.debug "Set Alarm level to $newMode"

    if (!(device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (!modes().contains(newMode)) {
        log.error "Request to set unknown Alarm mode $newMode"
        return
    }

	log.info "SetAlarm setting Alarm mode to $newMode -> ${[modeMap[newMode]]}"
    
    def parameter
    def value = []
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 7
        value = [modeMap[newMode]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        delayBetween([
            secure(zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value)),
            secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)),
            getSensitiveLevel(newMode) // Get the level after the alarm
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format(),
            getSensitiveLevel(newMode) // Get the level after the alarm
        ], 5000)
    }
}

def alarmToggle() {
    log.debug "Set Alarm Toggle"

    if (!(device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

	def currentMode = device.currentState("alarm")?.value
	log.trace "AlarmToggle Current Alarm mode is $currentMode"
	if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
    	log.warn "Lock initialization not complete, deferring toggle alarm. Try again later after refreshing lock status."
        return
    }

    def modeOrder = modes()
    def next = { modeOrder[modeOrder.indexOf(it) + 1] ?: modeOrder[0] }
    def nextMode = next(currentMode)
    
    def parameter
    def value = []
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"

        log.info "AlarmToggle Setting Alarm mode to $nextMode -> ${modeMap[nextMode]}"

        parameter = 7
        value = [modeMap[nextMode]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        delayBetween([
            secure(zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value)),
            secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)),
            getSensitiveLevel(nextMode) // Get the level after the alarm
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format(),
            getSensitiveLevel(nextMode) // Get the level after the alarm
        ], 5000)
    }
}

def sensitives() {
	["lowest", "low", "medium", "high", "highest"]
}

def getSensitiveMap() {
	[
        "highest": 1,
        "high": 2,
        "medium": 3,
        "low": 4,
        "lowest" : 5
	]
}

def getSensitiveLevel() {
	def currentMode = device.currentState("alarm")?.value
	getSensitiveLevel(currentMode)
}

def getSensitiveLevel(currentMode) {
    log.debug "Getting Sensitivity Level, current Alarm Mode $currentMode"
    
	if (!(currentMode && (currentMode != "unknown"))) { // Sometime when the initialization is not complete, we get a null here or if Alarm is unsupported we get a unknown, so avoid a crash and wait
    	log.warn "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }
        
    def parameter
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"
        int currentModeValue = modeMap[currentMode]
        log.trace "GetSensitiveLevel Current Alarm mode is $currentMode -> $currentModeValue"
        if (currentMode == "off") { // In off mode there is no sensitivity level
            log.info "There is no sensitive level when alarm is in off mode"
            sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            return
        }
        parameter = 7 + currentModeValue
    } else {
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not supported"
        sendEvent(name: "sensitive", value: "", displayed: false) // Not supported
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }
    
	security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}

def setSensitivity(String newMode) {
    log.debug "Set Alarm Sensitivity to $newMode"

    if (!(device.currentState('sensitive')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm Sensitivity feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (!sensitives().contains(newMode)) {
        log.error "Request to set unknown Alarm sensitivity $newMode"
        return
    }

	def currentMode = device.currentState("alarm")?.value
	if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
    	log.debug "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    def parameter
    def value = []
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"
        int currentModeValue = modeMap[currentMode]
        log.trace "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
        if (currentMode == "off") { // In off mode there is no sensitivity level
            log.info "There is no sensitive level when alarm is in off mode"
            sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            return
        }
        
        log.info "Set Alarm Sensitivity to $newMode -> ${[sensitiveMap[newMode]]}"
        
        parameter = 7 + currentModeValue
        value = [sensitiveMap[newMode]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter),
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format(),
        ], 5000)
    }
}

def sensitiveToggle() {
    log.debug "Set Alarm Sensitivity Toggle"

    if (!(device.currentState('sensitive')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm Sensitivity feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

	def currentMode = device.currentState("alarm")?.value
    if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
    	log.debug "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }
        
    def parameter
    def value = []
    def security = true
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        log.trace "Found Schlage"
        int currentModeValue = modeMap[currentMode]
        log.trace "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
        if (currentMode == "off") { // In off mode there is no sensitivity level
            log.info "There is no sensitive level when alarm is in off mode"
            sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            return
        }

        def currentSensitive = device.currentState("sensitive")?.value
        log.trace "SensitiveToggle Current Alarm sensitivity is $currentSensitive"
        def SensitiveOrder = sensitives()
        def next = { SensitiveOrder[SensitiveOrder.indexOf(it) + 1] ?: SensitiveOrder[0] }
        def nextSensitive = next(currentSensitive)

        log.info "Toggling Alarm Sensitivity to $nextSensitive -> ${sensitiveMap[nextSensitive]}"

        parameter = 7 + currentModeValue
        value = [sensitiveMap[nextSensitive]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter),
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format(),
        ], 5000)
    }
}

def getBatteryState() {
    // Some locks implement non secure reading of battery
    def security = true
    
    if (state.MSR?.startsWith("0230-")) { // IDLock
        security = false
    }
    
    security ? secure(zwave.batteryV1.batteryGet()) : zwave.batteryV1.batteryGet().format()
}

private configureLock() {
    log.trace "$device.displayName: Configuring lock settings"
    def map = null
    
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        map = schlageConfigureLock()
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        map = yaleConfigureLock()
    } else if (state.MSR?.startsWith("0090-")) { // Kwikset lock
        map = kwiksetConfigureLock()
    } else if (state.MSR?.startsWith("0230-")) { // IDLock
        map = idLockConfigureLock()
    } else if (state.MSR?.startsWith("010E-0008")) { // Danalock V2
        map = danaLockConfigureLockV2()
    } else if (state.MSR?.startsWith("010E-0009")) { // Danalock V3
        map = danaLockConfigureLockV3()
    } else {
        log.warn "Unsupported device with MSR $state.MSR"
    }

    return map    
}

private yaleConfigureLock() {
    log.trace "Configure Yale settings"
    def cmds = []
    
    if (yaleWrongCodeLimit) {
        if (yaleWrongCodeLimit >=1 && yaleWrongCodeLimit <= 7) {
            log.info "Setting Wrong Code Tamper Alert threshold to $yaleWrongCodeLimit"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 4, configurationValue: [yaleWrongCodeLimit])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 4)
        } else {
            log.warn "Wrong Code Tamper Alert threshold INVALID (between 1 and 7) -> $yaleWrongCodeLimit"
        }
    }

    if (yaleRelockTime) {
        if (yaleRelockTime >=5 && yaleRelockTime <= 255) {
            log.info "Setting Auto Relock time to $yaleRelockTime seconds"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 3, configurationValue: [yaleRelockTime])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 3)
        } else {
            log.warn "Auto Relock time INVALID (between 5 and 255) -> $yaleRelockTime seconds"
        }
    }
    
    log.info "${yaleDPS ? "Enabling" : "Disabling"} DPS functionality"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: 19, configurationValue: [yaleDPS ? 255 : 0])
    cmds << zwave.configurationV1.configurationGet(parameterNumber: 19)
    
    cmds ? secureSequence(cmds, 5000) : null
}

private kwiksetConfigureLock() {
    log.trace "Configure Kwikset settings"
    def cmds = []
    
    cmds ? secureSequence(cmds, 5000) : null
}

private schlageConfigureLock() {
    log.trace "Configure Schlage settings"
    def cmds = []
    
    cmds ? secureSequence(cmds, 5000) : null
}

private idLockConfigureLock() {
    log.trace "Configure IDLock settings"
    def cmds = []
    
    cmds ? secureSequence(cmds, 5000) : null
}

private danaLockConfigureLockV3() {
    log.trace "Configure Danalock V3 settings"
    def cmds = []
    
    if (danaBrakeGoBack != null && danaBrakeGoBack != "") {
        if (danaBrakeGoBack >= danalockV3ParamMap.BrakeAndGo.Min && danaBrakeGoBack <= danalockV3ParamMap.BrakeAndGo.Max) {
            if (danaBrakeGoBack == danalockV3ParamMap.BrakeAndGo.Min) {
                log.info "Disabling Brake & Go back"
            } else {
                log.info "Setting Brake & Go Back time to $danaBrakeGoBack seconds"
            }

            cmds << zwave.configurationV1.configurationSet(parameterNumber: danalockV3ParamMap.BrakeAndGo.Param, configurationValue: getDanalockV3ParamMap(danaBrakeGoBack).BrakeAndGo.ParamValue)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: danalockV3ParamMap.BrakeAndGo.Param)
        } else {
            log.warn "Brake & Go Back time INVALID (between ${danalockV3ParamMap.BrakeAndGo.Min} and ${danalockV3ParamMap.BrakeAndGo.Max}) -> $danaBrakeGoBack seconds"
        }
    }
    
    if (danaTurnGo != null) {
        if (danaTurnGo) {
            log.info "Enabling Turn & Go"
        } else {
            log.info "Disabling Turn & Go"
        }

        cmds << zwave.configurationV1.configurationSet(parameterNumber: danalockV3ParamMap.TurnAndGo.Param, configurationValue: [danaTurnGo ? danalockV3ParamMap.TurnAndGo.Enabled : danalockV3ParamMap.TurnAndGo.Disabled])
        cmds << zwave.configurationV1.configurationGet(parameterNumber: danalockV3ParamMap.TurnAndGo.Param)
    }
    
    cmds ? secureSequence(cmds, 5000) : null
}

private danaLockConfigureLockV2() {
    log.trace "Configure Danalock V2 settings"
    def cmds = []
    
    if (danaBrakeGoBack != null && danaBrakeGoBack != "") {
        if (danaBrakeGoBack >=0 && danaBrakeGoBack <= 15) {
            if (danaBrakeGoBack == 0) {
                log.info "Disabling Brake & Go back"
            } else {
                log.info "Setting Brake & Go Back time to $danaBrakeGoBack seconds"
            }

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 10, configurationValue: [danaBrakeGoBack])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 10)
        } else {
            log.warn "Brake & Go Back time INVALID (between 0 and 15) -> $danaBrakeGoBack seconds"
        }
    }
    
    if (danaTurnGo != null) {
        if (danaTurnGo) {
            log.info "Enabling Turn & Go"
        } else {
            log.info "Disabling Turn & Go"
        }

        cmds << zwave.configurationV1.configurationSet(parameterNumber: 9, configurationValue: [danaTurnGo ? 1 : 0])
        cmds << zwave.configurationV1.configurationGet(parameterNumber: 9)
    }
    
    if (danaTurnSpeed) {
        if (danaTurnSpeed >=1 && danaTurnSpeed <= 5) {
            log.info "Setting speed to $danaTurnSpeed"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 2, configurationValue: [danaTurnSpeed])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 2)
        } else {
            log.warn "Turn speed INVALID (between 1 and 5) -> $danaTurnSpeed"
        }
    }
        
    cmds ? secureSequence(cmds, 5000) : null
}

def activateSmoke(String msg) {
	log.debug "$device.displayName: Activating smoke alarm sensor"
    sendEvent([ name: "smoke", value: "detected",  descriptionText: msg, displayed: true ])
}

def deactivateSmoke() {
	log.debug "$device.displayName: Deactivating smoke alarm sensor" 
	sendEvent([ name: "smoke", value: "clear",  descriptionText: "$device.displayName: Deactivating smoke/fire alarm sensor", displayed: true ])
}

def resetSmoke() {
	log.debug "$device.displayName: Resetting smoke alarm sensor" 
	sendEvent([ name: "smoke", value: "clear",  descriptionText: "$device.displayName: Resetting smoke/fire alarm sensor", displayed: true ])
}

def activateMotion(String msg) {
	log.debug "$device.displayName: Activating door tampering activity sensor" 
	sendEvent([ name: "motion", value: "active",  descriptionText: msg, displayed: true ])
}

def deactivateMotion() {
	log.debug "$device.displayName: Deactivating door tampering activity sensor" 
	sendEvent([ name: "motion", value: "inactive",  descriptionText: "$device.displayName: Deactivating door tampering activity sensor", displayed: true ])
    sendEvent([ name: "tamper", value: "clear",  descriptionText: "$device.displayName: Deactivating door tampering activity sensor", displayed: true ])
}

def resetMotion() {
	log.debug "$device.displayName: Resetting door tampering activity sensor" 
	sendEvent([ name: "motion", value: "inactive",  descriptionText: "$device.displayName: Resetting door tampering activity sensor", displayed: true ])
    sendEvent([ name: "tamper", value: "clear",  descriptionText: "$device.displayName: Resetting door tampering activity sensor", displayed: true ])
}

def setState(String position, String msg) {
    log.debug "$device.displayName: Setting door sensor: $position" 
    sendEvent([ name: "contact", value: position, descriptionText: msg ])
    sendEvent([ name: "contactX", value: position, displayed: false ])
}

def resetState() {
	log.debug "$device.displayName: Resetting door closed sensor" 
    sendEvent([ name: "contact", value: "closed", descriptionText: "$device.displayName Resetting door sensor as closed", displayed: true ])
    sendEvent([ name: "contactX", value: "unknown", displayed: false ])
}

def reLocked() {
	log.debug "$device.displayName: Sending lock door notification as a follow up the unlocked event for the non motorized deadbolt" 
    def map = [ name: "lock", value: "locked", type: "auto", displayed: true ]
    sendEvent(map)
}

// Dummy code for enabling switch interface on lock (uncomment the capability lock to use this)
def on() {
	lock()
}

def off() {
	unlock()
}

private paramValue(value, bytes) {
    if (value == null || !(value instanceof Number)) {
        return null
    }
        
    //log.trace "Param value: $value, $bytes"

    List<Integer> ret = [] // We start with a Integer list and then convert to array (since arrays are fixed in size)
    for (int i=0; i<bytes; i++) {
        ret = [(((value as Long) >> (i*8)) & 0xFF) as Integer] + ret
    }
    
    //log.debug ret as Integer[]
    
    return ret as Integer[] // We need an integer array
}

private reverseValue(value) {
    if (!value || !List.isCase(value)) {
        return null
    }
        
    //log.trace "Reverse value: $value, $bytes"

    Long ret = 0
    for (int i=0; i<value.size(); i++) {
        ret |= ((((value[i] as Integer) & 0xFF) as Long) << ((value.size() - 1 - i) * 8)) as Long
    }
    
    //log.debug ret
    
    return ret
}

private getDanalockV3ParamMap(value = null) {
	[
        "TurnAndGo": 			[ Param: 1, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ], // Twist Assist
        "BrakeAndGo": 			[ Param: 2, Size: 4, Default: 0, Min: 0, Max: 2147483647, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it }, // Hold and release
        "Async": 				[ Param: 3, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ], // Blocked 2 Blocked
        "BleTempAllowTimer": 	[ Param: 4, Size: 4, Default: 0, Min: 0, Max: 2147483647, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "BleAlwaysAllowed": 	[ Param: 5, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ],
        "AutoLock": 			[ Param: 6, Size: 4, Default: 0, Min: 0, Max: 2147483647, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
	]
}