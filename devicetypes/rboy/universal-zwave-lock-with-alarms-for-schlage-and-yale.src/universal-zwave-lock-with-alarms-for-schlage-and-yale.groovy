/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
/*
 * Modified by RBoy, SmartThings Z-Wave lock base code as of 2015-12-19
 * Changes Copyright RBoy, redistribution of any changes or modified code is not allowed without permission
 * Version 2.6.4
 *
 * Change Log
 * 2016-2-10 - Added support for additional Yale lock devices
 * 2016-2-7 - Fix Support for Yale lock Vacation Mode (Key Code enable/disable)
 * 2016-2-6 - Fixed Yale MSR code check
 * 2016-2-6 - Added support for Yale locks AutoLock and Keypad disable
 * 2016-2-6 - Fixed refresh on configuration
 * 2016-2-3 - Fixed an issue with keypad code enable/disable not working for the BE369
 * 2016-2-3 - Support future version of Schlage locks and fix issue with unsupported Schlage locks (now prompts user to report the new locks to developer but still tries to configure it)
 * 2016-2-2 - Set alarm and sensitive attributes to empty if not supported
 * 2016-2-2 - Fixed alarm status not updating on the tile always, indicate when features are not supported by lock
 * 2016-1-27 - Fix for battery UI broken after upgrade to ST iOS 2.0.8 app
 * 2016-1-27 - Fixed issue with motion sensor for BE469 showing up as 0 in SHM on fresh installation
 * 2016-1-23 - Fixed a bug in getting the MSR for a new lock setup
 * 2016-1-19 - Fixed a bug in base code, codeReport notifications were not always sent to the SmartApp
 * 2015-12-19 - Updated base code and cleaned up
 * 2015-12-9 - Added Dummy commented code for enabling switch capabilities for the lock, uncomment code to enable switch capabilities as requested by users
 * 2015-12-3 - Fix for delay/error in initialization not populating the features sometimes
 * 2015-11-29 - Tweaked the timeout for the relock notification for non motorized deadbolts to 3 seconds
 * 2015-11-29 - Added fix for non motorized deadbolt locks like FE599 not reporting locked after user unlocks the door using a code and it relocks automatically
 * 2015-11-21 - Readded support for attribute "invalidCode" when a user enters an invalid code too many times
 * 2015-11-20 - Corrected text from Auto unlock to Auto lock
 * 2015-11-2 - Added support to set Alarm and Sensivity levels directly from a SmartApp using setAlarm ("off", "alert", "tamper", "forced")and setSensitivity ("highest", "high", "medium", "low", "lowest") commands
 * 2015-9-29 - Added support for Schlage BE369
 * 2015-9-26 - Updated layout and colors
 * 2015-9-23 - Updated colors and layout
 * 2015-9-19 - Added support for MultiAttribute Tiles
 * 2015-7-22 - Updated base code to sync with SmartThings (removed status "invalidCode" and use "tamper" instead)
 * 2015-7-15 - Added support for BE468
 * 2015-7-15 - Improved Jammed status support
 * 2015-6-5 - Added support to get battery level on manual refresh
 * 2015-6-5 - Added support for BE469 and FE599 Schlage locks
 * 2015-2-13 - Added support for auto lock and vacation mode
 * 2015-1-20 - Added support for configuring alarm mode and alarm sensitivity
 * 2015-1-20 - Added support for motion sensor capability for alarm event
 * 2015-1-20 - Added support for door jammed status using capability "invalidCode"
 *
 */
  
 /**
 *  Z-Wave Lock
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */
 
metadata {
	// Automatically generated. Make future change here.
	definition (name: "Universal Z-Wave Lock With Alarms for Schlage and Yale", namespace: "rboy", author: "RBoy") {
		capability "Actuator"
		capability "Lock"
		capability "Polling"
		capability "Refresh"
		capability "Sensor"
		capability "Lock Codes"
		capability "Battery"
        capability "Motion Sensor"
        //capability "Switch" // Uncomment this to enable Switch capability interfaces on lock
        
        attribute "alarm", "string"
        attribute "sensitive", "string"
        attribute "codeunlock", "string"
        attribute "autolock", "string"
        attribute "lockStatus", "string"
        attribute "invalidCode", "string"

		command "unlockwtimeout"
        command "alarmToggle"
        command "setAlarm", ["string"]
        command "sensitiveToggle"
        command "setSensitivity", ["string"]
        command "disableKeypad"
        command "enableKeypad"
        command "enableAutolock"
        command "disableAutolock"

		fingerprint deviceId: "0x4003", inClusters: "0x98"
		fingerprint deviceId: "0x4004", inClusters: "0x98"
	}

	simulator {
		status "locked": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
		status "unlocked": "command: 9881, payload: 00 62 03 00 00 00 FE FE"

		reply "9881006201FF,delay 4200,9881006202": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
		reply "988100620100,delay 4200,9881006202": "command: 9881, payload: 00 62 03 00 00 00 FE FE"
	}

	tiles(scale: 2) {
		multiAttributeTile(name:"toggle", type: "generic", width: 6, height: 4){
			tileAttribute ("device.lock", key: "PRIMARY_CONTROL") {
                attributeState "locked", label:'locked', action:"lock.unlock", icon:"st.locks.lock.locked", backgroundColor:"#79b821", nextState:"unlocking"
                attributeState "unlocked", label:'unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked", backgroundColor:"#ea9900", nextState:"locking"
                attributeState "unknown", label:"jammed", action:"lock.lock", icon:"st.locks.lock.unknown", backgroundColor:"#ff3333", nextState:"locking"
                attributeState "locking", label:'locking', icon:"st.locks.lock.locked", backgroundColor:"#79b821"
                attributeState "unlocking", label:'unlocking', icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff"
			}
			tileAttribute ("device.lockStatus", key: "SECONDARY_CONTROL") {
				attributeState "lockStatus", label:'${currentValue}'
            }
		}
        standardTile("lock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:'Lock', action:"lock.lock", icon:"st.locks.lock.locked", nextState:"locking"
		}
		standardTile("unlock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:'Unlock', action:"lock.unlock", icon:"st.locks.lock.unlocked", nextState:"unlocking"
		}
		standardTile("alarm", "device.alarm", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:"Unsupported", action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-off", nextState:"workingoff"
			state "off", label:'Alarm Off', action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-off", nextState:"workingoff"
			state "alert", label:'Alert Mode', action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-on", nextState:"workingon"
			state "tamper", label:'Tamper Mode', action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-on", nextState:"workingon"
			state "forced", label:'Forced Mode', action:"alarmToggle", icon:"st.quirky.spotter.quirky-spotter-sound-on", nextState:"workingon"
			state "workingoff", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-off", backgroundColor:"#ffffff"
			state "workingon", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff"
		}
		standardTile("sensitive", "device.sensitive", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:"Unsupported", action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "highest", label:'Highest Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "high", label:'High Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "medium", label:'Medium Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "low", label:'Low Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "lowest", label:'Lowest Sensitivity', action:"sensitiveToggle", icon:"st.Health & Wellness.health6", nextState:"working"
			state "working", label:"...", icon:"st.Health & Wellness.health6", backgroundColor:"#ffffff"
		}
		standardTile("codeunlock", "device.codeunlock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:"Unsupported", action:"enableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#ffffff", nextState:"working"
			state "enabled", label:'Code Entry On', action:"disableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#ffffff", nextState:"working"
			state "disabled", label:'Code Off', action:"enableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#fd5050", nextState:"working"
			state "working", label:"...", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#79b8ff"
		}
		standardTile("autolock", "device.autolock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "unknown", label:"Unsupported", action:"disableAutolock", icon:"st.contact.contact.closed", backgroundColor:"#ffffff", nextState:"working"
			state "enabled", label:'AutoLock', action:"disableAutolock", icon:"st.contact.contact.closed", backgroundColor:"#79b821", nextState:"working"
			state "disabled", label:'AutoLock Off', action:"enableAutolock", icon:"st.contact.contact.closed", nextState:"working"
			state "working", label:"...", icon:"st.contact.contact.closed", backgroundColor:"#79b8ff"
		}
		valueTile("battery", "device.battery", inactiveLabel: false, width: 2, height: 2) {
			state "battery", label:'Battery\n ${currentValue}%', unit:"", backgroundColors:[
                [value: 20, color: "#ff0000"],
                [value: 35, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
		}
		standardTile("refresh", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
			state "default", label:'', action:"refresh.refresh", icon:"st.secondary.refresh"
		}

		main "toggle"
		details(["toggle", "lock", "unlock", "codeunlock", "alarm", "sensitive", "autolock", "refresh", "battery"])
	}
}

import physicalgraph.zwave.commands.doorlockv1.*
import physicalgraph.zwave.commands.usercodev1.*

def updated() {
	log.trace "Update called settings: $settings"
	try {
		if (!state.init) {
			state.init = true
		}
        refresh() // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def updateTiles() {
    def lockStatusS = (device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown") ? "Alarm ${device.currentState('alarm')?.value}" + (device.currentState('sensitive')?.value && (device.currentState('sensitive')?.value != "unknown") ? "/${device.currentState('sensitive')?.value} | ": " | ") : "") + "Battery ${device.currentState('battery')?.value}%"
    sendEvent(name: "lockStatus", value: lockStatusS, displayed: false, isStateChange: true)
    log.trace lockStatusS
}

def parse(String description) {
	def result = null
	if (description.startsWith("Err 106")) {
		if (state.sec) {
			result = createEvent(descriptionText:description, displayed:false)
		} else {
			result = createEvent(
				descriptionText: "This lock failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.",
				eventType: "ALERT",
				name: "secureInclusion",
				value: "failed",
				displayed: true,
			)
		}
	} else if (description == "updated") {
		return null
	} else {
		def cmd = zwave.parse(description, [ 0x98: 1, 0x72: 2, 0x85: 2, 0x86: 1 ])
		if (cmd) {
			result = zwaveEvent(cmd)
		}
	}

    updateTiles() // Update the alarm status on the tiles
    
	log.debug "\"$description\" parsed to ${result.inspect()}"
	result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	def encapsulatedCommand = cmd.encapsulatedCommand([0x62: 1, 0x71: 2, 0x80: 1, 0x85: 2, 0x63: 1, 0x98: 1, 0x86: 1])
	// log.debug "encapsulated: $encapsulatedCommand"
	if (encapsulatedCommand) {
		zwaveEvent(encapsulatedCommand)
	}
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.NetworkKeyVerify cmd) {
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Secure inclusion was successful")
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityCommandsSupportedReport cmd) {
	state.sec = cmd.commandClassSupport.collect { String.format("%02X ", it) }.join()
	if (cmd.commandClassControl) {
		state.secCon = cmd.commandClassControl.collect { String.format("%02X ", it) }.join()
	}
	log.debug "Security command classes: $state.sec"
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Lock is securely included")
}

def zwaveEvent(DoorLockOperationReport cmd) {
    log.debug "DoorLockOperationReport $cmd"
	def result = []
	def map = [ name: "lock" ]
	if (cmd.doorLockMode == 0xFF) {
		map.value = "locked"
	} else if (cmd.doorLockMode >= 0x40) {
		map.value = "unknown"
	} else if (cmd.doorLockMode & 1) {
		map.value = "unlocked with timeout"
	} else {
		map.value = "unlocked"
		if (state.assoc != zwaveHubNodeId) {
			log.debug "setting association"
			result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
			result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
			result << response(secure(zwave.associationV1.associationGet(groupingIdentifier:1)))
		}
	}
	result ? [createEvent(map), *result] : createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport cmd) {
	log.debug "AlarmReport $cmd"
	def result = []
	def map = null
	if (cmd.zwaveAlarmType == 6) {
		if (1 <= cmd.zwaveAlarmEvent && cmd.zwaveAlarmEvent < 10) {
			map = [ name: "lock", value: (cmd.zwaveAlarmEvent & 1) ? "locked" : "unlocked" ]
		}
		switch(cmd.zwaveAlarmEvent) {
			case 1:
				map.descriptionText = "$device.displayName was manually locked"
				break
			case 2:
				map.descriptionText = "$device.displayName was manually unlocked"
				break
			case 5:
				if (cmd.eventParameter) {
					map.descriptionText = "$device.displayName was locked with code ${cmd.eventParameter.first()}"
					map.data = [ usedCode: cmd.eventParameter[0] ]
				}
				break
			case 6:
				if (cmd.eventParameter) {
					map.descriptionText = "$device.displayName was unlocked with code ${cmd.eventParameter.first()}"
					map.data = [ usedCode: cmd.eventParameter[0] ]
				}
				break
			case 9:
				map.descriptionText = "$device.displayName was autolocked"
				break
			case 7:
			case 8:
			case 0xA:
				map = [ name: "lock", value: "unknown", descriptionText: "$device.displayName was not locked fully" ]
				break
			case 0xB:
				map = [ name: "lock", value: "unknown", descriptionText: "$device.displayName is jammed" ]
				break
			case 0xC:
				map = [ name: "codeChanged", value: "all", descriptionText: "$device.displayName: all user codes deleted", isStateChange: true ]
				allCodesDeleted()
				break
			case 0xD:
				if (cmd.eventParameter) {
					map = [ name: "codeReport", value: cmd.eventParameter[0], data: [ code: "" ], isStateChange: true ]
					map.descriptionText = "$device.displayName code ${map.value} was deleted"
					map.isStateChange = (state["code$map.value"] != "")
					state["code$map.value"] = ""
				} else {
					map = [ name: "codeChanged", descriptionText: "$device.displayName: user code deleted", isStateChange: true ]
				}
				break
			case 0xE:
				map = [ name: "codeChanged", value: cmd.alarmLevel,  descriptionText: "$device.displayName: user code added", isStateChange: true ]
				if (cmd.eventParameter) {
					map.value = cmd.eventParameter[0]
					result << response(requestCode(cmd.eventParameter[0]))
				}
				break
			case 0xF:
				map = [ name: "codeChanged", descriptionText: "$device.displayName: user code not added, duplicate", isStateChange: true ]
				break
			case 0x10:
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName: keypad temporarily disabled", displayed: true ]
				break
			case 0x11:
				map = [ descriptionText: "$device.displayName: keypad is busy" ]
				break
			case 0x12:
				map = [ name: "codeChanged", descriptionText: "$device.displayName: program code changed", isStateChange: true ]
				break
			case 0x13:
				map = [ name: "invalidCode", value: "detected", descriptionText: "$device.displayName: code entry attempt limit exceeded", displayed: true ]
				break
			default:
				map = map ?: [ descriptionText: "$device.displayName: alarm event $cmd.zwaveAlarmEvent", displayed: false ]
				break
		}
	} else if (cmd.zwaveAlarmType == 7) {
		// Door tamper alarm has been set off ZWAVE_ALARM_TYPE_BURGLAR
        map = [ name: "motion", value: "active",  descriptionText: "$device.displayName: Door tampering activity detected", displayed: true ]
		def runTime = new Date(now() + (60 * 1000))
		runOnce(runTime, deactivateMotion) // Minimum resolution is 60 seconds
        sendEvent(map)
        
		map = [ name: "tamper", value: "detected", displayed: true ]
		switch (cmd.zwaveAlarmEvent) {
			case 0:
				map.value = "clear"
				map.descriptionText = "$device.displayName: tamper alert cleared"
				break
			case 1:
			case 2:
				map.descriptionText = "$device.displayName: intrusion attempt detected"
				break
			case 3:
				map.descriptionText = "$device.displayName: covering removed"
				break
			case 4:
				map.descriptionText = "$device.displayName: invalid code"
				break
			default:
				map.descriptionText = "$device.displayName: tamper alarm $cmd.zwaveAlarmEvent"
				break
		}
	} else switch(cmd.alarmType) {
		case 21:  // Manually locked
		case 18:  // Locked with keypad
		case 24:  // Locked by command (Kwikset 914)
		case 27:  // Autolocked
			map = [ name: "lock", value: "locked" ]
			break
		case 16:  // Note: for levers this means it's unlocked, for non-motorized deadbolt, it's just unsecured and might not get unlocked
        	// Note: Schlage FE599 non motorized deadbolt sends 16 and motorized deadbolts like BE469 send 19. However with non motorized deadbolts it only unsecures the handles and not unlocks, so we need to send a lock event after a few seconds
        	log.trace "Non motorized bolt, resetting unlocked to locked notification in 3 seconds"
            runIn(3, reLocked) // The bolt resecures after 3 seconds, send the locked event notification
		case 19:
			map = [ name: "lock", value: "unlocked" ]
			if (cmd.alarmLevel) {
				map.descriptionText = "$device.displayName was unlocked with code $cmd.alarmLevel"
				map.data = [ usedCode: cmd.alarmLevel ]
			}
			break
		case 22:
		case 25:  // Kwikset 914 unlocked by command
			map = [ name: "lock", value: "unlocked" ]
			break
		case 9:
		case 17:
		case 23:
		case 26:
			map = [ name: "lock", value: "unknown", descriptionText: "$device.displayName bolt is jammed" ]
			break
		case 13:
			map = [ name: "codeChanged", value: cmd.alarmLevel, descriptionText: "$device.displayName code $cmd.alarmLevel was added", isStateChange: true ]
			result << response(requestCode(cmd.alarmLevel))
			break
		case 32:
			map = [ name: "codeChanged", value: "all", descriptionText: "$device.displayName: all user codes deleted", isStateChange: true ]
			allCodesDeleted()
            break
		case 33:
			map = [ name: "codeReport", value: cmd.alarmLevel, data: [ code: "" ], isStateChange: true ]
			map.descriptionText = "$device.displayName code $cmd.alarmLevel was deleted"
			map.isStateChange = (state["code$cmd.alarmLevel"] != "")
			state["code$cmd.alarmLevel"] = ""
			break
		case 112:
			map = [ name: "codeChanged", value: cmd.alarmLevel, descriptionText: "$device.displayName code $cmd.alarmLevel changed", isStateChange: true ]
			result << response(requestCode(cmd.alarmLevel))
			break
		case 130:  // Yale YRD batteries replaced
			map = [ descriptionText: "$device.displayName batteries replaced", isStateChange: true ]
			break
		case 131:
			map = [ /*name: "codeChanged", value: cmd.alarmLevel,*/ descriptionText: "$device.displayName code $cmd.alarmLevel is duplicate", isStateChange: false ]
			break
		case 161:
			if (cmd.alarmLevel == 2) {
				map = [ descriptionText: "$device.displayName front escutcheon removed", isStateChange: true ]
			} else {
				map = [ descriptionText: "$device.displayName detected failed user code attempt", isStateChange: true ]
			}
			break
		case 167:
			if (!state.lastbatt || now() - state.lastbatt > 12*60*60*1000) {
				map = [ descriptionText: "$device.displayName: battery low", isStateChange: true ]
				result << response(secure(zwave.batteryV1.batteryGet()))
			} else {
				map = [ name: "battery", value: device.currentValue("battery"), descriptionText: "$device.displayName: battery low", displayed: true ]
			}
			break
		case 168:
			map = [ name: "battery", value: 1, descriptionText: "$device.displayName: battery level critical", displayed: true ]
			break
		case 169:
			map = [ name: "battery", value: 0, descriptionText: "$device.displayName: battery too low to operate lock", isStateChange: true ]
			break
		default:
			map = [ displayed: false, descriptionText: "$device.displayName: alarm event $cmd.alarmType level $cmd.alarmLevel" ]
			break
	}
	result ? [createEvent(map), *result] : createEvent(map)
}

def zwaveEvent(UserCodeReport cmd) {
	def result = []
	def name = "code$cmd.userIdentifier"
	def code = cmd.code
	def map = [:]
	if (cmd.userIdStatus == UserCodeReport.USER_ID_STATUS_OCCUPIED ||
		(cmd.userIdStatus == UserCodeReport.USER_ID_STATUS_STATUS_NOT_AVAILABLE && cmd.user && code != "**********"))
	{
		if (code == "**********") {  // Schlage locks send us this instead of the real code
			state.blankcodes = true
			code = state["set$name"] ?: decrypt(state[name]) ?: code
			state.remove("set$name".toString())
		}
		if (!code && cmd.userIdStatus == 1) {  // Schlage touchscreen sends blank code to notify of a changed code
			map = [ name: "codeChanged", value: cmd.userIdentifier, displayed: true, isStateChange: true ]
			map.descriptionText = "$device.displayName code $cmd.userIdentifier " + (state[name] ? "changed" : "was added")
			code = state["set$name"] ?: decrypt(state[name]) ?: "****"
			state.remove("set$name".toString())
		} else {
			map = [ name: "codeReport", value: cmd.userIdentifier, data: [ code: code ] ]
			map.descriptionText = "$device.displayName code $cmd.userIdentifier is set"
			map.displayed = (cmd.userIdentifier != state.requestCode && cmd.userIdentifier != state.pollCode)
			map.isStateChange = true
		}
		result << createEvent(map)
	} else {
		map = [ name: "codeReport", value: cmd.userIdentifier, data: [ code: "" ] ]
		if (state.blankcodes && state["reset$name"]) {  // we deleted this code so we can tell that our new code gets set
			map.descriptionText = "$device.displayName code $cmd.userIdentifier was reset"
			map.displayed = map.isStateChange = true
			result << createEvent(map)
			state["set$name"] = state["reset$name"]
			result << response(setCode(cmd.userIdentifier, state["reset$name"]))
			state.remove("reset$name".toString())
		} else {
			if (state[name]) {
				map.descriptionText = "$device.displayName code $cmd.userIdentifier was deleted"
			} else {
				map.descriptionText = "$device.displayName code $cmd.userIdentifier is not set"
			}
			map.displayed = (cmd.userIdentifier != state.requestCode && cmd.userIdentifier != state.pollCode)
			map.isStateChange = true
			result << createEvent(map)
		}
		code = ""
	}
	state[name] = code ? encrypt(code) : code

	if (cmd.userIdentifier == state.requestCode) {  // reloadCodes() was called, keep requesting the codes in order
		if (state.requestCode + 1 > state.codes || state.requestCode >= 30) {
			state.remove("requestCode")  // done
		} else {
			state.requestCode = state.requestCode + 1  // get next
			result << response(requestCode(state.requestCode))
		}
	}
	if (cmd.userIdentifier == state.pollCode) {
		if (state.pollCode + 1 > state.codes || state.pollCode >= 30) {
			state.remove("pollCode")  // done
		} else {
			state.pollCode = state.pollCode + 1
		}
	}
	log.debug "code report parsed to ${result.inspect()}"
	result
}

def zwaveEvent(UsersNumberReport cmd) {
	def result = []
	state.codes = cmd.supportedUsers
	if (state.requestCode && state.requestCode <= cmd.supportedUsers) {
		result << response(requestCode(state.requestCode))
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
	def result = []
	if (cmd.nodeId.any { it == zwaveHubNodeId }) {
		state.remove("associationQuery")
		log.debug "$device.displayName is associated to $zwaveHubNodeId"
		result << createEvent(descriptionText: "$device.displayName is associated")
		state.assoc = zwaveHubNodeId
		if (cmd.groupingIdentifier == 2) {
			result << response(zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		}
	} else if (cmd.groupingIdentifier == 1) {
		result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
	} else if (cmd.groupingIdentifier == 2) {
		result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.timev1.TimeGet cmd) {
	def result = []
	def now = new Date().toCalendar()
	if(location.timeZone) now.timeZone = location.timeZone
	result << createEvent(descriptionText: "$device.displayName requested time update", displayed: false)
	result << response(secure(zwave.timeV1.timeReport(
		hourLocalTime: now.get(Calendar.HOUR_OF_DAY),
		minuteLocalTime: now.get(Calendar.MINUTE),
		secondLocalTime: now.get(Calendar.SECOND)))
	)
	result
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet cmd) {
	// The old Schlage locks use group 1 for basic control - we don't want that, so unsubscribe from group 1
	def result = [ createEvent(name: "lock", value: cmd.value ? "unlocked" : "locked") ]
	result << response(zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId))
	if (state.assoc != zwaveHubNodeId) {
		result << response(zwave.associationV1.associationGet(groupingIdentifier:2))
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "$device.displayName has a low battery"
	} else {
		map.value = cmd.batteryLevel
	}
	state.lastbatt = now()
	createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	log.debug "ManufacturerSpecificReport $cmd"
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)

	result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)
	result
}

def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd) {
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	if (state.MSR == "003B-6341-5044") {
		updateDataValue("ver", "${cmd.applicationVersion >> 4}.${cmd.applicationVersion & 0xF}")
	}
	def text = "$device.displayName: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	createEvent(descriptionText: text, isStateChange: false)
}

def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationBusy cmd) {
	def msg = cmd.status == 0 ? "try again later" :
	          cmd.status == 1 ? "try again in $cmd.waitTime seconds" :
	          cmd.status == 2 ? "request queued" : "sorry"
	createEvent(displayed: true, descriptionText: "$device.displayName is busy, $msg")
}

def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationRejectedRequest cmd) {
	createEvent(displayed: true, descriptionText: "$device.displayName rejected the last request")
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	createEvent(displayed: false, descriptionText: "$device.displayName: $cmd")
}

def lockAndCheck(doorLockMode) {
	secureSequence([
		zwave.doorLockV1.doorLockOperationSet(doorLockMode: doorLockMode),
		zwave.doorLockV1.doorLockOperationGet()
	], 4200)
}

def lock() {
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_SECURED)
}

def unlock() {
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED)
}

def unlockwtimeout() {
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED_WITH_TIMEOUT)
}

def refresh() {
    if (!device.currentValue("motion")?.trim()) { // If the motion sensor state isn't defined then lets define it to report it correctly in SHM
        deactivateMotion()
    }

	def cmds = []

    log.debug "Refresh called, Device MSR is $state.MSR"
	if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
		log.debug "Getting Device MSR"
    	cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format()
	    cmds << "delay 5000"
    }
  	cmds << secure(zwave.doorLockV1.doorLockOperationGet())
    cmds << "delay 5000"
    cmds << getAlarmLevel() // Alarm Level
    cmds << "delay 5000"
    cmds << getCodeunlockState() // Keypad
    cmds << "delay 5000"
	cmds << getAutolockState() // Auto Lock
	cmds << "delay 5000"
    cmds << getSensitiveLevel() // Alarm Sensitivity Level
	cmds << "delay 5000"
    cmds << secure(zwave.batteryV1.batteryGet())
	if (state.assoc == zwaveHubNodeId) {
		log.debug "$device.displayName is associated to ${state.assoc}"
	} else if (!state.associationQuery) {
		log.debug "checking association"
		cmds << "delay 4200"
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()  // old Schlage locks use group 2 and don't secure the Association CC
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		state.associationQuery = now()
	} else if (secondsPast(state.associationQuery, 9)) {
		log.debug "setting association"
		cmds << "delay 6000"
		cmds << zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId).format()
		cmds << secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		state.associationQuery = now()
	}
    if(cmds) cmds << "delay 5000"
	log.trace "refresh sending ${cmds.inspect()}"
	cmds
}

def poll() {
    if (!device.currentValue("motion")?.trim()) { // If the motion sensor state isn't defined then lets define it to report it correctly in SHM
        deactivateMotion()
    }

	def cmds = []

    log.debug "Poll called, Device MSR is $state.MSR"
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format()
        cmds << "delay 5000"
    }

    // Only check lock state if it changed recently or we haven't had an update in an hour
	def latest = device.currentState("lock")?.date?.time
	if (!latest || !secondsPast(latest, 6 * 60) || secondsPast(state.lastPoll, 55 * 60)) {
		cmds << secure(zwave.doorLockV1.doorLockOperationGet())
        cmds << "delay 5000"
        cmds << getAlarmLevel() // Alarm level
        cmds << "delay 5000"
        cmds << getCodeunlockState() // Keypad
        cmds << "delay 5000"
        cmds << getAutolockState() // Auto Lock
        cmds << "delay 5000"
        cmds << getSensitiveLevel() // Alarm Sensitivity Level
		state.lastPoll = now()
	} else if (!state.lastbatt || now() - state.lastbatt > 53*60*60*1000) {
		cmds << secure(zwave.batteryV1.batteryGet())
		state.lastbatt = now()  //inside-214
	}
	if (cmds) {
	    cmds << "delay 6000"
		log.debug "poll is sending ${cmds.inspect()}"
		cmds
	} else {
		// workaround to keep polling from stopping due to lack of activity
        log.trace "Poll called again to soon, skipping poll to save battery"
		sendEvent(descriptionText: "skipping poll", isStateChange: true, displayed: false)
        device.activity()  // workaround to keep polling from being shut off
		null
	}
}

def requestCode(codeNumber) {
	secure(zwave.userCodeV1.userCodeGet(userIdentifier: codeNumber))
}

def reloadAllCodes() {
	def cmds = []
	if (!state.codes) {
		state.requestCode = 1
		cmds << secure(zwave.userCodeV1.usersNumberGet())
	} else {
		if(!state.requestCode) state.requestCode = 1
		cmds << requestCode(codeNumber)
	}
	cmds
}

def setCode(codeNumber, code) {
	def strcode = code
	log.debug "setting code $codeNumber to $code"
	if (code instanceof String) {
		code = code.toList().findResults { if(it > ' ' && it != ',' && it != '-') it.toCharacter() as Short }
	} else {
		strcode = code.collect{ it as Character }.join()
	}
	if (state.blankcodes) {
		// Can't just set, we won't be able to tell if it was successful
		if (state["code$codeNumber"] != "") {
			if (state["setcode$codeNumber"] != strcode) {
				state["resetcode$codeNumber"] = strcode
				return deleteCode(codeNumber)
			}
		} else {
			state["setcode$codeNumber"] = strcode
		}
	}
	secureSequence([
		zwave.userCodeV1.userCodeSet(userIdentifier:codeNumber, userIdStatus:1, user:code),
		zwave.userCodeV1.userCodeGet(userIdentifier:codeNumber)
	], 7000)
}

def deleteCode(codeNumber) {
	log.debug "deleting code $codeNumber"
	secureSequence([
		zwave.userCodeV1.userCodeSet(userIdentifier:codeNumber, userIdStatus:0),
		zwave.userCodeV1.userCodeGet(userIdentifier:codeNumber)
	], 7000)
}

def updateCodes(codeSettings) {
	if(codeSettings instanceof String) codeSettings = util.parseJson(codeSettings)
	def set_cmds = []
	def get_cmds = []
	codeSettings.each { name, updated ->
		def current = decrypt(state[name])
		if (name.startsWith("code")) {
			def n = name[4..-1].toInteger()
			log.debug "$name was $current, set to $updated"
			if (updated?.size() >= 4 && updated != current) {
				def cmds = setCode(n, updated)
				set_cmds << cmds.first()
				get_cmds << cmds.last()
			} else if ((current && updated == "") || updated == "0") {
				def cmds = deleteCode(n)
				set_cmds << cmds.first()
				get_cmds << cmds.last()
			} else if (updated && updated.size() < 4) {
				// Entered code was too short
				codeSettings["code$n"] = current
			}
		} else log.warn("unexpected entry $name: $updated")
	}
	if (set_cmds) {
		return response(delayBetween(set_cmds, 2200) + ["delay 2200"] + delayBetween(get_cmds, 4200))
	}
}

def getCode(codeNumber) {
	decrypt(state["code$codeNumber"])
}

def getAllCodes() {
	state.findAll { it.key.startsWith 'code' }.collectEntries {
		[it.key, (it.value instanceof String && it.value.startsWith("~")) ? decrypt(it.value) : it.value]
	}
}

private secure(physicalgraph.zwave.Command cmd) {
	zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
}

private secureSequence(commands, delay=4200) {
	delayBetween(commands.collect{ secure(it) }, delay)
}

private Boolean secondsPast(timestamp, seconds) {
	if (!(timestamp instanceof Number)) {
		if (timestamp instanceof Date) {
			timestamp = timestamp.time
		} else if ((timestamp instanceof String) && timestamp.isNumber()) {
			timestamp = timestamp.toLong()
		} else {
			return true
		}
	}
	return (now() - timestamp) > (seconds * 1000)
}

private allCodesDeleted() {
	if (state.codes instanceof Integer) {
		(1..state.codes).each { n ->
			if (state["code$n"]) {
				result << createEvent(name: "codeReport", value: n, data: [ code: "" ], descriptionText: "code $n was deleted",
					displayed: false, isStateChange: true)
			}
			state["code$n"] = ""
		}
	}
}

// CUSTOM STUFF
def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd) {
	log.debug "ConfigurationReport $cmd"
	def result = []
    def map = null
    
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        map = schlageConfigurationReport(cmd)
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        map = yaleConfigurationReport(cmd)
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
    }

	result = createEvent(map)
    runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
    result
}

// Parse the Yale parameters
private yaleConfigurationReport(cmd) {
	log.debug "Processing Yale Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
    	case 1: // Beeper
        	map = [name: "beeper", descriptionText: "Beeper", displayed: true, isStateChange: false]
            switch (cmd.configurationValue[0]) {
            	case 1:
            		map.value = "disabled"
                    break
                    
                case 2:
                case 3:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
    	case 8: // Vacation mode enabled -> Keypad disabled and vice versa
        	map = [name: "codeunlock", descriptionText: "Unlock using code", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "enabled"
                    break
                    
                case 1:
                case 2:
                    map.value = "disabled"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
    	case 2: // Auto lock
        	map = [name: "autolock", descriptionText: "Auto lock", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "disabled"
                    break
                    
                case 0xff:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
		default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
			break
    }
    
    return map
}

// Parse the Schlage parameters
private schlageConfigurationReport(cmd) {
	log.debug "Processing Schlage Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
    	case 0x03: // Beeper
        	map = [name: "beeper", descriptionText: "Beeper", displayed: true, isStateChange: false]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "disabled"
                    break
                    
                case 0xff:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
    	case 0x04: // Vacation mode enabled -> Keypad disabled and vice versa
        	map = [name: "codeunlock", descriptionText: "Unlock using code", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "enabled"
                    break
                    
                case 0x1:
                	switch (state.MSR) {
                        case "003B-634B-504C": // Schlage FE599NX CAM 505 ACC 505
                        case "003B-634B-5044": // Schlage BE369
                			map.value = "disabled"
                        	break
                            
                        default:
	                		map.value = "unknown"
                            break
                    }
                    break
                    
                case 0xff:
                	switch (state.MSR) {
                        case "003B-6341-5044": // Schlage BE469NX CAM 716
                        case "003B-6341-7750": // Schlage BE469NX CEN 716
                        case "003B-6349-5044": // Schlage BE468
                        	map.value = "disabled"
                            break
                            
                        default:
                            map.value = "unknown"
                        	break
                    }
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
    	case 0x07: // Lock specific alarm mode
        	map = [name: "alarm", descriptionText: "Alarm Mode", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "off"
                    break
                    
                case 0x1:
                	map.value = "alert"
                    break
                    
                case 0x2:
                	map.value = "tamper"
                    break
                    
                case 0x3:
                	map.value = "forced"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
            case 0x08:
            case 0x09:
        	case 0x0A: // Lock specific alarm sensitivity level
        	map = [name: "sensitive", descriptionText: "Alarm Sensitivity Level", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0x1:
            		map.value = "highest"
                    break
                    
                case 0x2:
                	map.value = "high"
                    break
                    
                case 0x3:
                	map.value = "medium"
                    break
                    
                case 0x4:
                	map.value = "low"
                    break
                    
                case 0x5:
                	map.value = "lowest"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
    	case 0x0F: // Auto lock
        	map = [name: "autolock", descriptionText: "Auto lock", displayed: true, isStateChange: true]
            switch (cmd.configurationValue[0]) {
            	case 0:
            		map.value = "disabled"
                    break
                    
                case 0xff:
                	map.value = "enabled"
                    break
                    
                default:
                	map.value = "unknown"
                    break
            }
            break;
            
		default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
			break
    }
    
    return map
}

def getCodeunlockState() {
    log.debug "Getting keypad code unlock state"
    
    def parameter
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 4
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 8
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "codeunlock", value: "") // Not supported
        return
    }

    switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044": // Schlage BE469NX CAM 716
        case "003B-6341-7750": // Schlage BE469NX CEN 716
        	log.debug "Found Schlage BE469"
            break
            
    	case "003B-6349-5044": // Schlage BE468
        	log.debug "Found Schlage BE468"
            break
            
    	case "003B-634B-504C": // Schlage FE599NX CAM 505 ACC 505
        	log.debug "Found Schlage FE599"
            break
            
        case "003B-634B-5044": // Schlage BE369
            log.debug "Found Schlage BE369"
            break
            
        case ~/0109-0001-.*/: // Yale Touch Lever
        case ~/0129-0001-.*/: // Yale Touch Lever
        	log.debug "Found Yale Touch Lever"
            break
                        
        case ~/0109-0002-.*/: // Yale Touch Deadbolt
        case ~/0129-0002-.*/: // Yale Touch Deadbolt
        	log.debug "Found Yale Touch Deadbolt"
            break
                        
        case ~/0109-0003-.*/: // Yale Push Button Lever
        case ~/0129-0003-.*/: // Yale Push Button Lever
        	log.debug "Found Yale Push Button Lever"
            break
                        
        case ~/0109-0004-.*/: // Yale Push Button Deadbolt
        case ~/0129-0004-.*/: // Yale Push Button Deadbolt
        	log.debug "Found Yale Push Button Deadbolt"
            break
                        
        default:
        	log.debug "Unsupported device with MSR $state.MSR, CodeUnLock feature may not be available"
        	sendEvent(name: "codeunlock", value: "") // Not supported
            break
    }
    
	secure(zwave.configurationV2.configurationGet(parameterNumber: parameter))
}	

def enableKeypad() {
    log.debug "Enabling keypad code unlock"
    
    if (!(device.currentState('codeunlock')?.value && (device.currentState('codeunlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, CodeUnLock feature not available"
        sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 4
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 8
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: parameter, configurationValue: [0]),
		zwave.configurationV2.configurationGet(parameterNumber: parameter)
	], 5000)
}	

def disableKeypad() {
    log.debug "Disabling keypad code unlock"
    
    if (!(device.currentState('codeunlock')?.value && (device.currentState('codeunlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, CodeUnLock feature not available"
        sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 4
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 8
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def lockDisableCode = []
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044": // Schlage BE469NX CAM 716
        case "003B-6341-7750": // Schlage BE469NX CEN 716
    	case "003B-6349-5044": // Schlage BE468
            lockDisableCode = [255]
            break
            
		case "003B-634B-504C": // Schlage FE599NX CAM 505 ACC 505
		case "003B-634B-5044": // Schlage BE369
            lockDisableCode = [1]
            break
                        
        case ~/0109-000[1-4]-.*/: // Yale locks
        case ~/0129-000[1-4]-.*/: // Yale locks
        	lockDisableCode = [1] // Vacation mode (don't use privacy mode for consistency)
            break
                        
        default:
            lockDisableCode = [255] // Default most Schlage locks use this try it out
        	log.warn "Unsupported Schlage device with MSR $state.MSR, CodeUnLock feature may not work properly"
        	sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
            break
    }
	secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: parameter, configurationValue: lockDisableCode),
		zwave.configurationV2.configurationGet(parameterNumber: parameter)
	], 5000)
}	

def getAutolockState() {
    log.debug "Getting auto lock state"
    
    def parameter
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 15
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 2
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "autolock", value: "") // Not supported
        return
    }

	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044": // Schlage BE469NX CAM 716
        case "003B-6341-7750": // Schlage BE469NX CEN 716
        	log.debug "Found Schlage BE469"
            break
            
    	case "003B-6349-5044": // Schlage BE468
        	log.debug "Found Schlage BE468"
            break
            
        case ~/0109-0001-.*/: // Yale Touch Lever
        case ~/0129-0001-.*/: // Yale Touch Lever
        	log.debug "Found Yale Touch Lever"
            break
                        
        case ~/0109-0002-.*/: // Yale Touch Deadbolt
        case ~/0129-0002-.*/: // Yale Touch Deadbolt
        	log.debug "Found Yale Touch Deadbolt"
            break
                        
        case ~/0109-0003-.*/: // Yale Push Button Lever
        case ~/0129-0003-.*/: // Yale Push Button Lever
        	log.debug "Found Yale Push Button Lever"
            break
                        
        case ~/0109-0004-.*/: // Yale Push Button Deadbolt
        case ~/0129-0004-.*/: // Yale Push Button Deadbolt
        	log.debug "Found Yale Push Button Deadbolt"
            break
                        
        default:
        	log.debug "Unsupported device with MSR $state.MSR, Auto Lock feature may not be available"
        	sendEvent(name: "autolock", value: "") // Not supported
            break
    }
    
	secure(zwave.configurationV2.configurationGet(parameterNumber: parameter))
}	

def enableAutolock() {
    log.debug "Enabling auto lock" 

    if (!(device.currentState('autolock')?.value && (device.currentState('autolock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not available"
        sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 15
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 2
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

	secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: parameter, configurationValue: [255]),
		zwave.configurationV2.configurationGet(parameterNumber: parameter)
	], 5000)
}	

def disableAutolock() {
    log.debug "Disabling auto lock"

    if (!(device.currentState('autolock')?.value && (device.currentState('autolock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not available"
        sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    if (state.MSR?.startsWith("003B-")) { // Schlage lock
        parameter = 15
    } else if (state.MSR?.startsWith("0109-") || state.MSR?.startsWith("0129-")) { // Yale lock
        parameter = 2
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

	secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: parameter, configurationValue: [0]),
		zwave.configurationV2.configurationGet(parameterNumber: parameter)
	], 5000)
}	

def modes() {
	["off", "alert", "tamper", "forced"]
}

def getModeMap() {
	[
        "off": 0,
        "alert": 1,
        "tamper": 2,
        "forced": 3
	]
}

def getAlarmLevel() {
    log.debug "Getting Alarm Level"
    
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044": // Schlage BE469NX CAM 716
        case "003B-6341-7750": // Schlage BE469NX CEN 716
        	log.debug "Found Schlage BE469"
            break
            
        default:
        	log.debug "Unsupported device with MSR $state.MSR, Alarm feature may not be available"
        	sendEvent(name: "alarm", value: "") // Not supported
            break
    }
    
    secure(zwave.configurationV2.configurationGet(parameterNumber: 7))
}

def setAlarm(String newMode)
{
    log.debug "Set Alarm level"

    if (!(device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not available"
        sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (!modes().contains(newMode)) {
        log.error "Request to set unknown Alarm mode $newMode"
        return
    }

	log.debug "SetAlarm setting Alarm mode to $newMode -> ${[modeMap[newMode]]}"
    
    delayBetween([
        secure(zwave.configurationV2.configurationSet(parameterNumber: 7, configurationValue: [modeMap[newMode]])),
        secure(zwave.configurationV2.configurationGet(parameterNumber: 7)),
        getSensitiveLevel(newMode) // Get the level after the alarm
    ], 5000)
}

def alarmToggle() {
    log.debug "Set Alarm Toggle"

    if (!(device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not available"
        sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

	def currentMode = device.currentState("alarm")?.value
	log.debug "AlarmToggle Current Alarm mode is $currentMode"
	if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
    	log.warn "Lock initialization not complete, deferring toggle alarm. Try again later after refreshing lock status."
        return
    }
        
	def modeOrder = modes()
	def next = { modeOrder[modeOrder.indexOf(it) + 1] ?: modeOrder[0] }
	def nextMode = next(currentMode)
    
    log.debug "AlarmToggle Setting Alarm mode to $nextMode -> ${modeMap[nextMode]}"
    
    delayBetween([
        secure(zwave.configurationV2.configurationSet(parameterNumber: 7, configurationValue: [modeMap[nextMode]])),
        secure(zwave.configurationV2.configurationGet(parameterNumber: 7)),
        getSensitiveLevel(nextMode) // Get the level after the alarm
    ], 5000)
}

def sensitives() {
	["highest", "high", "medium", "low", "lowest"]
}

def getSensitiveMap() {
	[
        "highest": 1,
        "high": 2,
        "medium": 3,
        "low": 4,
        "lowest" : 5
	]
}

def getSensitiveLevel() {
	def currentMode = device.currentState("alarm")?.value
	getSensitiveLevel(currentMode)
}

def getSensitiveLevel(currentMode) {
    log.debug "Getting Sensitivity Level"
    
	switch (state.MSR) { // check if we have a supported device
    	case "003B-6341-5044": // Schlage BE469NX CAM 716
        case "003B-6341-7750": // Schlage BE469NX CEN 716
        	log.debug "Found Schlage BE469"
            break
            
        default:
        	log.debug "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature may not be available"
        	sendEvent(name: "sensitive", value: "") // Not supported
        	runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            break
    }
    
	if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
    	log.debug "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }
        
	int currentModeValue = modeMap[currentMode]
	log.debug "GetSensitiveLevel Current Alarm mode is $currentMode -> $currentModeValue"
    if (currentMode == "off") { // In off mode there is no sensitivity level
    	log.debug "There is no sensitive level when alarm is in off mode"
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
    	return
    }
    
	secure(zwave.configurationV2.configurationGet(parameterNumber: (7 + currentModeValue)))
}

def setSensitivity(String newMode)
{
    log.debug "Set Alarm Sensitivity"

    if (!(device.currentState('sensitive')?.value && (device.currentState('alarm')?.value != "sensitive"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not available"
        sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (!sensitives().contains(newMode)) {
        log.error "Request to set unknown Alarm sensitivity $newMode"
        return
    }

	def currentMode = device.currentState("alarm")?.value
	if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
    	log.debug "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }
        
    int currentModeValue = modeMap[currentMode]
	log.debug "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
    if (currentMode == "off") { // In off mode there is no sensitivity level
    	log.debug "There is no sensitive level when alarm is in off mode"
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
    	return
    }

	log.debug "Set Sensitivity setting Alarm Sensitivity to $newMode -> ${[sensitiveMap[newMode]]}"
    
    secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: (7 + currentModeValue), configurationValue: [sensitiveMap[newMode]]),
		zwave.configurationV2.configurationGet(parameterNumber: (7 + currentModeValue))
    ], 5000)
}

def sensitiveToggle() {
    log.debug "Set Alarm Sensitivity Toggle"

    if (!(device.currentState('sensitive')?.value && (device.currentState('alarm')?.value != "sensitive"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not available"
        sendEvent(name: "contactDeveloper", value: "Unsupported lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

	def currentMode = device.currentState("alarm")?.value
    if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
    	log.debug "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }
        
    int currentModeValue = modeMap[currentMode]
	log.debug "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
    if (currentMode == "off") { // In off mode there is no sensitivity level
    	log.debug "There is no sensitive level when alarm is in off mode"
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
    	return
    }
    
	def currentSensitive = device.currentState("sensitive")?.value
	log.debug "SensitiveToggle Current Alarm sensitivity is $currentSensitive"
	def SensitiveOrder = sensitives()
	def next = { SensitiveOrder[SensitiveOrder.indexOf(it) + 1] ?: SensitiveOrder[0] }
	def nextSensitive = next(currentSensitive)
    
    log.debug "Setting Alarm sensitivity to $nextSensitive -> ${sensitiveMap[nextSensitive]}"
    
	secureSequence([
		zwave.configurationV2.configurationSet(parameterNumber: (7 + currentModeValue), configurationValue: [sensitiveMap[nextSensitive]]),
		zwave.configurationV2.configurationGet(parameterNumber: (7 + currentModeValue))
	], 5000)
}

def deactivateMotion() {
	log.debug "$device.displayName: Resetting door tampering activity sensor" 
	def map = [ name: "motion", value: "inactive",  descriptionText: "$device.displayName: Resetting door tampering activity sensor", displayed: true ]
    sendEvent(map)
}

def reLocked() {
	log.debug "$device.displayName: Sending lock door notification as a follow up the unlocked event for the non motorized deadbolt" 
    def map = [ name: "lock", value: "locked", displayed: true ]
    sendEvent(map)
}

// Dummy code for enabling switch interface on lock (uncomment the capability lock to use this)
def on() {
	lock()
}

def off() {
	unlock()
}